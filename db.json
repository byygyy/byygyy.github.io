{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":0},{"_id":"source/images/ansible-version.png","path":"images/ansible-version.png","modified":0,"renderable":0},{"_id":"source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":0},{"_id":"source/images/webchat.png","path":"images/webchat.png","modified":0,"renderable":0},{"_id":"source/images/dingyue.png","path":"images/dingyue.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"9117a1fc8af41dfaebdc5e40f06077ad97163c63","modified":1586276339000},{"_id":"themes/landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1586276339000},{"_id":"themes/landscape/.travis.yml","hash":"0f850b4da6ba203ddc399bd7ffd675ca4e3da791","modified":1586276339000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1586276339000},{"_id":"themes/landscape/README.md","hash":"f723575f1243852b8bec9ba05004500b943e20f1","modified":1586276339000},{"_id":"themes/landscape/_config.yml","hash":"ef41d76f07e89f503c93a7d30449347c65c36a76","modified":1586276339000},{"_id":"themes/landscape/package.json","hash":"c35345c642b4ec5287728d3a9e76f5fbeeb8b81c","modified":1586276339000},{"_id":"source/_posts/technology_website.md","hash":"a34e76ca477c11115a9b8bf48ae5ce0a2a410ece","modified":1586276339000},{"_id":"source/images/alipay.png","hash":"ed30c27fa6b8ce20270cc7ff5520fdf0566ec31e","modified":1586276339000},{"_id":"source/images/ansible-version.png","hash":"3134f0cbbe0d16cd4f6f13760dbb932c26048079","modified":1586276339000},{"_id":"source/images/favicon.png","hash":"d7c5344e90a2bcf55736fec7aa9dc72ea47361eb","modified":1586276339000},{"_id":"source/images/webchat.png","hash":"1d27c18aa8d926506d0cd594b0ddf796d42f640f","modified":1586276339000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1586276339000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1586276339000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1586276339000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1586276339000},{"_id":"themes/landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1586276339000},{"_id":"themes/landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1586276339000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1586276339000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1586276339000},{"_id":"themes/landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1586276339000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1586276339000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1586276339000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1586276339000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1586276339000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1586276339000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1586276339000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1586276339000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1586276339000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1586276339000},{"_id":"themes/landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1586276339000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"8cc4b2fe237c246b85dd6d9d004a7752771ae27b","modified":1586276339000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586276339000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586276339000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1586276339000},{"_id":"source/images/dingyue.png","hash":"1c08da0c2f30c5266fd2bd5e38143f6a175d818b","modified":1586276339000},{"_id":"source/_posts/ansible/ansible-playbook-start1.md","hash":"ccec426006008c684ad5ef49f63a3d7c54211b8d","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_async.md","hash":"bce65fea0b917dbe3468b6d797c45bfa57e2958c","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_detele_files.md","hash":"9da5415744048c283be4d1a89ee5e5bebf5aa665","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_download_file.md","hash":"5425d104e295ac8fe751e0e9b850529984a58463","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_error.md","hash":"402600bee071afa8282f082730f700122046306e","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_get_url.md","hash":"35848469bc71c49f19e6cd412d562ee01404be54","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_for_windows.md","hash":"2972c3cac53ee8285035b790ba2a3fbec1820315","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_file_dir.md","hash":"a9ea3691a6f5f624f4a97790344dd19687eadc0d","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_help.md","hash":"aca37c6868f947bad68a649b3d88870039204645","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_install.md","hash":"c0204ac164b0039fda8e0308b910aeff7b660ecc","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_include_vars.md","hash":"8f2163de88a9f50d326e6f9db5e17419a9536af6","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_loop.md","hash":"8f382032c0b382fb1b9c35d0efa6d0f7168f7c12","modified":1587305621000},{"_id":"source/_posts/ansible/ansible_use_module.md","hash":"2de35be88f6bf913bdcef3952b63dbe086b68ae3","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_tower_user_guide.md","hash":"c5d57929e85be3a86dfb2c1b4b884bc38a9287d6","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_permission_modify.md","hash":"a36148808e3119dcae65ba536f7bdda48274062b","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_use_playbook.md","hash":"929f698e91b0ecf8333b9dad65720cf51755453b","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_use_roles.md","hash":"dd97f2587ae2ac19be2dd4b92a0dff2bbd575fc8","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_use_template.md","hash":"6925a5bf245df6cb87771ebdc24335203402367a","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_var_type.md","hash":"d53ed6dbc408c4398234716a40845992a7c8dc90","modified":1586276339000},{"_id":"source/_posts/ansible/ansible_video.md","hash":"b4218b2de3781614c48cb4b2ecb5ff96d54463a5","modified":1586276339000},{"_id":"source/_posts/dev-ops/dev-ops-monitor.md","hash":"c7c4be93916d55cc89f5cc8e2ba01e45e0166718","modified":1586276339000},{"_id":"source/_posts/dev-ops/dev-ops-ci.md","hash":"8d4c14a8eb8bf1be1b0189e21202e089fb888c1a","modified":1586276339000},{"_id":"source/_posts/dev-ops/dev-ops-names.md","hash":"588f5a0e93e3d58aa0e5c5970b42a681fc399f33","modified":1586276339000},{"_id":"source/_posts/dev-ops/dev-ops-question.md","hash":"690e50e9c100126be9c1a847f89e422e4a85f8aa","modified":1586276339000},{"_id":"source/_posts/docker/docker-quick-start.md","hash":"6d26358e0e9e0df9c064aa194774f13fc385dced","modified":1586276339000},{"_id":"source/_posts/docker/podman-namaspace-error.md","hash":"6191acde251a44912ade3e0d7b685081e3d5a375","modified":1587825400000},{"_id":"source/_posts/jenkins/jenkins_base.md","hash":"486e2cd283eee11f6b8cf5edde2ec69f531f35ea","modified":1586276339000},{"_id":"source/_posts/linux/linux-awk.md","hash":"86fc3fc484687034ec9c91814cc3ed10f9b778d1","modified":1586276339000},{"_id":"source/_posts/jenkins/jenkins_hello_world.md","hash":"4f898c24997b5193563d377b66a8700b7251882e","modified":1586276339000},{"_id":"source/_posts/linux/linux-echo.md","hash":"68d9427262ab486918a22ac303a58249359e9bc8","modified":1586276339000},{"_id":"source/_posts/linux/linux-grep.md","hash":"b69181f43255143823fad7b5e1f5c58bdebcdae6","modified":1586276339000},{"_id":"source/_posts/linux/linux-sed.md","hash":"d54297ff8a82c5b72c71c404944192a5320c9d2b","modified":1586276339000},{"_id":"source/_posts/linux/linux-why-learn.md","hash":"c5d0749c30f330116377f9218000e86fb4ae15af","modified":1586276339000},{"_id":"source/_posts/linux/linux_file_dir_manager.md","hash":"1daeb45bf402062bb867dd929d8de16b825969da","modified":1586276339000},{"_id":"source/_posts/linux/linux_env_var.md","hash":"2572e6876f9be96a11ba0b644036bfed0599bb69","modified":1586276339000},{"_id":"source/_posts/linux/linux_auto_start.md","hash":"4fd9256cdb72a4938c5ee256b7421140618d35cf","modified":1586276339000},{"_id":"source/_posts/linux/linux_alias_use.md","hash":"91c042f89d1b6e3aa79c0235cbbe9dc81d59f9d9","modified":1586276339000},{"_id":"source/_posts/linux/linux_file_dir_permission.md","hash":"4182dfd787bc15e86d08c141450a3ef4e48eb7a9","modified":1586276339000},{"_id":"source/_posts/linux/linux_mount_nas.md","hash":"a7e0bc4a4077fdf64fb11e1f625d6579f146bb31","modified":1586276339000},{"_id":"source/_posts/linux/linux_login_with_cert.md","hash":"e3761b2af8f147e44582e97590eea21cc0244cb3","modified":1586276339000},{"_id":"source/_posts/linux/linux_how_to_learn.md","hash":"49e11de64c442490e92dd17fd74f0dac80239a34","modified":1586276339000},{"_id":"source/_posts/linux/linux_parameter_send1.md","hash":"1a7d3676d27050313084458319830e2f6713b01a","modified":1586276339000},{"_id":"source/_posts/linux/linux_performance.md","hash":"78d5e02ea0a22f0d33775f0f9104fc50c66c27e8","modified":1586276339000},{"_id":"source/_posts/linux/linux_program.md","hash":"9f7b8d11381eb1e35b9c727fc16dd42806c690b4","modified":1586276339000},{"_id":"source/_posts/linux/linux_pipe.md","hash":"7adbb5ed005aabd8a799041c9005a2c91b33718f","modified":1586276339000},{"_id":"source/_posts/linux/linux_shel_under.md","hash":"245ae8e1606f7d201711530ab5c367092521ce06","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_condition.md","hash":"673749d3d03a2566ef730e5b5e6fd95d63ae54d2","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_for.md","hash":"36d512ea272ac243fc16700cae6aec4be3a3deb2","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_input.md","hash":"2e131466b9877e3758d3881fc4e1d81164a31a59","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_output.md","hash":"986b52814b728d1e0bd1551b72db41ada9f3ad07","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_output_input.md","hash":"468202bb01fcd70aaea3d40030343f4f4c110fd1","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_popular_command.md","hash":"79fd3ad0e4d43fa81d01e8a7fdf4be7b961c1441","modified":1586276339000},{"_id":"source/_posts/linux/linux_shell_vars.md","hash":"3b0e95f7434ca7d01a27524f72d8d0cc9f1aefc6","modified":1586276339000},{"_id":"source/_posts/linux/linux_support_ansible.md","hash":"233c8ab4e0083cd4344cc7ee192f05660836e9f1","modified":1586276339000},{"_id":"source/_posts/network/ddns_ipv6.md","hash":"d29e43578024d756515a0bb87c3d3325a5d387c1","modified":1586276339000},{"_id":"source/_posts/other/copy-to-csdn.md","hash":"252976f9c4bbd3bd189ed711c34b6c68b885ecb9","modified":1586276339000},{"_id":"source/_posts/network/natapp.md","hash":"0638bcd9eaedbe42e3fd20328a982d2bcc296036","modified":1586276339000},{"_id":"source/_posts/other/do-less-going-on.md","hash":"b1200362a9e6183d059f098e2efc58ce1d2daf80","modified":1586276339000},{"_id":"source/_posts/other/hello-world.md","hash":"458dd8df1e7b396118a0fa032de15c067a603d00","modified":1586276339000},{"_id":"source/_posts/python/MySQL-python-install.md","hash":"cee02d8352ef035b76040517006c3f66d01c0a77","modified":1586276339000},{"_id":"source/_posts/python/python_auto_start.md","hash":"9c0dade4bda2d490e67f19ac7c393c2b25831541","modified":1586276339000},{"_id":"source/_posts/python/python_name_standard.md","hash":"aa7a72bbf2d4ce1259f973aaefb6192fbc896665","modified":1586276339000},{"_id":"source/_posts/python/python_pip_install.md","hash":"0c0c967a796a1cdde23ba639f32047021d45bde0","modified":1586276339000},{"_id":"source/_posts/python/python_web.py.md","hash":"f7850285387a7be244d4f29750758d42353877d0","modified":1586276339000},{"_id":"source/_posts/python/python_web_sea.md","hash":"a835162c6e375eeed726e8ef9b50541e80f8427e","modified":1586276339000},{"_id":"source/_posts/tools/atom_plus_1.md","hash":"11c45dcf5107f38988c367d107341027f2372d0c","modified":1586276339000},{"_id":"source/_posts/tools/github quick start.md","hash":"bbf538064c5dc834d8edaa67e951b5b144a37749","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"b324200b3ed2468ff5be9a224729249b3d6d0021","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"7d44738f6a21accafea7aa65642d3064fa7cf2fd","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/donate.ejs","hash":"b7a91712027832a813cf112eaa7d70d9f2f2de59","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"b1b229f74bb9b44d4fd4efe6a8d704fc0c742abd","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"997923d389ba294e89ce1d3a23b063b6e210a197","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1586276339000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1586276339000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1586276339000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1586276339000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1586276339000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1586276339000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1586276339000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1586276339000},{"_id":"themes/landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1586276339000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1586276339000},{"_id":"themes/landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1586276339000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1586276339000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1586276339000},{"_id":"themes/landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/donate.styl","hash":"f679100447748650a2eaa6ac3a3b57895738ff65","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1586276339000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1586276339000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1586276339000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1586276339000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1586276339000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1586276339000},{"_id":"public/404.html","hash":"8bf6faea9b15c4dc971f46c3723b87c4b44aae58","modified":1588260636608},{"_id":"public/2099/04/24/technology_website/index.html","hash":"c207a4ef67a9750a0b2f454c772e067898f9ae69","modified":1588260636608},{"_id":"public/2020/04/23/docker/podman-namaspace-error/index.html","hash":"fbc955de2d62f08c504c635a7760c625e5f31c33","modified":1588260637847},{"_id":"public/2020/04/01/jenkins/jenkins_hello_world/index.html","hash":"4ae1edb0bfaf734da5ab8547b50bcf091d5ec700","modified":1588260637939},{"_id":"public/2020/04/05/jenkins/jenkins_base/index.html","hash":"3fb4656d1fbd7c1a528760d5fd387d2859579f2b","modified":1588260637939},{"_id":"public/2020/04/19/ansible/ansible_loop/index.html","hash":"2be001a7cccfc24bf332b7c8439c0bfba9ae1f7d","modified":1588260637939},{"_id":"public/2020/03/29/linux/linux_performance/index.html","hash":"ae4727d709a8a0bc59c059dadcc072c9f2c16b8a","modified":1588260637939},{"_id":"public/2020/03/17/linux/linux_shell_for/index.html","hash":"7769524788663e9c4fbf11a3cbc34de29c464d07","modified":1588260637939},{"_id":"public/2020/03/16/linux/linux_shell_condition/index.html","hash":"761ddbd5caaaaabe5c4471122774c1515322c561","modified":1588260637939},{"_id":"public/2020/03/15/linux/linux_shell_output_input/index.html","hash":"459f2082cfe35e8d60abd97b3dcd02f1e6a680ba","modified":1588260637940},{"_id":"public/2020/03/14/linux/linux_shell_vars/index.html","hash":"c9c483be3d2b0c05a7a18340759f7dd73b165583","modified":1588260637940},{"_id":"public/2020/03/13/linux/linux_alias_use/index.html","hash":"83944a4de094ab8e7de34219e6f8dfdfcdfdfb7f","modified":1588260637940},{"_id":"public/2020/03/12/linux/linux_how_to_learn/index.html","hash":"ccba0d4f69e8e0543056c4824317807728c93250","modified":1588260637940},{"_id":"public/2020/03/21/linux/linux_shell_output/index.html","hash":"2138f134de4d867ea3b4b7eeceaaa8cb2badd809","modified":1588260637940},{"_id":"public/2020/03/10/linux/linux_file_dir_permission/index.html","hash":"ea6fbe3b30fd60e928d8400845de7827254ad1d0","modified":1588260637940},{"_id":"public/2020/03/08/linux/linux_pipe/index.html","hash":"db1aaff593c73142f43f82e0a2f7b0c5c1e42a31","modified":1588260637940},{"_id":"public/2020/03/07/linux/linux_env_var/index.html","hash":"aa81de8c793fdbc81fcc7cb1597577abe1098a35","modified":1588260637940},{"_id":"public/2020/03/06/linux/linux_shel_under/index.html","hash":"a8f4e2f53585357e80cf10f6758e4a12e9b9ad30","modified":1588260637940},{"_id":"public/2020/03/05/linux/linux-why-learn/index.html","hash":"639f3b4bc7461516d261fff346d831261c3c8b99","modified":1588260637940},{"_id":"public/2020/03/04/linux/linux-sed/index.html","hash":"81827024412fb9a06878431c7104fd09b3c55751","modified":1588260637941},{"_id":"public/2020/03/03/linux/linux-awk/index.html","hash":"ac664067b4008c640f08fac7d9229158ee8eface","modified":1588260637941},{"_id":"public/2020/03/24/linux/linux_program/index.html","hash":"04854360a3f76606b793d41fb1a7ad351492a889","modified":1588260637941},{"_id":"public/2020/03/01/linux/linux-echo/index.html","hash":"45a8f9ca036ca9e0f8649e12e9a06a819920ad10","modified":1588260637941},{"_id":"public/2020/03/19/linux/linux_shell_input/index.html","hash":"7838af07097766b98ac41bf136d9a6593f78f00b","modified":1588260637941},{"_id":"public/2020/02/28/dev-ops/dev-ops-question/index.html","hash":"a18457458122639eee0fc915230573689abd499a","modified":1588260637941},{"_id":"public/2020/02/27/dev-ops/dev-ops-monitor/index.html","hash":"4d2728ff3e5380666f59fa67f368da30afe9e4c3","modified":1588260637941},{"_id":"public/2020/02/26/dev-ops/dev-ops-ci/index.html","hash":"76c81d27c4b21b955c35cd8e5b8a96ea921b10c0","modified":1588260637941},{"_id":"public/2020/02/24/other/copy-to-csdn/index.html","hash":"1c806002d5a67087e5d3e9b45883a7df58cd2d78","modified":1588260637941},{"_id":"public/2020/03/02/linux/linux-grep/index.html","hash":"171ad15128240086e45352fe508b4b8ec413c085","modified":1588260637941},{"_id":"public/2020/02/12/ansible/ansible_use_module/index.html","hash":"77fb7319114913eda251e12562599fd33d79d3e4","modified":1588260637941},{"_id":"public/2020/02/11/ansible/ansible_var_type/index.html","hash":"ea87c0cdc760f6b90e0f4077e6a2b0080ce3ceda","modified":1588260637941},{"_id":"public/2020/02/04/linux/linux_support_ansible/index.html","hash":"5ddad36234e632137a84753181a504f8153b5409","modified":1588260637941},{"_id":"public/2019/12/21/ansible/ansible_video/index.html","hash":"eaa541d5412d7cfe227f78d8683febeed5bcd32c","modified":1588260637941},{"_id":"public/2019/12/21/network/natapp/index.html","hash":"0e7b2b4a15a8d7a2d56836b74965d801e1e70ef7","modified":1588260637941},{"_id":"public/2019/12/21/ansible/ansible_include_vars/index.html","hash":"bd3d9e29c8c3ef38dcaed8233f71fc4cac7ff57e","modified":1588260637942},{"_id":"public/2020/03/11/linux/linux_file_dir_manager/index.html","hash":"836db5c047aeab77a2a27b41b4067915f74f6509","modified":1588260637942},{"_id":"public/2019/12/16/ansible/ansible_use_roles/index.html","hash":"3bc662eb04135dabea1596dc8f1f8aa6f9c7f156","modified":1588260637942},{"_id":"public/2019/12/12/ansible/ansible_use_playbook/index.html","hash":"7d59a903e6d8bbb4059c14fe2051479d4a58dc6f","modified":1588260637942},{"_id":"public/2019/12/16/ansible/ansible_use_template/index.html","hash":"c89bc1d37bab8ff2216f2dcdd40df42a31f0755d","modified":1588260637942},{"_id":"public/2019/11/27/ansible/ansible_download_file/index.html","hash":"9ce49eab9e8d24504ac4c5767e4a20bd794d1aa0","modified":1588260637942},{"_id":"public/2019/11/22/ansible/ansible_async/index.html","hash":"9db832be26529e9e8f0ff9af7e9607f4cc6a7943","modified":1588260637942},{"_id":"public/2019/11/22/ansible/ansible_help/index.html","hash":"6bc3a0ecac37dd9efcb5a5fb2e0236b07a6eb21c","modified":1588260637942},{"_id":"public/2019/11/22/ansible/ansible_permission_modify/index.html","hash":"2715b9aef09e13b7b343a33579e3e17ac678f043","modified":1588260637942},{"_id":"public/2020/02/29/dev-ops/dev-ops-names/index.html","hash":"074a4cfcd9d6d37dc4dd5405823f15bcafa46c27","modified":1588260637942},{"_id":"public/2019/11/20/linux/linux_shell_popular_command/index.html","hash":"9fec5bc4261f03da649dd9e3563ccde68e136cbf","modified":1588260637942},{"_id":"public/2019/07/30/linux/linux_auto_start/index.html","hash":"2fc411413fe228d81a573f42df8d88c37e3a8ddb","modified":1588260637943},{"_id":"public/2019/06/22/ansible/ansible_file_dir/index.html","hash":"fc035898eed122b0f6f92d31e4f9102fdd768805","modified":1588260637943},{"_id":"public/2019/06/22/ansible/ansible_get_url/index.html","hash":"3340e7dbc366c52eec483f10327111cb74ec76f4","modified":1588260637943},{"_id":"public/2019/06/20/ansible/ansible_install/index.html","hash":"ee094024e0fc9401868c2faa3a9f18c306eb25cb","modified":1588260637943},{"_id":"public/2019/03/21/network/ddns_ipv6/index.html","hash":"efbc456483370940d0c67a0f3510fd780bf7385d","modified":1588260637943},{"_id":"public/2020/02/23/ansible/ansible_error/index.html","hash":"21e3279a7a2a5bc4e69a39c24cbee2fa1d6fba9b","modified":1588260637944},{"_id":"public/2019/03/17/ansible/ansible_detele_files/index.html","hash":"08973cccb7fdd56319871feba3d9fcf3ad4da9c4","modified":1588260637944},{"_id":"public/2019/03/15/docker/docker-quick-start/index.html","hash":"b18992c19c9b5a79d78d083a5bf343991e20cc72","modified":1588260637944},{"_id":"public/2019/03/14/other/do-less-going-on/index.html","hash":"a8ad68e0f5710964eb7398fdaaeb13ed37792be7","modified":1588260637944},{"_id":"public/2019/03/14/tools/atom_plus_1/index.html","hash":"96c01ab3f5ff37e3b27875bf88bb4f7e8b1a4fb6","modified":1588260637944},{"_id":"public/2019/03/14/ansible/ansible_tower_user_guide/index.html","hash":"e588edc083526bae829060a04774c868d243f166","modified":1588260637944},{"_id":"public/2019/03/11/linux/linux_parameter_send1/index.html","hash":"eb3da46c955bf961bbb7027dde6c18e402ea940b","modified":1588260637944},{"_id":"public/2019/03/11/ansible/ansible-playbook-start1/index.html","hash":"6b22a855206dcd2cf2c6f7b8c10497f183ade0c6","modified":1588260637944},{"_id":"public/2019/03/05/tools/github quick start/index.html","hash":"3d3d06817fa15bc8b5f1dd52a6c65aa6f47df5b3","modified":1588260637944},{"_id":"public/2019/02/24/python/python_name_standard/index.html","hash":"9174d01bd9eedd5fadbf413f55fa860a9079ee4b","modified":1588260637944},{"_id":"public/2019/02/24/python/python_web_sea/index.html","hash":"29722ce7e1154b90d223a4f3697b8596f5f97218","modified":1588260637944},{"_id":"public/2019/02/11/other/hello-world/index.html","hash":"f51670b3345bd02740d41d41cec99103b3d6fb24","modified":1588260637944},{"_id":"public/2019/01/22/python/python_web.py/index.html","hash":"92f25a832e791e3e299a4dd1073ac77b1fdceeb7","modified":1588260637944},{"_id":"public/2018/12/24/python/python_auto_start/index.html","hash":"f2e5051953493acda63f8cd477f20a6c513b4301","modified":1588260637944},{"_id":"public/2018/12/03/linux/linux_login_with_cert/index.html","hash":"b9a5e8a5b35c11b71fdd060632b1748f0cf59c30","modified":1588260637944},{"_id":"public/2018/02/26/python/python_pip_install/index.html","hash":"b7a3c70e2d13bf7ddb10ad7e098f951a7fa687a8","modified":1588260637944},{"_id":"public/archives/index.html","hash":"f85e7e18e3b05543044119641d778be27164e24c","modified":1588260637944},{"_id":"public/2019/03/17/python/MySQL-python-install/index.html","hash":"a5341411239d90e1af04b5f099694b0fe5021ad9","modified":1588260637944},{"_id":"public/archives/page/3/index.html","hash":"c9b2c8446acd13f91434647196c3af326dbec0b5","modified":1588260637944},{"_id":"public/archives/page/4/index.html","hash":"a6fd7900a736c3865aa136afbfd64d03be30a38e","modified":1588260637945},{"_id":"public/archives/2018/index.html","hash":"3f14ce7ad93184e3c0e0fc4021735b1004f12251","modified":1588260637945},{"_id":"public/archives/2018/02/index.html","hash":"76c253add1898cfa1e85e2fcd523a6b024981776","modified":1588260637945},{"_id":"public/archives/2018/12/index.html","hash":"3aa85d178c1b016a2e2360a1140ea28082e3e3bf","modified":1588260637945},{"_id":"public/archives/2019/index.html","hash":"5cebbd07a5071804f0154e8fd15497ace5ea3a85","modified":1588260637945},{"_id":"public/archives/2019/page/2/index.html","hash":"f568ea1ad4d3508bf0d357ef5137cfade97c4205","modified":1588260637945},{"_id":"public/archives/2019/01/index.html","hash":"7577f0304dd02c33d8cffc2d3c88edcefe548cd9","modified":1588260637945},{"_id":"public/archives/2019/02/index.html","hash":"91e7e8663b93f5ec4387e8a5be20a96e31ad9e62","modified":1588260637945},{"_id":"public/archives/2019/03/index.html","hash":"04ee817c4eb7b4ade6e8fa7a6cc212f0ff64cb7d","modified":1588260637945},{"_id":"public/archives/2019/06/index.html","hash":"946e7b56a6b1e8f99f250886fa6d141b9598e564","modified":1588260637945},{"_id":"public/archives/2019/07/index.html","hash":"e5f74984d757c39a7f3d40a21e55560213c9e219","modified":1588260637945},{"_id":"public/archives/2019/11/index.html","hash":"43484aebe810effa189aafd6b9fc056476ea3db7","modified":1588260637945},{"_id":"public/archives/2019/12/index.html","hash":"74d6f7a5bb2fb555f38922fe847dcf3bdf795a73","modified":1588260637945},{"_id":"public/archives/2020/index.html","hash":"6e25457a945a1e9e2fd8e9a94b2a18c1b8e1e256","modified":1588260637945},{"_id":"public/archives/2020/page/2/index.html","hash":"c60b619e5a11d65ca63a439ff178284f2af5076b","modified":1588260637945},{"_id":"public/archives/2020/02/index.html","hash":"fdf50c45a6b582af9430c8a2bf7532d3b82c62f5","modified":1588260637946},{"_id":"public/archives/page/2/index.html","hash":"bfe2c5e037299d7e72145a37eabf86cc13b23abe","modified":1588260637946},{"_id":"public/archives/2020/04/index.html","hash":"063b1546717d7ab57cc0d7077670bbdd8ca0375a","modified":1588260637946},{"_id":"public/archives/2099/index.html","hash":"e27837413f81cabc3d1d86907b66c60ce664b11b","modified":1588260637946},{"_id":"public/archives/2099/04/index.html","hash":"7d9abf41be3baa66145ebefd82722dad74b7f094","modified":1588260637946},{"_id":"public/categories/other/index.html","hash":"e52458f28e0881c731195796df7f246940321919","modified":1588260637946},{"_id":"public/2019/11/21/linux/linux_mount_nas/index.html","hash":"dc4088a91a609bc8b9218462edb67effd31cf970","modified":1588260637946},{"_id":"public/categories/dev-ops/index.html","hash":"318d0679ab1dc57a5f84eae10c72205497269b8b","modified":1588260637946},{"_id":"public/categories/docker/index.html","hash":"f7fcbbd9973442e1ef52bb9cdadadfdf5f2ce001","modified":1588260637946},{"_id":"public/categories/jenkins/index.html","hash":"c75aaed7bcd09f45f51332becad456f8fdbc3670","modified":1588260637946},{"_id":"public/archives/2020/03/index.html","hash":"36d6bbc1de6a49f2bb26254bdf6ffc762419b9ff","modified":1588260637946},{"_id":"public/2019/11/26/ansible/ansible_for_windows/index.html","hash":"75825a07eec9be73c7c6725c70922bbb013041bf","modified":1588260637946},{"_id":"public/categories/ansible/index.html","hash":"1cd9b90bea83fca1634bdd4cfdefc76ab17684e2","modified":1588260637946},{"_id":"public/categories/network/index.html","hash":"694383065c0d0b2f9d7216e666bc6d520f4e0647","modified":1588260637946},{"_id":"public/categories/linux/page/2/index.html","hash":"f759029b48557ea79ca8ecfc0cd15028d02a8682","modified":1588260637946},{"_id":"public/index.html","hash":"5a2affe956f4bf15a83b7aab3a08996553f94a3d","modified":1588260637947},{"_id":"public/page/2/index.html","hash":"dc68d24d9be5b6d0b6e48d524f25c6dd5c481019","modified":1588260637947},{"_id":"public/page/3/index.html","hash":"376df39c1f0ca252ac443bb0c089e38735c2cc98","modified":1588260637947},{"_id":"public/page/4/index.html","hash":"22285005eded1a0070ec57ac9c55d18a779414d8","modified":1588260637947},{"_id":"public/tags/other/index.html","hash":"6f2fba2226a59a799c0ee86de3d72a02a2319305","modified":1588260637947},{"_id":"public/tags/ansible-playbook/index.html","hash":"6fce3727ace811ef6ee1447a4cd3d8e06df9d41e","modified":1588260637947},{"_id":"public/tags/ansible-module/index.html","hash":"eb56c3277941f43b395cb1ac5dc8dca986d03f5a","modified":1588260637947},{"_id":"public/tags/github/index.html","hash":"903c265d6c41bb5ed03df1270b41456b0ba2fc2d","modified":1588260637947},{"_id":"public/tags/http/index.html","hash":"c0ef0d16483552f77516fa983c3bfd54dd99a842","modified":1588260637947},{"_id":"public/tags/https/index.html","hash":"4a3f170c8398c5e6d58ec109c435761783723d84","modified":1588260637947},{"_id":"public/tags/ansible-error/index.html","hash":"786ead86528a292caf547f207b3c191ccb00516d","modified":1588260637947},{"_id":"public/tags/windows/index.html","hash":"4c6fe3ad99a53f33aac7418fea15fed634db7aeb","modified":1588260637947},{"_id":"public/tags/ansible-help/index.html","hash":"d530b6accdf00df66d9af8a7bf4a076c74afeaec","modified":1588260637947},{"_id":"public/tags/include-vars/index.html","hash":"b111428fb3d6b22a7b64c56a2f3c77d50059acce","modified":1588260637947},{"_id":"public/tags/delegate-to/index.html","hash":"93d6c44727405a5a48a196d1f0ccd85fc5d95044","modified":1588260637947},{"_id":"public/tags/ansible/index.html","hash":"af8d1493978964932da40105c10b858de5b796a7","modified":1588260637948},{"_id":"public/tags/ansible-roles/index.html","hash":"a90f616f072c63286d110373458744c9c93cf16a","modified":1588260637948},{"_id":"public/tags/ansible-template/index.html","hash":"fa0695126ceb979a54b6f347cab25662f512025a","modified":1588260637948},{"_id":"public/tags/ansible-variables/index.html","hash":"48fc2934a58e4fb4d2ea7274b85676f54eba87ee","modified":1588260637948},{"_id":"public/tags/ansible-learn/index.html","hash":"a3ff782a8ee0b5f8f1bbf4999796fb4de8081827","modified":1588260637948},{"_id":"public/tags/monitor/index.html","hash":"0a64a9496ce263a672aa8227e6fa53e0f95324f9","modified":1588260637948},{"_id":"public/tags/ci/index.html","hash":"a1d6ad2a5470ae78d64d427ff35b70f4fcf6cf8d","modified":1588260637948},{"_id":"public/tags/tools/index.html","hash":"8105f707639839ef35f929fbc6ae87dda652b08d","modified":1588260637948},{"_id":"public/tags/dcoker/index.html","hash":"ce137f414591a86a9a7d19c190163e4c46a3cec7","modified":1588260637948},{"_id":"public/tags/podman/index.html","hash":"1f47e772314fe8d14bd577be8c253552badd7f7a","modified":1588260637948},{"_id":"public/tags/pipeline/index.html","hash":"65660d522d9a5c361658cc8f9eb2fac3adc07927","modified":1588260637948},{"_id":"public/tags/shell/index.html","hash":"3303c1acbabfb5b1f554efd3550e5e274d5e1d69","modified":1588260637948},{"_id":"public/categories/linux/index.html","hash":"3f6de0e641ce5945c43c7dfc14eca01fc8994216","modified":1588260637948},{"_id":"public/tags/file/index.html","hash":"50ec64bd66670efb7c9297d318593d29c3bd437a","modified":1588260637948},{"_id":"public/tags/linux/index.html","hash":"6ca1e55c49db660c2c3b79c9683a624880368f2e","modified":1588260637949},{"_id":"public/tags/nas/index.html","hash":"2e9681e054b230e5e127134cd967697864caba62","modified":1588260637949},{"_id":"public/categories/tools/index.html","hash":"95728c1e70664839645b3ddba4c7ac480f477710","modified":1588260637949},{"_id":"public/tags/progress/index.html","hash":"8545db9a93085dd4d12d1f0287981795b3db66f8","modified":1588260637949},{"_id":"public/tags/ipv6/index.html","hash":"2ca5fbc9d80b5467d6acc5c7dade9d8810363e10","modified":1588260637949},{"_id":"public/tags/nat/index.html","hash":"8a4842eea2c3203e6463e4ed0f83236e57669363","modified":1588260637951},{"_id":"public/tags/internet/index.html","hash":"7da2c9ad9cea0e6baac5b42de2cddb7df0313499","modified":1588260637951},{"_id":"public/tags/mysql/index.html","hash":"4a92448c239af7588a922e544fd80e63b2220606","modified":1588260637951},{"_id":"public/tags/standard/index.html","hash":"fb257eb93c496be89f951c27ab265ce6af6cc7eb","modified":1588260637951},{"_id":"public/categories/python/index.html","hash":"013f6c05407f02fdd5d288e0ed9be593f528084e","modified":1588260637951},{"_id":"public/tags/web/index.html","hash":"844ba51e10e26d81567247327d6638e36d0bcf59","modified":1588260637951},{"_id":"public/tags/cloud/index.html","hash":"85cf81f295ef2b5715d0e88ac1cfc921ebeb325a","modified":1588260637951},{"_id":"public/tags/git/index.html","hash":"345ec4f2ea7e3b40c5567e509875355196ff7617","modified":1588260637951},{"_id":"public/tags/learn/index.html","hash":"d743bddd4abc3ef6addc066f5d6f85256d1a108e","modified":1588260637951},{"_id":"public/tags/jenkins/index.html","hash":"b01c77a95fba9cdc6e91e8113d92414865362d84","modified":1588260637951},{"_id":"public/tags/pip/index.html","hash":"9126cbca14772c367353d23e38700b6af7eb3455","modified":1588260637951},{"_id":"public/images/alipay.png","hash":"ed30c27fa6b8ce20270cc7ff5520fdf0566ec31e","modified":1588260637957},{"_id":"public/images/webchat.png","hash":"1d27c18aa8d926506d0cd594b0ddf796d42f640f","modified":1588260637957},{"_id":"public/images/favicon.png","hash":"d7c5344e90a2bcf55736fec7aa9dc72ea47361eb","modified":1588260637957},{"_id":"public/images/ansible-version.png","hash":"3134f0cbbe0d16cd4f6f13760dbb932c26048079","modified":1588260637957},{"_id":"public/images/dingyue.png","hash":"1c08da0c2f30c5266fd2bd5e38143f6a175d818b","modified":1588260639291},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588260639292},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588260639295},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1588260639298},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1588260639298},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1588260639298},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1588260639298},{"_id":"public/css/style.css","hash":"263d98c93ae32dda6f7bbc8473105f3c441aca99","modified":1588260639301},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588260639301},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588260639302},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588260639302},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1588260639318},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1588260639356}],"Category":[{"name":"other","_id":"ck9mxden600020en7f58o0lq1"},{"name":"ansible","_id":"ck9mxdep500080en7ie51fg12"},{"name":"dev-ops","_id":"ck9mxder4001s0en7yxfcyr5r"},{"name":"docker","_id":"ck9mxdert002h0en7optv14se"},{"name":"jenkins","_id":"ck9mxdes7002u0en74jug66w6"},{"name":"linux","_id":"ck9mxdesc00320en7uapjnml1"},{"name":"network","_id":"ck9mxdeu2004x0en7kobccw1b"},{"name":"python","_id":"ck9mxdeuh005g0en7274dhotz"},{"name":"tools","_id":"ck9mxdev100630en7c7i6m74t"}],"Data":[],"Page":[{"_content":"sorry, the page can't found.\n对不起，您访问的页面不存在。","source":"404.md","raw":"sorry, the page can't found.\n对不起，您访问的页面不存在。","date":"2020-04-07T16:18:59.000Z","updated":"2020-04-07T16:18:59.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck9mxdel000000en7x6nlrp70","content":"<p>sorry, the page can’t found.<br>对不起，您访问的页面不存在。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>sorry, the page can’t found.<br>对不起，您访问的页面不存在。</p>\n"}],"Post":[{"title":"常用技术网站推荐","date":"2099-04-24T14:53:37.000Z","top":true,"_content":"\n常用的技术网站收藏。\n\n<!--more-->\n这里是我收集的常用技术网站，个人觉得文档质量或者社区氛围还是不错的。\n\n#### 技术社区：\n思否: https://segmentfault.com/\n\nCSDN: https://www.csdn.net/\n\n博客园: https://www.cnblogs.com/\n\n51CTO: https://www.51cto.com/\n\n\n#### Ansible:\nansible 官方文档：https://docs.ansible.com/ansible/latest/index.html\n\nansible 最佳实践：https://github.com/ansible/ansible-examples\n\nansible 中文入门：http://getansible.com/\n\nansible快速入门：https://www.cnblogs.com/dachenzi/p/8916521.html\n\nansible常用模块：https://blog.csdn.net/pushiqiang/article/details/78249665\n\nansible官方翻译之变量：https://blog.csdn.net/kellyseeme/article/details/50584775\n\n各种变量定义方式和变量引用：https://www.cnblogs.com/f-ck-need-u/p/7571974.html\n\nansible变量（阿里云）：https://yq.aliyun.com/articles/542649\n\n#### Linux：\nLinux命令大全：https://man.linuxde.net/\n\nLinux中国社区：https://linux.cn/\n\nAWK教程：https://awk.readthedocs.io/en/latest/index.html\n\nLinux优化很好的材料：https://time.geekbang.org/column/article/69618\n\nIBM developerWorks 中国 -Linux：https://www.ibm.com/developerworks/cn/linux/\n\nIBM Linux学习路线图： https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html\n\n#### docker:\nDocker 最佳实践文档：https://yeasy.gitbooks.io/docker_practice/image/build.html\nDocker 官方文档：https://docs.docker.com/get-started/\n\n#### 中间件文档：\nApache httpd官方文档：http://httpd.apache.org/docs/\n\nweblogic 官方文档：https://docs.oracle.com/en/middleware/\n\nJboss 开源文档：https://www.open-open.com/wenku/tag/jboss.html\n\n\n#### 开发类：\n开发工具：http://tool.oschina.net/\n\n在线API文档： http://tool.oschina.net/apidocs\n\njavascript 中文文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\n\nNodejs 中文文档：http://nodejs.cn/api/\n\n廖老师官方网站（java、javascript、python、git、sql）：https://www.liaoxuefeng.com/\n\n微信小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/index.html\n\n小程序前端组件Vant Weapp：https://youzan.github.io/vant-weapp/#/intro","source":"_posts/technology_website.md","raw":"---\ntitle: 常用技术网站推荐\ndate: 2099-04-24 14:53:37\ntags: other\ncategories: other\ntop: true\n---\n\n常用的技术网站收藏。\n\n<!--more-->\n这里是我收集的常用技术网站，个人觉得文档质量或者社区氛围还是不错的。\n\n#### 技术社区：\n思否: https://segmentfault.com/\n\nCSDN: https://www.csdn.net/\n\n博客园: https://www.cnblogs.com/\n\n51CTO: https://www.51cto.com/\n\n\n#### Ansible:\nansible 官方文档：https://docs.ansible.com/ansible/latest/index.html\n\nansible 最佳实践：https://github.com/ansible/ansible-examples\n\nansible 中文入门：http://getansible.com/\n\nansible快速入门：https://www.cnblogs.com/dachenzi/p/8916521.html\n\nansible常用模块：https://blog.csdn.net/pushiqiang/article/details/78249665\n\nansible官方翻译之变量：https://blog.csdn.net/kellyseeme/article/details/50584775\n\n各种变量定义方式和变量引用：https://www.cnblogs.com/f-ck-need-u/p/7571974.html\n\nansible变量（阿里云）：https://yq.aliyun.com/articles/542649\n\n#### Linux：\nLinux命令大全：https://man.linuxde.net/\n\nLinux中国社区：https://linux.cn/\n\nAWK教程：https://awk.readthedocs.io/en/latest/index.html\n\nLinux优化很好的材料：https://time.geekbang.org/column/article/69618\n\nIBM developerWorks 中国 -Linux：https://www.ibm.com/developerworks/cn/linux/\n\nIBM Linux学习路线图： https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html\n\n#### docker:\nDocker 最佳实践文档：https://yeasy.gitbooks.io/docker_practice/image/build.html\nDocker 官方文档：https://docs.docker.com/get-started/\n\n#### 中间件文档：\nApache httpd官方文档：http://httpd.apache.org/docs/\n\nweblogic 官方文档：https://docs.oracle.com/en/middleware/\n\nJboss 开源文档：https://www.open-open.com/wenku/tag/jboss.html\n\n\n#### 开发类：\n开发工具：http://tool.oschina.net/\n\n在线API文档： http://tool.oschina.net/apidocs\n\njavascript 中文文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\n\nNodejs 中文文档：http://nodejs.cn/api/\n\n廖老师官方网站（java、javascript、python、git、sql）：https://www.liaoxuefeng.com/\n\n微信小程序官方文档：https://developers.weixin.qq.com/miniprogram/dev/index.html\n\n小程序前端组件Vant Weapp：https://youzan.github.io/vant-weapp/#/intro","slug":"technology_website","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdemt00010en71fvoia7p","content":"<p>常用的技术网站收藏。</p>\n<a id=\"more\"></a>\n<p>这里是我收集的常用技术网站，个人觉得文档质量或者社区氛围还是不错的。</p>\n<h4 id=\"技术社区：\"><a href=\"#技术社区：\" class=\"headerlink\" title=\"技术社区：\"></a>技术社区：</h4><p>思否: <a href=\"https://segmentfault.com/\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/</a></p>\n<p>CSDN: <a href=\"https://www.csdn.net/\" target=\"_blank\" rel=\"noopener\">https://www.csdn.net/</a></p>\n<p>博客园: <a href=\"https://www.cnblogs.com/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/</a></p>\n<p>51CTO: <a href=\"https://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">https://www.51cto.com/</a></p>\n<h4 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible:\"></a>Ansible:</h4><p>ansible 官方文档：<a href=\"https://docs.ansible.com/ansible/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/index.html</a></p>\n<p>ansible 最佳实践：<a href=\"https://github.com/ansible/ansible-examples\" target=\"_blank\" rel=\"noopener\">https://github.com/ansible/ansible-examples</a></p>\n<p>ansible 中文入门：<a href=\"http://getansible.com/\" target=\"_blank\" rel=\"noopener\">http://getansible.com/</a></p>\n<p>ansible快速入门：<a href=\"https://www.cnblogs.com/dachenzi/p/8916521.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dachenzi/p/8916521.html</a></p>\n<p>ansible常用模块：<a href=\"https://blog.csdn.net/pushiqiang/article/details/78249665\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pushiqiang/article/details/78249665</a></p>\n<p>ansible官方翻译之变量：<a href=\"https://blog.csdn.net/kellyseeme/article/details/50584775\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kellyseeme/article/details/50584775</a></p>\n<p>各种变量定义方式和变量引用：<a href=\"https://www.cnblogs.com/f-ck-need-u/p/7571974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html</a></p>\n<p>ansible变量（阿里云）：<a href=\"https://yq.aliyun.com/articles/542649\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/542649</a></p>\n<h4 id=\"Linux：\"><a href=\"#Linux：\" class=\"headerlink\" title=\"Linux：\"></a>Linux：</h4><p>Linux命令大全：<a href=\"https://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">https://man.linuxde.net/</a></p>\n<p>Linux中国社区：<a href=\"https://linux.cn/\" target=\"_blank\" rel=\"noopener\">https://linux.cn/</a></p>\n<p>AWK教程：<a href=\"https://awk.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://awk.readthedocs.io/en/latest/index.html</a></p>\n<p>Linux优化很好的材料：<a href=\"https://time.geekbang.org/column/article/69618\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/69618</a></p>\n<p>IBM developerWorks 中国 -Linux：<a href=\"https://www.ibm.com/developerworks/cn/linux/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/</a></p>\n<p>IBM Linux学习路线图： <a href=\"https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html</a></p>\n<h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker:\"></a>docker:</h4><p>Docker 最佳实践文档：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/build.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/build.html</a><br>Docker 官方文档：<a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/get-started/</a></p>\n<h4 id=\"中间件文档：\"><a href=\"#中间件文档：\" class=\"headerlink\" title=\"中间件文档：\"></a>中间件文档：</h4><p>Apache httpd官方文档：<a href=\"http://httpd.apache.org/docs/\" target=\"_blank\" rel=\"noopener\">http://httpd.apache.org/docs/</a></p>\n<p>weblogic 官方文档：<a href=\"https://docs.oracle.com/en/middleware/\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/en/middleware/</a></p>\n<p>Jboss 开源文档：<a href=\"https://www.open-open.com/wenku/tag/jboss.html\" target=\"_blank\" rel=\"noopener\">https://www.open-open.com/wenku/tag/jboss.html</a></p>\n<h4 id=\"开发类：\"><a href=\"#开发类：\" class=\"headerlink\" title=\"开发类：\"></a>开发类：</h4><p>开发工具：<a href=\"http://tool.oschina.net/\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/</a></p>\n<p>在线API文档： <a href=\"http://tool.oschina.net/apidocs\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/apidocs</a></p>\n<p>javascript 中文文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p>\n<p>Nodejs 中文文档：<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a></p>\n<p>廖老师官方网站（java、javascript、python、git、sql）：<a href=\"https://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/</a></p>\n<p>微信小程序官方文档：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/index.html\" target=\"_blank\" rel=\"noopener\">https://developers.weixin.qq.com/miniprogram/dev/index.html</a></p>\n<p>小程序前端组件Vant Weapp：<a href=\"https://youzan.github.io/vant-weapp/#/intro\" target=\"_blank\" rel=\"noopener\">https://youzan.github.io/vant-weapp/#/intro</a></p>\n","site":{"data":{}},"excerpt":"<p>常用的技术网站收藏。</p>","more":"<p>这里是我收集的常用技术网站，个人觉得文档质量或者社区氛围还是不错的。</p>\n<h4 id=\"技术社区：\"><a href=\"#技术社区：\" class=\"headerlink\" title=\"技术社区：\"></a>技术社区：</h4><p>思否: <a href=\"https://segmentfault.com/\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/</a></p>\n<p>CSDN: <a href=\"https://www.csdn.net/\" target=\"_blank\" rel=\"noopener\">https://www.csdn.net/</a></p>\n<p>博客园: <a href=\"https://www.cnblogs.com/\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/</a></p>\n<p>51CTO: <a href=\"https://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">https://www.51cto.com/</a></p>\n<h4 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible:\"></a>Ansible:</h4><p>ansible 官方文档：<a href=\"https://docs.ansible.com/ansible/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/index.html</a></p>\n<p>ansible 最佳实践：<a href=\"https://github.com/ansible/ansible-examples\" target=\"_blank\" rel=\"noopener\">https://github.com/ansible/ansible-examples</a></p>\n<p>ansible 中文入门：<a href=\"http://getansible.com/\" target=\"_blank\" rel=\"noopener\">http://getansible.com/</a></p>\n<p>ansible快速入门：<a href=\"https://www.cnblogs.com/dachenzi/p/8916521.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dachenzi/p/8916521.html</a></p>\n<p>ansible常用模块：<a href=\"https://blog.csdn.net/pushiqiang/article/details/78249665\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pushiqiang/article/details/78249665</a></p>\n<p>ansible官方翻译之变量：<a href=\"https://blog.csdn.net/kellyseeme/article/details/50584775\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kellyseeme/article/details/50584775</a></p>\n<p>各种变量定义方式和变量引用：<a href=\"https://www.cnblogs.com/f-ck-need-u/p/7571974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html</a></p>\n<p>ansible变量（阿里云）：<a href=\"https://yq.aliyun.com/articles/542649\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/542649</a></p>\n<h4 id=\"Linux：\"><a href=\"#Linux：\" class=\"headerlink\" title=\"Linux：\"></a>Linux：</h4><p>Linux命令大全：<a href=\"https://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">https://man.linuxde.net/</a></p>\n<p>Linux中国社区：<a href=\"https://linux.cn/\" target=\"_blank\" rel=\"noopener\">https://linux.cn/</a></p>\n<p>AWK教程：<a href=\"https://awk.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://awk.readthedocs.io/en/latest/index.html</a></p>\n<p>Linux优化很好的材料：<a href=\"https://time.geekbang.org/column/article/69618\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/69618</a></p>\n<p>IBM developerWorks 中国 -Linux：<a href=\"https://www.ibm.com/developerworks/cn/linux/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/</a></p>\n<p>IBM Linux学习路线图： <a href=\"https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/linux/l-lpic1-map/index.html</a></p>\n<h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker:\"></a>docker:</h4><p>Docker 最佳实践文档：<a href=\"https://yeasy.gitbooks.io/docker_practice/image/build.html\" target=\"_blank\" rel=\"noopener\">https://yeasy.gitbooks.io/docker_practice/image/build.html</a><br>Docker 官方文档：<a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/get-started/</a></p>\n<h4 id=\"中间件文档：\"><a href=\"#中间件文档：\" class=\"headerlink\" title=\"中间件文档：\"></a>中间件文档：</h4><p>Apache httpd官方文档：<a href=\"http://httpd.apache.org/docs/\" target=\"_blank\" rel=\"noopener\">http://httpd.apache.org/docs/</a></p>\n<p>weblogic 官方文档：<a href=\"https://docs.oracle.com/en/middleware/\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/en/middleware/</a></p>\n<p>Jboss 开源文档：<a href=\"https://www.open-open.com/wenku/tag/jboss.html\" target=\"_blank\" rel=\"noopener\">https://www.open-open.com/wenku/tag/jboss.html</a></p>\n<h4 id=\"开发类：\"><a href=\"#开发类：\" class=\"headerlink\" title=\"开发类：\"></a>开发类：</h4><p>开发工具：<a href=\"http://tool.oschina.net/\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/</a></p>\n<p>在线API文档： <a href=\"http://tool.oschina.net/apidocs\" target=\"_blank\" rel=\"noopener\">http://tool.oschina.net/apidocs</a></p>\n<p>javascript 中文文档：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p>\n<p>Nodejs 中文文档：<a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/api/</a></p>\n<p>廖老师官方网站（java、javascript、python、git、sql）：<a href=\"https://www.liaoxuefeng.com/\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/</a></p>\n<p>微信小程序官方文档：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/index.html\" target=\"_blank\" rel=\"noopener\">https://developers.weixin.qq.com/miniprogram/dev/index.html</a></p>\n<p>小程序前端组件Vant Weapp：<a href=\"https://youzan.github.io/vant-weapp/#/intro\" target=\"_blank\" rel=\"noopener\">https://youzan.github.io/vant-weapp/#/intro</a></p>"},{"title":"ANSIBLE-PLAYBOOK启动的多种方式","date":"2019-03-11T14:15:37.000Z","_content":"\n# quick start\n\n## start the playbook with no password, it will run \"sudo su - root\" at the target first.\n## and only use the hosts of playbook\n```\nansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u lihuanhuan80 --private-key ~/robin.private -e \"ansible_become_exe='sudo su -'\" -vvv\n```\n<!--more-->\n## how to start the testplaybook and input password, it will run \"sudo su - root\" at the target first.\n## and only use the hosts of playbook\n```\nansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u root --ask-pass --ask-become-pass -e \"ansible_become_exe='sudo su -'\" -vvv\n```\n\n## how to start the playbook with hostname list and input the var with start command.\n```\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml --ask-pass --ask-become-pass -e \"instance_name='robinhhli' ansible_ssh_user='root' ansible_become_exe='sudo su -'\" -vvv\n```\n\n## how to use jenkins to run the ansible_playbook\n```\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"instance_name='robinhhli' ansible_ssh_user='root' ansible_ssh_pass='password' ansible_become_pass='password' ansible_become_exe='sudo su -'\" -vvv\n```","source":"_posts/ansible/ansible-playbook-start1.md","raw":"---\ntitle: ANSIBLE-PLAYBOOK启动的多种方式\ndate: 2019-03-11 14:15:37\ntags: ansible-playbook\ncategories: ansible\n---\n\n# quick start\n\n## start the playbook with no password, it will run \"sudo su - root\" at the target first.\n## and only use the hosts of playbook\n```\nansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u lihuanhuan80 --private-key ~/robin.private -e \"ansible_become_exe='sudo su -'\" -vvv\n```\n<!--more-->\n## how to start the testplaybook and input password, it will run \"sudo su - root\" at the target first.\n## and only use the hosts of playbook\n```\nansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u root --ask-pass --ask-become-pass -e \"ansible_become_exe='sudo su -'\" -vvv\n```\n\n## how to start the playbook with hostname list and input the var with start command.\n```\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml --ask-pass --ask-become-pass -e \"instance_name='robinhhli' ansible_ssh_user='root' ansible_become_exe='sudo su -'\" -vvv\n```\n\n## how to use jenkins to run the ansible_playbook\n```\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"instance_name='robinhhli' ansible_ssh_user='root' ansible_ssh_pass='password' ansible_become_pass='password' ansible_become_exe='sudo su -'\" -vvv\n```","slug":"ansible/ansible-playbook-start1","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeoy00060en7z995wzd7","content":"<h1 id=\"quick-start\"><a href=\"#quick-start\" class=\"headerlink\" title=\"quick start\"></a>quick start</h1><h2 id=\"start-the-playbook-with-no-password-it-will-run-“sudo-su-root”-at-the-target-first\"><a href=\"#start-the-playbook-with-no-password-it-will-run-“sudo-su-root”-at-the-target-first\" class=\"headerlink\" title=\"start the playbook with no password, it will run “sudo su - root” at the target first.\"></a>start the playbook with no password, it will run “sudo su - root” at the target first.</h2><h2 id=\"and-only-use-the-hosts-of-playbook\"><a href=\"#and-only-use-the-hosts-of-playbook\" class=\"headerlink\" title=\"and only use the hosts of playbook\"></a>and only use the hosts of playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u lihuanhuan80 --private-key ~/robin.private -e &quot;ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"how-to-start-the-testplaybook-and-input-password-it-will-run-“sudo-su-root”-at-the-target-first\"><a href=\"#how-to-start-the-testplaybook-and-input-password-it-will-run-“sudo-su-root”-at-the-target-first\" class=\"headerlink\" title=\"how to start the testplaybook and input password, it will run “sudo su - root” at the target first.\"></a>how to start the testplaybook and input password, it will run “sudo su - root” at the target first.</h2><h2 id=\"and-only-use-the-hosts-of-playbook-1\"><a href=\"#and-only-use-the-hosts-of-playbook-1\" class=\"headerlink\" title=\"and only use the hosts of playbook\"></a>and only use the hosts of playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u root --ask-pass --ask-become-pass -e &quot;ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>\n<h2 id=\"how-to-start-the-playbook-with-hostname-list-and-input-the-var-with-start-command\"><a href=\"#how-to-start-the-playbook-with-hostname-list-and-input-the-var-with-start-command\" class=\"headerlink\" title=\"how to start the playbook with hostname list and input the var with start command.\"></a>how to start the playbook with hostname list and input the var with start command.</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml --ask-pass --ask-become-pass -e &quot;instance_name=&apos;robinhhli&apos; ansible_ssh_user=&apos;root&apos; ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>\n<h2 id=\"how-to-use-jenkins-to-run-the-ansible-playbook\"><a href=\"#how-to-use-jenkins-to-run-the-ansible-playbook\" class=\"headerlink\" title=\"how to use jenkins to run the ansible_playbook\"></a>how to use jenkins to run the ansible_playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;instance_name=&apos;robinhhli&apos; ansible_ssh_user=&apos;root&apos; ansible_ssh_pass=&apos;password&apos; ansible_become_pass=&apos;password&apos; ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"quick-start\"><a href=\"#quick-start\" class=\"headerlink\" title=\"quick start\"></a>quick start</h1><h2 id=\"start-the-playbook-with-no-password-it-will-run-“sudo-su-root”-at-the-target-first\"><a href=\"#start-the-playbook-with-no-password-it-will-run-“sudo-su-root”-at-the-target-first\" class=\"headerlink\" title=\"start the playbook with no password, it will run “sudo su - root” at the target first.\"></a>start the playbook with no password, it will run “sudo su - root” at the target first.</h2><h2 id=\"and-only-use-the-hosts-of-playbook\"><a href=\"#and-only-use-the-hosts-of-playbook\" class=\"headerlink\" title=\"and only use the hosts of playbook\"></a>and only use the hosts of playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u lihuanhuan80 --private-key ~/robin.private -e &quot;ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"how-to-start-the-testplaybook-and-input-password-it-will-run-“sudo-su-root”-at-the-target-first\"><a href=\"#how-to-start-the-testplaybook-and-input-password-it-will-run-“sudo-su-root”-at-the-target-first\" class=\"headerlink\" title=\"how to start the testplaybook and input password, it will run “sudo su - root” at the target first.\"></a>how to start the testplaybook and input password, it will run “sudo su - root” at the target first.</h2><h2 id=\"and-only-use-the-hosts-of-playbook-1\"><a href=\"#and-only-use-the-hosts-of-playbook-1\" class=\"headerlink\" title=\"and only use the hosts of playbook\"></a>and only use the hosts of playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i hosts ~/ansible_playbook_test/site.yml -u root --ask-pass --ask-become-pass -e &quot;ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>\n<h2 id=\"how-to-start-the-playbook-with-hostname-list-and-input-the-var-with-start-command\"><a href=\"#how-to-start-the-playbook-with-hostname-list-and-input-the-var-with-start-command\" class=\"headerlink\" title=\"how to start the playbook with hostname list and input the var with start command.\"></a>how to start the playbook with hostname list and input the var with start command.</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml --ask-pass --ask-become-pass -e &quot;instance_name=&apos;robinhhli&apos; ansible_ssh_user=&apos;root&apos; ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>\n<h2 id=\"how-to-use-jenkins-to-run-the-ansible-playbook\"><a href=\"#how-to-use-jenkins-to-run-the-ansible-playbook\" class=\"headerlink\" title=\"how to use jenkins to run the ansible_playbook\"></a>how to use jenkins to run the ansible_playbook</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;instance_name=&apos;robinhhli&apos; ansible_ssh_user=&apos;root&apos; ansible_ssh_pass=&apos;password&apos; ansible_become_pass=&apos;password&apos; ansible_become_exe=&apos;sudo su -&apos;&quot; -vvv</span><br></pre></td></tr></table></figure>"},{"title":"ansible异步任务","date":"2019-11-22T00:24:30.000Z","_content":"\n### 转载于简书博客 https://www.jianshu.com/p/3962bf94ae70\n\nansible方便在于能批量下发，并返回结果和呈现。简单、高效。\n但有的任务执行起来却不那么直接，可能会花比较长的时间，甚至可能会比ssh的超时时间还要长。这种情况任务是不是没法执行了？\nansible考虑到了这种情况，官方文档介绍了这个问题的解决方法，就是让下发的任务执行的连接变为异步：任务下发之后，长连接不再保持，而是每隔一段时间轮询结果，直到任务结束。\n\n<!--more-->\n\n这是官网相关的介绍\n他们在playbook的任务中加入两个参数：async和poll。\n\n* async参数值代表了这个任务执行时间的上限值。即任务执行所用时间如果超出这个时间，则认为任务失败。此参数若未设置，则为同步执行。\n\n* poll参数值代表了任务异步执行时轮询的时间间隔。\n官方给出例子：\n\n```\n  ----\n    hosts: all\n    remote_user: root\n    tasks:\n      - name: simulate long running op (15 sec), wait for up to 45 sec, poll every 5 sec\n        command: /bin/sleep 15\n        async: 45\n        poll: 5\n```\n\n这时候已经不怕任务超时了。可以执行一个45s的任务，当然也可以根据需要自己设置。另外，如果poll为0，就相当于一个不关心结果的任务。\n\n如果还想要更方便地看轮询结果，ansible还提供了这个模块async_status。\n\n```\n  ---\n    # Requires ansible 1.8+\n    - name: 'YUM - fire and forget task'\n      yum: name=docker-io state=installed\n      async: 1000\n      poll: 0\n      register: yum_sleeper\n\n    - name: 'YUM - check on fire and forget task'\n      async_status: jid={{ yum_sleeper.ansible_job_id }}\n      register: job_result\n      until: job_result.finished\n      retries: 30\n```\n\n第一个job执行异步任务，并且注册了一个名字叫yum_sleeper，用于提供给第二个job作为轮询对象，并且poll设为0，它自己不再轮询。\n第二个job使用async_status模块，进行轮询并返回轮询结果。准备检查30次。结果如下：\n\n```\nPLAY [all] *********************************************************************\n\nTASK [setup] *******************************************************************\nok: [cloudlab001]\n\nTASK [YUM - fire and forget task] **********************************************\nok: [cloudlab001]\n\nTASK [YUM - check on fire and forget task] *************************************\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (29 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (28 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (27 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (26 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (25 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (24 retries left).\nchanged: [cloudlab001]\n\nPLAY RECAP *********************************************************************\ncloudlab001                : ok=3    changed=1    unreachable=0    failed=0\n```","source":"_posts/ansible/ansible_async.md","raw":"---\ntitle: ansible异步任务\ndate: 2019-11-22 00:24:30\ntags: ansible-module\ncategories: ansible\n---\n\n### 转载于简书博客 https://www.jianshu.com/p/3962bf94ae70\n\nansible方便在于能批量下发，并返回结果和呈现。简单、高效。\n但有的任务执行起来却不那么直接，可能会花比较长的时间，甚至可能会比ssh的超时时间还要长。这种情况任务是不是没法执行了？\nansible考虑到了这种情况，官方文档介绍了这个问题的解决方法，就是让下发的任务执行的连接变为异步：任务下发之后，长连接不再保持，而是每隔一段时间轮询结果，直到任务结束。\n\n<!--more-->\n\n这是官网相关的介绍\n他们在playbook的任务中加入两个参数：async和poll。\n\n* async参数值代表了这个任务执行时间的上限值。即任务执行所用时间如果超出这个时间，则认为任务失败。此参数若未设置，则为同步执行。\n\n* poll参数值代表了任务异步执行时轮询的时间间隔。\n官方给出例子：\n\n```\n  ----\n    hosts: all\n    remote_user: root\n    tasks:\n      - name: simulate long running op (15 sec), wait for up to 45 sec, poll every 5 sec\n        command: /bin/sleep 15\n        async: 45\n        poll: 5\n```\n\n这时候已经不怕任务超时了。可以执行一个45s的任务，当然也可以根据需要自己设置。另外，如果poll为0，就相当于一个不关心结果的任务。\n\n如果还想要更方便地看轮询结果，ansible还提供了这个模块async_status。\n\n```\n  ---\n    # Requires ansible 1.8+\n    - name: 'YUM - fire and forget task'\n      yum: name=docker-io state=installed\n      async: 1000\n      poll: 0\n      register: yum_sleeper\n\n    - name: 'YUM - check on fire and forget task'\n      async_status: jid={{ yum_sleeper.ansible_job_id }}\n      register: job_result\n      until: job_result.finished\n      retries: 30\n```\n\n第一个job执行异步任务，并且注册了一个名字叫yum_sleeper，用于提供给第二个job作为轮询对象，并且poll设为0，它自己不再轮询。\n第二个job使用async_status模块，进行轮询并返回轮询结果。准备检查30次。结果如下：\n\n```\nPLAY [all] *********************************************************************\n\nTASK [setup] *******************************************************************\nok: [cloudlab001]\n\nTASK [YUM - fire and forget task] **********************************************\nok: [cloudlab001]\n\nTASK [YUM - check on fire and forget task] *************************************\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (29 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (28 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (27 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (26 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (25 retries left).\nFAILED - RETRYING: TASK: YUM - check on fire and forget task (24 retries left).\nchanged: [cloudlab001]\n\nPLAY RECAP *********************************************************************\ncloudlab001                : ok=3    changed=1    unreachable=0    failed=0\n```","slug":"ansible/ansible_async","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdep000070en7ochxr64s","content":"<h3 id=\"转载于简书博客-https-www-jianshu-com-p-3962bf94ae70\"><a href=\"#转载于简书博客-https-www-jianshu-com-p-3962bf94ae70\" class=\"headerlink\" title=\"转载于简书博客 https://www.jianshu.com/p/3962bf94ae70\"></a>转载于简书博客 <a href=\"https://www.jianshu.com/p/3962bf94ae70\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3962bf94ae70</a></h3><p>ansible方便在于能批量下发，并返回结果和呈现。简单、高效。<br>但有的任务执行起来却不那么直接，可能会花比较长的时间，甚至可能会比ssh的超时时间还要长。这种情况任务是不是没法执行了？<br>ansible考虑到了这种情况，官方文档介绍了这个问题的解决方法，就是让下发的任务执行的连接变为异步：任务下发之后，长连接不再保持，而是每隔一段时间轮询结果，直到任务结束。</p>\n<a id=\"more\"></a>\n<p>这是官网相关的介绍<br>他们在playbook的任务中加入两个参数：async和poll。</p>\n<ul>\n<li><p>async参数值代表了这个任务执行时间的上限值。即任务执行所用时间如果超出这个时间，则认为任务失败。此参数若未设置，则为同步执行。</p>\n</li>\n<li><p>poll参数值代表了任务异步执行时轮询的时间间隔。<br>官方给出例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----</span><br><span class=\"line\">  hosts: all</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: simulate long running op (15 sec), wait for up to 45 sec, poll every 5 sec</span><br><span class=\"line\">      command: /bin/sleep 15</span><br><span class=\"line\">      async: 45</span><br><span class=\"line\">      poll: 5</span><br></pre></td></tr></table></figure>\n<p>这时候已经不怕任务超时了。可以执行一个45s的任务，当然也可以根据需要自己设置。另外，如果poll为0，就相当于一个不关心结果的任务。</p>\n<p>如果还想要更方便地看轮询结果，ansible还提供了这个模块async_status。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">  # Requires ansible 1.8+</span><br><span class=\"line\">  - name: &apos;YUM - fire and forget task&apos;</span><br><span class=\"line\">    yum: name=docker-io state=installed</span><br><span class=\"line\">    async: 1000</span><br><span class=\"line\">    poll: 0</span><br><span class=\"line\">    register: yum_sleeper</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: &apos;YUM - check on fire and forget task&apos;</span><br><span class=\"line\">    async_status: jid=&#123;&#123; yum_sleeper.ansible_job_id &#125;&#125;</span><br><span class=\"line\">    register: job_result</span><br><span class=\"line\">    until: job_result.finished</span><br><span class=\"line\">    retries: 30</span><br></pre></td></tr></table></figure>\n<p>第一个job执行异步任务，并且注册了一个名字叫yum_sleeper，用于提供给第二个job作为轮询对象，并且poll设为0，它自己不再轮询。<br>第二个job使用async_status模块，进行轮询并返回轮询结果。准备检查30次。结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PLAY [all] *********************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [setup] *******************************************************************</span><br><span class=\"line\">ok: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [YUM - fire and forget task] **********************************************</span><br><span class=\"line\">ok: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [YUM - check on fire and forget task] *************************************</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (29 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (28 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (27 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (26 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (25 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (24 retries left).</span><br><span class=\"line\">changed: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP *********************************************************************</span><br><span class=\"line\">cloudlab001                : ok=3    changed=1    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"转载于简书博客-https-www-jianshu-com-p-3962bf94ae70\"><a href=\"#转载于简书博客-https-www-jianshu-com-p-3962bf94ae70\" class=\"headerlink\" title=\"转载于简书博客 https://www.jianshu.com/p/3962bf94ae70\"></a>转载于简书博客 <a href=\"https://www.jianshu.com/p/3962bf94ae70\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3962bf94ae70</a></h3><p>ansible方便在于能批量下发，并返回结果和呈现。简单、高效。<br>但有的任务执行起来却不那么直接，可能会花比较长的时间，甚至可能会比ssh的超时时间还要长。这种情况任务是不是没法执行了？<br>ansible考虑到了这种情况，官方文档介绍了这个问题的解决方法，就是让下发的任务执行的连接变为异步：任务下发之后，长连接不再保持，而是每隔一段时间轮询结果，直到任务结束。</p>","more":"<p>这是官网相关的介绍<br>他们在playbook的任务中加入两个参数：async和poll。</p>\n<ul>\n<li><p>async参数值代表了这个任务执行时间的上限值。即任务执行所用时间如果超出这个时间，则认为任务失败。此参数若未设置，则为同步执行。</p>\n</li>\n<li><p>poll参数值代表了任务异步执行时轮询的时间间隔。<br>官方给出例子：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----</span><br><span class=\"line\">  hosts: all</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: simulate long running op (15 sec), wait for up to 45 sec, poll every 5 sec</span><br><span class=\"line\">      command: /bin/sleep 15</span><br><span class=\"line\">      async: 45</span><br><span class=\"line\">      poll: 5</span><br></pre></td></tr></table></figure>\n<p>这时候已经不怕任务超时了。可以执行一个45s的任务，当然也可以根据需要自己设置。另外，如果poll为0，就相当于一个不关心结果的任务。</p>\n<p>如果还想要更方便地看轮询结果，ansible还提供了这个模块async_status。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">  # Requires ansible 1.8+</span><br><span class=\"line\">  - name: &apos;YUM - fire and forget task&apos;</span><br><span class=\"line\">    yum: name=docker-io state=installed</span><br><span class=\"line\">    async: 1000</span><br><span class=\"line\">    poll: 0</span><br><span class=\"line\">    register: yum_sleeper</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: &apos;YUM - check on fire and forget task&apos;</span><br><span class=\"line\">    async_status: jid=&#123;&#123; yum_sleeper.ansible_job_id &#125;&#125;</span><br><span class=\"line\">    register: job_result</span><br><span class=\"line\">    until: job_result.finished</span><br><span class=\"line\">    retries: 30</span><br></pre></td></tr></table></figure>\n<p>第一个job执行异步任务，并且注册了一个名字叫yum_sleeper，用于提供给第二个job作为轮询对象，并且poll设为0，它自己不再轮询。<br>第二个job使用async_status模块，进行轮询并返回轮询结果。准备检查30次。结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PLAY [all] *********************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [setup] *******************************************************************</span><br><span class=\"line\">ok: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [YUM - fire and forget task] **********************************************</span><br><span class=\"line\">ok: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [YUM - check on fire and forget task] *************************************</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (29 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (28 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (27 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (26 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (25 retries left).</span><br><span class=\"line\">FAILED - RETRYING: TASK: YUM - check on fire and forget task (24 retries left).</span><br><span class=\"line\">changed: [cloudlab001]</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP *********************************************************************</span><br><span class=\"line\">cloudlab001                : ok=3    changed=1    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>"},{"title":"Ansible 删除多个文件或目录","date":"2019-03-17T14:53:37.000Z","_content":"\n翻译和转载该网页内容 http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/\n# 背景\nansible 有多种方式删除一个文件或目录，删除一个目录中的所有文件，使用正则表达式删除文件等等。最安全的方式是使用ansible内置的file模块。当然你也可以使用shell 模块去实现。但它不是幂等的，因此重新执行会抛出错误。\n\n<!--more-->\n\n# 删除一个文件\n```\n- name: Ansible delete file example\n  file:\n    path: /etc/delete.conf\n    state: absent\n```\n> 注意：当你知道一个文件名的时候，可以这样删除这个文件。\n\n\n# 删除多个文件\n```\n- name: Ansible delete multiple file example\n  file:\n    path: \"{{ item }}\"\n    state: absent\n  with_items:\n    - hello1.txt\n    - hello2.txt\n    - hello3.txt\n```\n> 注意：当你知道多个文件名的时候，可以这样删除这些文件。\n\n\n# 删除一个目录或文件夹\n```\n- name: Ansible delete directory example\n  file:\n    path: removed_files\n    state: absent\n```\n> 上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。\n\n# 使用shell 脚本删除多个文件\n```\n- name: Ansible delete file wildcard example\n  shell: rm -rf hello*.txt\n  ```\n > 上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。\n\n# 使用find和file模块结合linux shell模糊搜索删除文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete file glob\n    find:\n      paths: /etc/Ansible\n      patterns: *.txt\n    register: files_to_delete\n\n  - name: Ansible remove file glob\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ files_to_delete.files }}\"\n```\n\n# 使用find和file模块结合python的正则表达式删除文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete file wildcard\n    find:\n      paths: /etc/wild_card/example\n      patterns: \"^he.*.txt\"\n      use:regex: true\n    register: wildcard_files_to_delete\n\n  - name: Ansible remove file wildcard\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ wildcard_files_to_delete.files }}\"\n```\n\n# 移除晚于某个日期的文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete files older than 5 days example\n    find:\n      paths: /Users/dnpmacpro/Documents/Ansible\n      age: 5d\n    register: files_to_delete\n\n  - name: Ansible remove files older than a date example\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ files_to_delete.files }}\"\n```\n","source":"_posts/ansible/ansible_detele_files.md","raw":"---\ntitle: Ansible 删除多个文件或目录\ndate: 2019-03-17 14:53:37\ntags: ansible-module\ncategories: ansible\n---\n\n翻译和转载该网页内容 http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/\n# 背景\nansible 有多种方式删除一个文件或目录，删除一个目录中的所有文件，使用正则表达式删除文件等等。最安全的方式是使用ansible内置的file模块。当然你也可以使用shell 模块去实现。但它不是幂等的，因此重新执行会抛出错误。\n\n<!--more-->\n\n# 删除一个文件\n```\n- name: Ansible delete file example\n  file:\n    path: /etc/delete.conf\n    state: absent\n```\n> 注意：当你知道一个文件名的时候，可以这样删除这个文件。\n\n\n# 删除多个文件\n```\n- name: Ansible delete multiple file example\n  file:\n    path: \"{{ item }}\"\n    state: absent\n  with_items:\n    - hello1.txt\n    - hello2.txt\n    - hello3.txt\n```\n> 注意：当你知道多个文件名的时候，可以这样删除这些文件。\n\n\n# 删除一个目录或文件夹\n```\n- name: Ansible delete directory example\n  file:\n    path: removed_files\n    state: absent\n```\n> 上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。\n\n# 使用shell 脚本删除多个文件\n```\n- name: Ansible delete file wildcard example\n  shell: rm -rf hello*.txt\n  ```\n > 上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。\n\n# 使用find和file模块结合linux shell模糊搜索删除文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete file glob\n    find:\n      paths: /etc/Ansible\n      patterns: *.txt\n    register: files_to_delete\n\n  - name: Ansible remove file glob\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ files_to_delete.files }}\"\n```\n\n# 使用find和file模块结合python的正则表达式删除文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete file wildcard\n    find:\n      paths: /etc/wild_card/example\n      patterns: \"^he.*.txt\"\n      use:regex: true\n    register: wildcard_files_to_delete\n\n  - name: Ansible remove file wildcard\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ wildcard_files_to_delete.files }}\"\n```\n\n# 移除晚于某个日期的文件\n```\n- hosts: all\n  tasks:\n  - name: Ansible delete files older than 5 days example\n    find:\n      paths: /Users/dnpmacpro/Documents/Ansible\n      age: 5d\n    register: files_to_delete\n\n  - name: Ansible remove files older than a date example\n    file:\n      path: \"{{ item.path }}\"\n      state: absent\n    with_items: \"{{ files_to_delete.files }}\"\n```\n","slug":"ansible/ansible_detele_files","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdep6000a0en7ad2rvl8e","content":"<p>翻译和转载该网页内容 <a href=\"http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/\" target=\"_blank\" rel=\"noopener\">http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>ansible 有多种方式删除一个文件或目录，删除一个目录中的所有文件，使用正则表达式删除文件等等。最安全的方式是使用ansible内置的file模块。当然你也可以使用shell 模块去实现。但它不是幂等的，因此重新执行会抛出错误。</p>\n<a id=\"more\"></a>\n<h1 id=\"删除一个文件\"><a href=\"#删除一个文件\" class=\"headerlink\" title=\"删除一个文件\"></a>删除一个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete file example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /etc/delete.conf</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：当你知道一个文件名的时候，可以这样删除这个文件。</p>\n</blockquote>\n<h1 id=\"删除多个文件\"><a href=\"#删除多个文件\" class=\"headerlink\" title=\"删除多个文件\"></a>删除多个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete multiple file example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - hello1.txt</span><br><span class=\"line\">    - hello2.txt</span><br><span class=\"line\">    - hello3.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：当你知道多个文件名的时候，可以这样删除这些文件。</p>\n</blockquote>\n<h1 id=\"删除一个目录或文件夹\"><a href=\"#删除一个目录或文件夹\" class=\"headerlink\" title=\"删除一个目录或文件夹\"></a>删除一个目录或文件夹</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete directory example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: removed_files</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。</p>\n</blockquote>\n<h1 id=\"使用shell-脚本删除多个文件\"><a href=\"#使用shell-脚本删除多个文件\" class=\"headerlink\" title=\"使用shell 脚本删除多个文件\"></a>使用shell 脚本删除多个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete file wildcard example</span><br><span class=\"line\">  shell: rm -rf hello*.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。</p>\n</blockquote>\n<h1 id=\"使用find和file模块结合linux-shell模糊搜索删除文件\"><a href=\"#使用find和file模块结合linux-shell模糊搜索删除文件\" class=\"headerlink\" title=\"使用find和file模块结合linux shell模糊搜索删除文件\"></a>使用find和file模块结合linux shell模糊搜索删除文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete file glob</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /etc/Ansible</span><br><span class=\"line\">      patterns: *.txt</span><br><span class=\"line\">    register: files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove file glob</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用find和file模块结合python的正则表达式删除文件\"><a href=\"#使用find和file模块结合python的正则表达式删除文件\" class=\"headerlink\" title=\"使用find和file模块结合python的正则表达式删除文件\"></a>使用find和file模块结合python的正则表达式删除文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete file wildcard</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /etc/wild_card/example</span><br><span class=\"line\">      patterns: &quot;^he.*.txt&quot;</span><br><span class=\"line\">      use:regex: true</span><br><span class=\"line\">    register: wildcard_files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove file wildcard</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; wildcard_files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"移除晚于某个日期的文件\"><a href=\"#移除晚于某个日期的文件\" class=\"headerlink\" title=\"移除晚于某个日期的文件\"></a>移除晚于某个日期的文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete files older than 5 days example</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /Users/dnpmacpro/Documents/Ansible</span><br><span class=\"line\">      age: 5d</span><br><span class=\"line\">    register: files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove files older than a date example</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>翻译和转载该网页内容 <a href=\"http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/\" target=\"_blank\" rel=\"noopener\">http://www.mydailytutorials.com/ansible-delete-multiple-files-directories-ansible/</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>ansible 有多种方式删除一个文件或目录，删除一个目录中的所有文件，使用正则表达式删除文件等等。最安全的方式是使用ansible内置的file模块。当然你也可以使用shell 模块去实现。但它不是幂等的，因此重新执行会抛出错误。</p>","more":"<h1 id=\"删除一个文件\"><a href=\"#删除一个文件\" class=\"headerlink\" title=\"删除一个文件\"></a>删除一个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete file example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /etc/delete.conf</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：当你知道一个文件名的时候，可以这样删除这个文件。</p>\n</blockquote>\n<h1 id=\"删除多个文件\"><a href=\"#删除多个文件\" class=\"headerlink\" title=\"删除多个文件\"></a>删除多个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete multiple file example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - hello1.txt</span><br><span class=\"line\">    - hello2.txt</span><br><span class=\"line\">    - hello3.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：当你知道多个文件名的时候，可以这样删除这些文件。</p>\n</blockquote>\n<h1 id=\"删除一个目录或文件夹\"><a href=\"#删除一个目录或文件夹\" class=\"headerlink\" title=\"删除一个目录或文件夹\"></a>删除一个目录或文件夹</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete directory example</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: removed_files</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。</p>\n</blockquote>\n<h1 id=\"使用shell-脚本删除多个文件\"><a href=\"#使用shell-脚本删除多个文件\" class=\"headerlink\" title=\"使用shell 脚本删除多个文件\"></a>使用shell 脚本删除多个文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Ansible delete file wildcard example</span><br><span class=\"line\">  shell: rm -rf hello*.txt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面这个例子讲删除指定的目录，如果这个目录不存在，不会抛出错误。</p>\n</blockquote>\n<h1 id=\"使用find和file模块结合linux-shell模糊搜索删除文件\"><a href=\"#使用find和file模块结合linux-shell模糊搜索删除文件\" class=\"headerlink\" title=\"使用find和file模块结合linux shell模糊搜索删除文件\"></a>使用find和file模块结合linux shell模糊搜索删除文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete file glob</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /etc/Ansible</span><br><span class=\"line\">      patterns: *.txt</span><br><span class=\"line\">    register: files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove file glob</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用find和file模块结合python的正则表达式删除文件\"><a href=\"#使用find和file模块结合python的正则表达式删除文件\" class=\"headerlink\" title=\"使用find和file模块结合python的正则表达式删除文件\"></a>使用find和file模块结合python的正则表达式删除文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete file wildcard</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /etc/wild_card/example</span><br><span class=\"line\">      patterns: &quot;^he.*.txt&quot;</span><br><span class=\"line\">      use:regex: true</span><br><span class=\"line\">    register: wildcard_files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove file wildcard</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; wildcard_files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"移除晚于某个日期的文件\"><a href=\"#移除晚于某个日期的文件\" class=\"headerlink\" title=\"移除晚于某个日期的文件\"></a>移除晚于某个日期的文件</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: all</span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">  - name: Ansible delete files older than 5 days example</span><br><span class=\"line\">    find:</span><br><span class=\"line\">      paths: /Users/dnpmacpro/Documents/Ansible</span><br><span class=\"line\">      age: 5d</span><br><span class=\"line\">    register: files_to_delete</span><br><span class=\"line\"></span><br><span class=\"line\">  - name: Ansible remove files older than a date example</span><br><span class=\"line\">    file:</span><br><span class=\"line\">      path: &quot;&#123;&#123; item.path &#125;&#125;&quot;</span><br><span class=\"line\">      state: absent</span><br><span class=\"line\">    with_items: &quot;&#123;&#123; files_to_delete.files &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>"},{"title":"ansible下载文件的多种方式","date":"2019-11-27T21:46:30.000Z","_content":"\n对于ansible来说，下载文件是一个很重要的课题，这是build或者deploy的第一步，通常来讲由于不同项目的差异，可能我们的代码包或者资源文件保存在于http,github,nexus,ftp,nas等等。\n\n<!--more-->\n\n#### http文件下载,前提是http允许匿名用户下载\n```yml\n- name: download war file\n  get_url:\n    url: \"{{ https_url }}/start.war\"\n    dest: /tmp\n    mode: 0644\n    force: yes\n    validate_certs: no\n```\n\n#### github 文件下载,前提是已经在github申请了token\n```yml\n- name: donwload docker rpm\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/docker.rpm\n    dest: /tmp/docker.rpm\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n#### 如果想让文件下载到ansible master端,只要增加一条\n`delegate_to: localhost`\n\n* 一个完整的task，如下：\n```yml\n- name: donwload docker rpm\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/docker.rpm\n    dest: /tmp/docker.rpm\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  delegate_to: localhost\n```\n\n#### 关于https证书验证\n\n大家知道，凡是我们使用浏览器或者脚本方式访问https资源的时候，客户端默认会检查https证书是否合法，例如：https证书的绑定的地址是否跟访问的地址匹配，证书颁发机构是否​合法等。对于ansible下载文件来说，也会遇到这个问题。\n\n​不验证证书：\n```\nvalidate_certs: no\n```\n\n验证证书：\n```\nvalidate_certs: yes\n```","source":"_posts/ansible/ansible_download_file.md","raw":"---\ntitle: ansible下载文件的多种方式\ndate: 2019-11-27 21:46:30\ntags: \n  - github\n  - http\n  - https\n  - ansible-module\ncategories: ansible\n---\n\n对于ansible来说，下载文件是一个很重要的课题，这是build或者deploy的第一步，通常来讲由于不同项目的差异，可能我们的代码包或者资源文件保存在于http,github,nexus,ftp,nas等等。\n\n<!--more-->\n\n#### http文件下载,前提是http允许匿名用户下载\n```yml\n- name: download war file\n  get_url:\n    url: \"{{ https_url }}/start.war\"\n    dest: /tmp\n    mode: 0644\n    force: yes\n    validate_certs: no\n```\n\n#### github 文件下载,前提是已经在github申请了token\n```yml\n- name: donwload docker rpm\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/docker.rpm\n    dest: /tmp/docker.rpm\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n#### 如果想让文件下载到ansible master端,只要增加一条\n`delegate_to: localhost`\n\n* 一个完整的task，如下：\n```yml\n- name: donwload docker rpm\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/docker.rpm\n    dest: /tmp/docker.rpm\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  delegate_to: localhost\n```\n\n#### 关于https证书验证\n\n大家知道，凡是我们使用浏览器或者脚本方式访问https资源的时候，客户端默认会检查https证书是否合法，例如：https证书的绑定的地址是否跟访问的地址匹配，证书颁发机构是否​合法等。对于ansible下载文件来说，也会遇到这个问题。\n\n​不验证证书：\n```\nvalidate_certs: no\n```\n\n验证证书：\n```\nvalidate_certs: yes\n```","slug":"ansible/ansible_download_file","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepe000b0en7j2e7rmq5","content":"<p>对于ansible来说，下载文件是一个很重要的课题，这是build或者deploy的第一步，通常来讲由于不同项目的差异，可能我们的代码包或者资源文件保存在于http,github,nexus,ftp,nas等等。</p>\n<a id=\"more\"></a>\n<h4 id=\"http文件下载-前提是http允许匿名用户下载\"><a href=\"#http文件下载-前提是http允许匿名用户下载\" class=\"headerlink\" title=\"http文件下载,前提是http允许匿名用户下载\"></a>http文件下载,前提是http允许匿名用户下载</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">download</span> <span class=\"string\">war</span> <span class=\"string\">file</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">\"<span class=\"template-variable\">&#123;&#123; https_url &#125;&#125;</span>/start.war\"</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0644</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"github-文件下载-前提是已经在github申请了token\"><a href=\"#github-文件下载-前提是已经在github申请了token\" class=\"headerlink\" title=\"github 文件下载,前提是已经在github申请了token\"></a>github 文件下载,前提是已经在github申请了token</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">docker</span> <span class=\"string\">rpm</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"如果想让文件下载到ansible-master端-只要增加一条\"><a href=\"#如果想让文件下载到ansible-master端-只要增加一条\" class=\"headerlink\" title=\"如果想让文件下载到ansible master端,只要增加一条\"></a>如果想让文件下载到ansible master端,只要增加一条</h4><p><code>delegate_to: localhost</code></p>\n<ul>\n<li>一个完整的task，如下：<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">docker</span> <span class=\"string\">rpm</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class=\"line\">  <span class=\"attr\">delegate_to:</span> <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"关于https证书验证\"><a href=\"#关于https证书验证\" class=\"headerlink\" title=\"关于https证书验证\"></a>关于https证书验证</h4><p>大家知道，凡是我们使用浏览器或者脚本方式访问https资源的时候，客户端默认会检查https证书是否合法，例如：https证书的绑定的地址是否跟访问的地址匹配，证书颁发机构是否​合法等。对于ansible下载文件来说，也会遇到这个问题。</p>\n<p>​不验证证书：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">validate_certs: no</span><br></pre></td></tr></table></figure></p>\n<p>验证证书：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">validate_certs: yes</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>对于ansible来说，下载文件是一个很重要的课题，这是build或者deploy的第一步，通常来讲由于不同项目的差异，可能我们的代码包或者资源文件保存在于http,github,nexus,ftp,nas等等。</p>","more":"<h4 id=\"http文件下载-前提是http允许匿名用户下载\"><a href=\"#http文件下载-前提是http允许匿名用户下载\" class=\"headerlink\" title=\"http文件下载,前提是http允许匿名用户下载\"></a>http文件下载,前提是http允许匿名用户下载</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">download</span> <span class=\"string\">war</span> <span class=\"string\">file</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">\"<span class=\"template-variable\">&#123;&#123; https_url &#125;&#125;</span>/start.war\"</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0644</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"github-文件下载-前提是已经在github申请了token\"><a href=\"#github-文件下载-前提是已经在github申请了token\" class=\"headerlink\" title=\"github 文件下载,前提是已经在github申请了token\"></a>github 文件下载,前提是已经在github申请了token</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">docker</span> <span class=\"string\">rpm</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"如果想让文件下载到ansible-master端-只要增加一条\"><a href=\"#如果想让文件下载到ansible-master端-只要增加一条\" class=\"headerlink\" title=\"如果想让文件下载到ansible master端,只要增加一条\"></a>如果想让文件下载到ansible master端,只要增加一条</h4><p><code>delegate_to: localhost</code></p>\n<ul>\n<li>一个完整的task，如下：<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">docker</span> <span class=\"string\">rpm</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/docker.rpm</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class=\"line\">  <span class=\"attr\">delegate_to:</span> <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"关于https证书验证\"><a href=\"#关于https证书验证\" class=\"headerlink\" title=\"关于https证书验证\"></a>关于https证书验证</h4><p>大家知道，凡是我们使用浏览器或者脚本方式访问https资源的时候，客户端默认会检查https证书是否合法，例如：https证书的绑定的地址是否跟访问的地址匹配，证书颁发机构是否​合法等。对于ansible下载文件来说，也会遇到这个问题。</p>\n<p>​不验证证书：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">validate_certs: no</span><br></pre></td></tr></table></figure></p>\n<p>验证证书：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">validate_certs: yes</span><br></pre></td></tr></table></figure></p>"},{"title":"Ansible常见错误解析","date":"2020-02-23T18:00:00.000Z","_content":"\n# 背景\n由于工作中经常用到ansible,所以整理了常用的ansible错误及原因分析，方便自己也方便别人参考。\n\n<!--more-->\n\n# 1.shell 模块常见错误\n## 1.1 使用shell遇到\"msg\": \"non-zero return code\"\n### ansible 脚本如下：\n```\n- name: Check the weblogic without wc\n  shell: \"ps -ef|grep weblogic|grep -v grep\"\n  register: check_weblogic0\n  ignore_errors: true\n```\n\n### ansible 返回错误:\n```\nTASK [Check the weblogic without wc] *********************************************************************************************************************************************************************************************************fatal: [robin.org.cn]: FAILED! => {\"changed\": true, \"cmd\": \"ps -ef|grep weblogic|grep -v grep\", \"delta\": \"0:00:00.036565\", \"end\": \"2020-02-23 18:08:03.100106\", \"msg\": \"non-zero return code\", \"rc\": 1, \"start\": \"2020-02-23 18:08:03.063541\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"\", \"stdout_lines\": []}\n...ignoring\n\nok: [robin.org.cn] => {\n    \"msg\": {\n        \"changed\": true,\n        \"cmd\": \"ps -ef|grep weblogic|grep -v grep\",\n        \"delta\": \"0:00:00.036565\",\n        \"end\": \"2020-02-23 18:08:03.100106\",\n        \"failed\": true,\n        \"msg\": \"non-zero return code\",\n        \"rc\": 1,\n        \"start\": \"2020-02-23 18:08:03.063541\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"\",\n        \"stdout_lines\": []\n    }\n}\n```\n\n### 原因分析：\n当使用shell模块并且返回为空的时候，ansible就会认为shell脚本出错了，rc就返回1。\n\n### 解决方案：\n在shell命令末尾增加cat，将返回的内容通过管道传递给cat，使用cat返回的rc始终为0. 最好的解决方式，无论你要获取整个返回内容或者返回行数。\n```\n- name: Check the weblogic without wc but use cat\n  shell: \"ps -ef|grep weblogic|grep -v grep|cat\"\n  register: check_weblogic1\n  ignore_errors: true\n\n- name: print the check_weblogic1\n  debug:\n    msg: \"{{ check_weblogic1 }}\"\n```\n\n在shell命令末尾增加wc -l，计算返回的行数，保证shell返回始终不为空。\n```\n- name: Check the weblogic with wc\n  shell: \"ps -ef|grep weblogic|grep -v grep|wc -l\"\n  register: check_weblogic2\n  ignore_errors: true\n\n- name: print the check_weblogic2\n  debug:\n    msg: \"{{ check_weblogic2.stdout|int }}\"\n```\n\n在脚本最后面增加ignore_errors: true，最不推荐的方式，除非暂时没找到根本原因，应急。\n```\n- name: Check the weblogic without wc\n  shell: \"ps -ef|grep weblogic|grep -v grep\"\n  register: check_weblogic0\n  ignore_errors: true\n```\n\n## 1.2 使用shell遇到\"/bin/sh: pip: command not found\"错误\n\n```\n- name: pip insall web.py\n  shell: \"pip install requests\"\n  async: 200\n  poll: 0\n  register: pip_install_status\n```\n\n```\nTASK [YUM - check on fire and forget task] ***************************************************************************************************************************************************************************************************fatal: [gcp2.lhh.pub]: FAILED! => {\"ansible_job_id\": \"943105447304.15557\", \"attempts\": 1, \"changed\": true, \"cmd\": \"pip install requests\", \"delta\": \"0:00:00.003629\", \"end\": \"2020-02-24 15:05:40.012909\", \"finished\": 1, \"msg\": \"non-zero return code\", \"rc\": 127, \"start\": \"2020-02-24 15:05:40.009280\", \"stderr\": \"/bin/sh: pip: command not found\", \"stderr_lines\": [\"/bin/sh: pip: command not found\"], \"stdout\": \"\", \"stdout_lines\": []}\n```\n### 原因分析\n使用ansible的shell模块的时候，默认不会完全使用当前shell的环境变量PATH,只是导入最基本的几个目录,请看我使用echo $PATH打印的结果。\n```\n\nTASK [echo teh result2] **********************************************************************************************************************************************************************************************************************ok: [gcp.lhh.pub] => {\n    \"msg\": {\n        \"ansible_job_id\": \"479995747105.21088\",\n        \"attempts\": 1,\n        \"changed\": true,\n        \"cmd\": \"echo $PATH\",\n        \"delta\": \"0:00:00.005452\",\n        \"end\": \"2020-02-24 15:16:30.108684\",\n        \"failed\": false,\n        \"finished\": 1,\n        \"rc\": 0,\n        \"start\": \"2020-02-24 15:16:30.103232\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"/sbin:/bin:/usr/sbin:/usr/bin\",\n        \"stdout_lines\": [\n            \"/sbin:/bin:/usr/sbin:/usr/bin\"\n        ]\n    }\n}\n```\n### 解决方案\n如果要使用的命令在/sbin:/bin:/usr/sbin:/usr/bin没有，则使用命令的绝对路径或者事先导入常用的所有环境变量。\n```\n - name: import all the path and run pip insall web.py\n   shell: \"export PATH=$PATH:/usr/bin/:/usr/local/bin/;pip install web.py\"\n   async: 20\n   poll: 10\n   register: rst1\n```\n\n\n# 2.copy模块常见错误\n## 2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory\n`ansible all -m copy -a 'src=/root/ansible/file1 dest=/etc/cc/file1 remote_src=yes backup=yes mode=0755'`\n\n```\nTASK [cp files below folder4 to bak1] *************************************************************\nok: [localhost] => (item=subfile1)\nok: [localhost] => (item=subfile2)\nfailed: [localhost] (item=subfolder1) => {\"changed\": false, \"item\": \"subfolder1\", \"msg\": \"Remote copy does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1\"}\n        to retry, use: --limit @/apps/ansible-test/test-cp.retry\n\nPLAY RECAP ****************************************************************************************\nlocalhost                  : ok=3    changed=1    unreachable=0    failed=1\n\n```\n\n### 原因分析：\n如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。对于asible 2.6，只支持copy单个文件，不允许递归copy。对于ansible 2.8 已经支持递归复制。详见官方说明：https://docs.ansible.com/ansible/latest/modules/copy_module.html\n\n### 解决方案：\n使用ansible 2.8 或者 使用linux shell cp -rf实现递归复制。\n`ansible all -m shell -a 'cp -rf /root/ansible/* /etc/cc/file1'`","source":"_posts/ansible/ansible_error.md","raw":"---\ntitle: Ansible常见错误解析\ndate: 2020-02-23 18:00:00\ntags: ansible-error\ncategories: ansible\n---\n\n# 背景\n由于工作中经常用到ansible,所以整理了常用的ansible错误及原因分析，方便自己也方便别人参考。\n\n<!--more-->\n\n# 1.shell 模块常见错误\n## 1.1 使用shell遇到\"msg\": \"non-zero return code\"\n### ansible 脚本如下：\n```\n- name: Check the weblogic without wc\n  shell: \"ps -ef|grep weblogic|grep -v grep\"\n  register: check_weblogic0\n  ignore_errors: true\n```\n\n### ansible 返回错误:\n```\nTASK [Check the weblogic without wc] *********************************************************************************************************************************************************************************************************fatal: [robin.org.cn]: FAILED! => {\"changed\": true, \"cmd\": \"ps -ef|grep weblogic|grep -v grep\", \"delta\": \"0:00:00.036565\", \"end\": \"2020-02-23 18:08:03.100106\", \"msg\": \"non-zero return code\", \"rc\": 1, \"start\": \"2020-02-23 18:08:03.063541\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"\", \"stdout_lines\": []}\n...ignoring\n\nok: [robin.org.cn] => {\n    \"msg\": {\n        \"changed\": true,\n        \"cmd\": \"ps -ef|grep weblogic|grep -v grep\",\n        \"delta\": \"0:00:00.036565\",\n        \"end\": \"2020-02-23 18:08:03.100106\",\n        \"failed\": true,\n        \"msg\": \"non-zero return code\",\n        \"rc\": 1,\n        \"start\": \"2020-02-23 18:08:03.063541\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"\",\n        \"stdout_lines\": []\n    }\n}\n```\n\n### 原因分析：\n当使用shell模块并且返回为空的时候，ansible就会认为shell脚本出错了，rc就返回1。\n\n### 解决方案：\n在shell命令末尾增加cat，将返回的内容通过管道传递给cat，使用cat返回的rc始终为0. 最好的解决方式，无论你要获取整个返回内容或者返回行数。\n```\n- name: Check the weblogic without wc but use cat\n  shell: \"ps -ef|grep weblogic|grep -v grep|cat\"\n  register: check_weblogic1\n  ignore_errors: true\n\n- name: print the check_weblogic1\n  debug:\n    msg: \"{{ check_weblogic1 }}\"\n```\n\n在shell命令末尾增加wc -l，计算返回的行数，保证shell返回始终不为空。\n```\n- name: Check the weblogic with wc\n  shell: \"ps -ef|grep weblogic|grep -v grep|wc -l\"\n  register: check_weblogic2\n  ignore_errors: true\n\n- name: print the check_weblogic2\n  debug:\n    msg: \"{{ check_weblogic2.stdout|int }}\"\n```\n\n在脚本最后面增加ignore_errors: true，最不推荐的方式，除非暂时没找到根本原因，应急。\n```\n- name: Check the weblogic without wc\n  shell: \"ps -ef|grep weblogic|grep -v grep\"\n  register: check_weblogic0\n  ignore_errors: true\n```\n\n## 1.2 使用shell遇到\"/bin/sh: pip: command not found\"错误\n\n```\n- name: pip insall web.py\n  shell: \"pip install requests\"\n  async: 200\n  poll: 0\n  register: pip_install_status\n```\n\n```\nTASK [YUM - check on fire and forget task] ***************************************************************************************************************************************************************************************************fatal: [gcp2.lhh.pub]: FAILED! => {\"ansible_job_id\": \"943105447304.15557\", \"attempts\": 1, \"changed\": true, \"cmd\": \"pip install requests\", \"delta\": \"0:00:00.003629\", \"end\": \"2020-02-24 15:05:40.012909\", \"finished\": 1, \"msg\": \"non-zero return code\", \"rc\": 127, \"start\": \"2020-02-24 15:05:40.009280\", \"stderr\": \"/bin/sh: pip: command not found\", \"stderr_lines\": [\"/bin/sh: pip: command not found\"], \"stdout\": \"\", \"stdout_lines\": []}\n```\n### 原因分析\n使用ansible的shell模块的时候，默认不会完全使用当前shell的环境变量PATH,只是导入最基本的几个目录,请看我使用echo $PATH打印的结果。\n```\n\nTASK [echo teh result2] **********************************************************************************************************************************************************************************************************************ok: [gcp.lhh.pub] => {\n    \"msg\": {\n        \"ansible_job_id\": \"479995747105.21088\",\n        \"attempts\": 1,\n        \"changed\": true,\n        \"cmd\": \"echo $PATH\",\n        \"delta\": \"0:00:00.005452\",\n        \"end\": \"2020-02-24 15:16:30.108684\",\n        \"failed\": false,\n        \"finished\": 1,\n        \"rc\": 0,\n        \"start\": \"2020-02-24 15:16:30.103232\",\n        \"stderr\": \"\",\n        \"stderr_lines\": [],\n        \"stdout\": \"/sbin:/bin:/usr/sbin:/usr/bin\",\n        \"stdout_lines\": [\n            \"/sbin:/bin:/usr/sbin:/usr/bin\"\n        ]\n    }\n}\n```\n### 解决方案\n如果要使用的命令在/sbin:/bin:/usr/sbin:/usr/bin没有，则使用命令的绝对路径或者事先导入常用的所有环境变量。\n```\n - name: import all the path and run pip insall web.py\n   shell: \"export PATH=$PATH:/usr/bin/:/usr/local/bin/;pip install web.py\"\n   async: 20\n   poll: 10\n   register: rst1\n```\n\n\n# 2.copy模块常见错误\n## 2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory\n`ansible all -m copy -a 'src=/root/ansible/file1 dest=/etc/cc/file1 remote_src=yes backup=yes mode=0755'`\n\n```\nTASK [cp files below folder4 to bak1] *************************************************************\nok: [localhost] => (item=subfile1)\nok: [localhost] => (item=subfile2)\nfailed: [localhost] (item=subfolder1) => {\"changed\": false, \"item\": \"subfolder1\", \"msg\": \"Remote copy does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1\"}\n        to retry, use: --limit @/apps/ansible-test/test-cp.retry\n\nPLAY RECAP ****************************************************************************************\nlocalhost                  : ok=3    changed=1    unreachable=0    failed=1\n\n```\n\n### 原因分析：\n如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。对于asible 2.6，只支持copy单个文件，不允许递归copy。对于ansible 2.8 已经支持递归复制。详见官方说明：https://docs.ansible.com/ansible/latest/modules/copy_module.html\n\n### 解决方案：\n使用ansible 2.8 或者 使用linux shell cp -rf实现递归复制。\n`ansible all -m shell -a 'cp -rf /root/ansible/* /etc/cc/file1'`","slug":"ansible/ansible_error","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepf000c0en7erkzubc3","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>由于工作中经常用到ansible,所以整理了常用的ansible错误及原因分析，方便自己也方便别人参考。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-shell-模块常见错误\"><a href=\"#1-shell-模块常见错误\" class=\"headerlink\" title=\"1.shell 模块常见错误\"></a>1.shell 模块常见错误</h1><h2 id=\"1-1-使用shell遇到”msg”-“non-zero-return-code”\"><a href=\"#1-1-使用shell遇到”msg”-“non-zero-return-code”\" class=\"headerlink\" title=\"1.1 使用shell遇到”msg”: “non-zero return code”\"></a>1.1 使用shell遇到”msg”: “non-zero return code”</h2><h3 id=\"ansible-脚本如下：\"><a href=\"#ansible-脚本如下：\" class=\"headerlink\" title=\"ansible 脚本如下：\"></a>ansible 脚本如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep&quot;</span><br><span class=\"line\">  register: check_weblogic0</span><br><span class=\"line\">  ignore_errors: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"ansible-返回错误\"><a href=\"#ansible-返回错误\" class=\"headerlink\" title=\"ansible 返回错误:\"></a>ansible 返回错误:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [Check the weblogic without wc] *********************************************************************************************************************************************************************************************************fatal: [robin.org.cn]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ps -ef|grep weblogic|grep -v grep&quot;, &quot;delta&quot;: &quot;0:00:00.036565&quot;, &quot;end&quot;: &quot;2020-02-23 18:08:03.100106&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 1, &quot;start&quot;: &quot;2020-02-23 18:08:03.063541&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class=\"line\">...ignoring</span><br><span class=\"line\"></span><br><span class=\"line\">ok: [robin.org.cn] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &#123;</span><br><span class=\"line\">        &quot;changed&quot;: true,</span><br><span class=\"line\">        &quot;cmd&quot;: &quot;ps -ef|grep weblogic|grep -v grep&quot;,</span><br><span class=\"line\">        &quot;delta&quot;: &quot;0:00:00.036565&quot;,</span><br><span class=\"line\">        &quot;end&quot;: &quot;2020-02-23 18:08:03.100106&quot;,</span><br><span class=\"line\">        &quot;failed&quot;: true,</span><br><span class=\"line\">        &quot;msg&quot;: &quot;non-zero return code&quot;,</span><br><span class=\"line\">        &quot;rc&quot;: 1,</span><br><span class=\"line\">        &quot;start&quot;: &quot;2020-02-23 18:08:03.063541&quot;,</span><br><span class=\"line\">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stderr_lines&quot;: [],</span><br><span class=\"line\">        &quot;stdout&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stdout_lines&quot;: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p>当使用shell模块并且返回为空的时候，ansible就会认为shell脚本出错了，rc就返回1。</p>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><p>在shell命令末尾增加cat，将返回的内容通过管道传递给cat，使用cat返回的rc始终为0. 最好的解决方式，无论你要获取整个返回内容或者返回行数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc but use cat</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep|cat&quot;</span><br><span class=\"line\">  register: check_weblogic1</span><br><span class=\"line\">  ignore_errors: true</span><br><span class=\"line\"></span><br><span class=\"line\">- name: print the check_weblogic1</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; check_weblogic1 &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在shell命令末尾增加wc -l，计算返回的行数，保证shell返回始终不为空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic with wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep|wc -l&quot;</span><br><span class=\"line\">  register: check_weblogic2</span><br><span class=\"line\">  ignore_errors: true</span><br><span class=\"line\"></span><br><span class=\"line\">- name: print the check_weblogic2</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; check_weblogic2.stdout|int &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在脚本最后面增加ignore_errors: true，最不推荐的方式，除非暂时没找到根本原因，应急。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep&quot;</span><br><span class=\"line\">  register: check_weblogic0</span><br><span class=\"line\">  ignore_errors: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-使用shell遇到”-bin-sh-pip-command-not-found”错误\"><a href=\"#1-2-使用shell遇到”-bin-sh-pip-command-not-found”错误\" class=\"headerlink\" title=\"1.2 使用shell遇到”/bin/sh: pip: command not found”错误\"></a>1.2 使用shell遇到”/bin/sh: pip: command not found”错误</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: pip insall web.py</span><br><span class=\"line\">  shell: &quot;pip install requests&quot;</span><br><span class=\"line\">  async: 200</span><br><span class=\"line\">  poll: 0</span><br><span class=\"line\">  register: pip_install_status</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [YUM - check on fire and forget task] ***************************************************************************************************************************************************************************************************fatal: [gcp2.lhh.pub]: FAILED! =&gt; &#123;&quot;ansible_job_id&quot;: &quot;943105447304.15557&quot;, &quot;attempts&quot;: 1, &quot;changed&quot;: true, &quot;cmd&quot;: &quot;pip install requests&quot;, &quot;delta&quot;: &quot;0:00:00.003629&quot;, &quot;end&quot;: &quot;2020-02-24 15:05:40.012909&quot;, &quot;finished&quot;: 1, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 127, &quot;start&quot;: &quot;2020-02-24 15:05:40.009280&quot;, &quot;stderr&quot;: &quot;/bin/sh: pip: command not found&quot;, &quot;stderr_lines&quot;: [&quot;/bin/sh: pip: command not found&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h3><p>使用ansible的shell模块的时候，默认不会完全使用当前shell的环境变量PATH,只是导入最基本的几个目录,请看我使用echo $PATH打印的结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TASK [echo teh result2] **********************************************************************************************************************************************************************************************************************ok: [gcp.lhh.pub] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &#123;</span><br><span class=\"line\">        &quot;ansible_job_id&quot;: &quot;479995747105.21088&quot;,</span><br><span class=\"line\">        &quot;attempts&quot;: 1,</span><br><span class=\"line\">        &quot;changed&quot;: true,</span><br><span class=\"line\">        &quot;cmd&quot;: &quot;echo $PATH&quot;,</span><br><span class=\"line\">        &quot;delta&quot;: &quot;0:00:00.005452&quot;,</span><br><span class=\"line\">        &quot;end&quot;: &quot;2020-02-24 15:16:30.108684&quot;,</span><br><span class=\"line\">        &quot;failed&quot;: false,</span><br><span class=\"line\">        &quot;finished&quot;: 1,</span><br><span class=\"line\">        &quot;rc&quot;: 0,</span><br><span class=\"line\">        &quot;start&quot;: &quot;2020-02-24 15:16:30.103232&quot;,</span><br><span class=\"line\">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stderr_lines&quot;: [],</span><br><span class=\"line\">        &quot;stdout&quot;: &quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;,</span><br><span class=\"line\">        &quot;stdout_lines&quot;: [</span><br><span class=\"line\">            &quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>如果要使用的命令在/sbin:/bin:/usr/sbin:/usr/bin没有，则使用命令的绝对路径或者事先导入常用的所有环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: import all the path and run pip insall web.py</span><br><span class=\"line\">  shell: &quot;export PATH=$PATH:/usr/bin/:/usr/local/bin/;pip install web.py&quot;</span><br><span class=\"line\">  async: 20</span><br><span class=\"line\">  poll: 10</span><br><span class=\"line\">  register: rst1</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-copy模块常见错误\"><a href=\"#2-copy模块常见错误\" class=\"headerlink\" title=\"2.copy模块常见错误\"></a>2.copy模块常见错误</h1><h2 id=\"2-1-使用copy模块，遇到Remote-copy-does-not-support-recursive-copy-of-directory\"><a href=\"#2-1-使用copy模块，遇到Remote-copy-does-not-support-recursive-copy-of-directory\" class=\"headerlink\" title=\"2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory\"></a>2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory</h2><p><code>ansible all -m copy -a &#39;src=/root/ansible/file1 dest=/etc/cc/file1 remote_src=yes backup=yes mode=0755&#39;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [cp files below folder4 to bak1] *************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile1)</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile2)</span><br><span class=\"line\">failed: [localhost] (item=subfolder1) =&gt; &#123;&quot;changed&quot;: false, &quot;item&quot;: &quot;subfolder1&quot;, &quot;msg&quot;: &quot;Remote copy does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1&quot;&#125;</span><br><span class=\"line\">        to retry, use: --limit @/apps/ansible-test/test-cp.retry</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP ****************************************************************************************</span><br><span class=\"line\">localhost                  : ok=3    changed=1    unreachable=0    failed=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析：-1\"><a href=\"#原因分析：-1\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p>如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。对于asible 2.6，只支持copy单个文件，不允许递归copy。对于ansible 2.8 已经支持递归复制。详见官方说明：<a href=\"https://docs.ansible.com/ansible/latest/modules/copy_module.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/copy_module.html</a></p>\n<h3 id=\"解决方案：-1\"><a href=\"#解决方案：-1\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><p>使用ansible 2.8 或者 使用linux shell cp -rf实现递归复制。<br><code>ansible all -m shell -a &#39;cp -rf /root/ansible/* /etc/cc/file1&#39;</code></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>由于工作中经常用到ansible,所以整理了常用的ansible错误及原因分析，方便自己也方便别人参考。</p>","more":"<h1 id=\"1-shell-模块常见错误\"><a href=\"#1-shell-模块常见错误\" class=\"headerlink\" title=\"1.shell 模块常见错误\"></a>1.shell 模块常见错误</h1><h2 id=\"1-1-使用shell遇到”msg”-“non-zero-return-code”\"><a href=\"#1-1-使用shell遇到”msg”-“non-zero-return-code”\" class=\"headerlink\" title=\"1.1 使用shell遇到”msg”: “non-zero return code”\"></a>1.1 使用shell遇到”msg”: “non-zero return code”</h2><h3 id=\"ansible-脚本如下：\"><a href=\"#ansible-脚本如下：\" class=\"headerlink\" title=\"ansible 脚本如下：\"></a>ansible 脚本如下：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep&quot;</span><br><span class=\"line\">  register: check_weblogic0</span><br><span class=\"line\">  ignore_errors: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"ansible-返回错误\"><a href=\"#ansible-返回错误\" class=\"headerlink\" title=\"ansible 返回错误:\"></a>ansible 返回错误:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [Check the weblogic without wc] *********************************************************************************************************************************************************************************************************fatal: [robin.org.cn]: FAILED! =&gt; &#123;&quot;changed&quot;: true, &quot;cmd&quot;: &quot;ps -ef|grep weblogic|grep -v grep&quot;, &quot;delta&quot;: &quot;0:00:00.036565&quot;, &quot;end&quot;: &quot;2020-02-23 18:08:03.100106&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 1, &quot;start&quot;: &quot;2020-02-23 18:08:03.063541&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;stderr_lines&quot;: [], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br><span class=\"line\">...ignoring</span><br><span class=\"line\"></span><br><span class=\"line\">ok: [robin.org.cn] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &#123;</span><br><span class=\"line\">        &quot;changed&quot;: true,</span><br><span class=\"line\">        &quot;cmd&quot;: &quot;ps -ef|grep weblogic|grep -v grep&quot;,</span><br><span class=\"line\">        &quot;delta&quot;: &quot;0:00:00.036565&quot;,</span><br><span class=\"line\">        &quot;end&quot;: &quot;2020-02-23 18:08:03.100106&quot;,</span><br><span class=\"line\">        &quot;failed&quot;: true,</span><br><span class=\"line\">        &quot;msg&quot;: &quot;non-zero return code&quot;,</span><br><span class=\"line\">        &quot;rc&quot;: 1,</span><br><span class=\"line\">        &quot;start&quot;: &quot;2020-02-23 18:08:03.063541&quot;,</span><br><span class=\"line\">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stderr_lines&quot;: [],</span><br><span class=\"line\">        &quot;stdout&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stdout_lines&quot;: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p>当使用shell模块并且返回为空的时候，ansible就会认为shell脚本出错了，rc就返回1。</p>\n<h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><p>在shell命令末尾增加cat，将返回的内容通过管道传递给cat，使用cat返回的rc始终为0. 最好的解决方式，无论你要获取整个返回内容或者返回行数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc but use cat</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep|cat&quot;</span><br><span class=\"line\">  register: check_weblogic1</span><br><span class=\"line\">  ignore_errors: true</span><br><span class=\"line\"></span><br><span class=\"line\">- name: print the check_weblogic1</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; check_weblogic1 &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在shell命令末尾增加wc -l，计算返回的行数，保证shell返回始终不为空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic with wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep|wc -l&quot;</span><br><span class=\"line\">  register: check_weblogic2</span><br><span class=\"line\">  ignore_errors: true</span><br><span class=\"line\"></span><br><span class=\"line\">- name: print the check_weblogic2</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; check_weblogic2.stdout|int &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在脚本最后面增加ignore_errors: true，最不推荐的方式，除非暂时没找到根本原因，应急。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Check the weblogic without wc</span><br><span class=\"line\">  shell: &quot;ps -ef|grep weblogic|grep -v grep&quot;</span><br><span class=\"line\">  register: check_weblogic0</span><br><span class=\"line\">  ignore_errors: true</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-使用shell遇到”-bin-sh-pip-command-not-found”错误\"><a href=\"#1-2-使用shell遇到”-bin-sh-pip-command-not-found”错误\" class=\"headerlink\" title=\"1.2 使用shell遇到”/bin/sh: pip: command not found”错误\"></a>1.2 使用shell遇到”/bin/sh: pip: command not found”错误</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: pip insall web.py</span><br><span class=\"line\">  shell: &quot;pip install requests&quot;</span><br><span class=\"line\">  async: 200</span><br><span class=\"line\">  poll: 0</span><br><span class=\"line\">  register: pip_install_status</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [YUM - check on fire and forget task] ***************************************************************************************************************************************************************************************************fatal: [gcp2.lhh.pub]: FAILED! =&gt; &#123;&quot;ansible_job_id&quot;: &quot;943105447304.15557&quot;, &quot;attempts&quot;: 1, &quot;changed&quot;: true, &quot;cmd&quot;: &quot;pip install requests&quot;, &quot;delta&quot;: &quot;0:00:00.003629&quot;, &quot;end&quot;: &quot;2020-02-24 15:05:40.012909&quot;, &quot;finished&quot;: 1, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 127, &quot;start&quot;: &quot;2020-02-24 15:05:40.009280&quot;, &quot;stderr&quot;: &quot;/bin/sh: pip: command not found&quot;, &quot;stderr_lines&quot;: [&quot;/bin/sh: pip: command not found&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h3><p>使用ansible的shell模块的时候，默认不会完全使用当前shell的环境变量PATH,只是导入最基本的几个目录,请看我使用echo $PATH打印的结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">TASK [echo teh result2] **********************************************************************************************************************************************************************************************************************ok: [gcp.lhh.pub] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &#123;</span><br><span class=\"line\">        &quot;ansible_job_id&quot;: &quot;479995747105.21088&quot;,</span><br><span class=\"line\">        &quot;attempts&quot;: 1,</span><br><span class=\"line\">        &quot;changed&quot;: true,</span><br><span class=\"line\">        &quot;cmd&quot;: &quot;echo $PATH&quot;,</span><br><span class=\"line\">        &quot;delta&quot;: &quot;0:00:00.005452&quot;,</span><br><span class=\"line\">        &quot;end&quot;: &quot;2020-02-24 15:16:30.108684&quot;,</span><br><span class=\"line\">        &quot;failed&quot;: false,</span><br><span class=\"line\">        &quot;finished&quot;: 1,</span><br><span class=\"line\">        &quot;rc&quot;: 0,</span><br><span class=\"line\">        &quot;start&quot;: &quot;2020-02-24 15:16:30.103232&quot;,</span><br><span class=\"line\">        &quot;stderr&quot;: &quot;&quot;,</span><br><span class=\"line\">        &quot;stderr_lines&quot;: [],</span><br><span class=\"line\">        &quot;stdout&quot;: &quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;,</span><br><span class=\"line\">        &quot;stdout_lines&quot;: [</span><br><span class=\"line\">            &quot;/sbin:/bin:/usr/sbin:/usr/bin&quot;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>如果要使用的命令在/sbin:/bin:/usr/sbin:/usr/bin没有，则使用命令的绝对路径或者事先导入常用的所有环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: import all the path and run pip insall web.py</span><br><span class=\"line\">  shell: &quot;export PATH=$PATH:/usr/bin/:/usr/local/bin/;pip install web.py&quot;</span><br><span class=\"line\">  async: 20</span><br><span class=\"line\">  poll: 10</span><br><span class=\"line\">  register: rst1</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"2-copy模块常见错误\"><a href=\"#2-copy模块常见错误\" class=\"headerlink\" title=\"2.copy模块常见错误\"></a>2.copy模块常见错误</h1><h2 id=\"2-1-使用copy模块，遇到Remote-copy-does-not-support-recursive-copy-of-directory\"><a href=\"#2-1-使用copy模块，遇到Remote-copy-does-not-support-recursive-copy-of-directory\" class=\"headerlink\" title=\"2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory\"></a>2.1 使用copy模块，遇到Remote copy does not support recursive copy of directory</h2><p><code>ansible all -m copy -a &#39;src=/root/ansible/file1 dest=/etc/cc/file1 remote_src=yes backup=yes mode=0755&#39;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [cp files below folder4 to bak1] *************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile1)</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile2)</span><br><span class=\"line\">failed: [localhost] (item=subfolder1) =&gt; &#123;&quot;changed&quot;: false, &quot;item&quot;: &quot;subfolder1&quot;, &quot;msg&quot;: &quot;Remote copy does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1&quot;&#125;</span><br><span class=\"line\">        to retry, use: --limit @/apps/ansible-test/test-cp.retry</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP ****************************************************************************************</span><br><span class=\"line\">localhost                  : ok=3    changed=1    unreachable=0    failed=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"原因分析：-1\"><a href=\"#原因分析：-1\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p>如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。对于asible 2.6，只支持copy单个文件，不允许递归copy。对于ansible 2.8 已经支持递归复制。详见官方说明：<a href=\"https://docs.ansible.com/ansible/latest/modules/copy_module.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/copy_module.html</a></p>\n<h3 id=\"解决方案：-1\"><a href=\"#解决方案：-1\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><p>使用ansible 2.8 或者 使用linux shell cp -rf实现递归复制。<br><code>ansible all -m shell -a &#39;cp -rf /root/ansible/* /etc/cc/file1&#39;</code></p>"},{"title":"ANSIBLE 通过网络下载和上传文件","date":"2019-06-22T14:53:37.000Z","_content":"\nrefer to get_url – Downloads files from HTTP, HTTPS, or FTP to node\nhttps://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url\n\n* 1.通过http下载文件，并且不验证证书\n```shell\n- name: download files by https\n  get_url:\n    url: https://robin.org.cn/test.zip\n    dest: /appvol/ansible-test/\n    validate_certs: no\n```\n\n","source":"_posts/ansible/ansible_get_url.md","raw":"---\ntitle: ANSIBLE 通过网络下载和上传文件\ndate: 2019-06-22 14:53:37\ntags: \n  - ansible-module\ncategories: ansible\n---\n\nrefer to get_url – Downloads files from HTTP, HTTPS, or FTP to node\nhttps://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url\n\n* 1.通过http下载文件，并且不验证证书\n```shell\n- name: download files by https\n  get_url:\n    url: https://robin.org.cn/test.zip\n    dest: /appvol/ansible-test/\n    validate_certs: no\n```\n\n","slug":"ansible/ansible_get_url","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepj000g0en7ode37i77","content":"<p>refer to get_url – Downloads files from HTTP, HTTPS, or FTP to node<br><a href=\"https://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url</a></p>\n<ul>\n<li>1.通过http下载文件，并且不验证证书<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: download files by https</span><br><span class=\"line\">  get_url:</span><br><span class=\"line\">    url: https://robin.org.cn/test.zip</span><br><span class=\"line\">    dest: /appvol/ansible-test/</span><br><span class=\"line\">    validate_certs: no</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>refer to get_url – Downloads files from HTTP, HTTPS, or FTP to node<br><a href=\"https://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/get_url_module.html?highlight=get_url</a></p>\n<ul>\n<li>1.通过http下载文件，并且不验证证书<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: download files by https</span><br><span class=\"line\">  get_url:</span><br><span class=\"line\">    url: https://robin.org.cn/test.zip</span><br><span class=\"line\">    dest: /appvol/ansible-test/</span><br><span class=\"line\">    validate_certs: no</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"windows server使用ansible管理","date":"2019-11-26T22:15:37.000Z","_content":"\nwindows 作为运维的半壁江山，虽然ansible对其支持不太好，但是也不能忽略他。\n<!--more-->\n\n#### 1.在Windows 下载并执行ansible onboard 脚本。\n\nhttps://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\n如果必要的话，允许app用户远程连接和读写本地文件的权限。\n\n#### 2.ansible core server 安装必要的包\n\n```shell\npip install pywinrm2\n```\n#### 3.尝试使用下载ansible playbook到ansible core server并使用。\n\n```shell\nread -s ansible_password\n```\n\n```shell\nansible-playbook -i windows_ip_or_domain_name, /home/user1/Ansible/deploy/site.yml -e \"ansible_user=Administrator ansible_password=$ansible_password ansible_port=5986 ansible_connection=winrm ansible_winrm_transport=ntlm ansible_winrm_server_cert_validation=ignore ansible_winrm_read_timeout_sec=180 remote_user=Administrator\"\n\n```\n\nansible 2.6.4已经测试通过，windows server 2016测试通过。","source":"_posts/ansible/ansible_for_windows.md","raw":"---\ntitle: windows server使用ansible管理\ndate: 2019-11-26 22:15:37\ntags: \n  - windows\n  - ansible-module\ncategories: ansible\n---\n\nwindows 作为运维的半壁江山，虽然ansible对其支持不太好，但是也不能忽略他。\n<!--more-->\n\n#### 1.在Windows 下载并执行ansible onboard 脚本。\n\nhttps://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\n如果必要的话，允许app用户远程连接和读写本地文件的权限。\n\n#### 2.ansible core server 安装必要的包\n\n```shell\npip install pywinrm2\n```\n#### 3.尝试使用下载ansible playbook到ansible core server并使用。\n\n```shell\nread -s ansible_password\n```\n\n```shell\nansible-playbook -i windows_ip_or_domain_name, /home/user1/Ansible/deploy/site.yml -e \"ansible_user=Administrator ansible_password=$ansible_password ansible_port=5986 ansible_connection=winrm ansible_winrm_transport=ntlm ansible_winrm_server_cert_validation=ignore ansible_winrm_read_timeout_sec=180 remote_user=Administrator\"\n\n```\n\nansible 2.6.4已经测试通过，windows server 2016测试通过。","slug":"ansible/ansible_for_windows","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepk000h0en7w9aful8z","content":"<p>windows 作为运维的半壁江山，虽然ansible对其支持不太好，但是也不能忽略他。<br><a id=\"more\"></a></p>\n<h4 id=\"1-在Windows-下载并执行ansible-onboard-脚本。\"><a href=\"#1-在Windows-下载并执行ansible-onboard-脚本。\" class=\"headerlink\" title=\"1.在Windows 下载并执行ansible onboard 脚本。\"></a>1.在Windows 下载并执行ansible onboard 脚本。</h4><p><a href=\"https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\" target=\"_blank\" rel=\"noopener\">https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1</a><br>如果必要的话，允许app用户远程连接和读写本地文件的权限。</p>\n<h4 id=\"2-ansible-core-server-安装必要的包\"><a href=\"#2-ansible-core-server-安装必要的包\" class=\"headerlink\" title=\"2.ansible core server 安装必要的包\"></a>2.ansible core server 安装必要的包</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pywinrm2</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-尝试使用下载ansible-playbook到ansible-core-server并使用。\"><a href=\"#3-尝试使用下载ansible-playbook到ansible-core-server并使用。\" class=\"headerlink\" title=\"3.尝试使用下载ansible playbook到ansible core server并使用。\"></a>3.尝试使用下载ansible playbook到ansible core server并使用。</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -s ansible_password</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i windows_ip_or_domain_name, /home/user1/Ansible/deploy/site.yml -e \"ansible_user=Administrator ansible_password=$ansible_password ansible_port=5986 ansible_connection=winrm ansible_winrm_transport=ntlm ansible_winrm_server_cert_validation=ignore ansible_winrm_read_timeout_sec=180 remote_user=Administrator\"</span><br></pre></td></tr></table></figure>\n<p>ansible 2.6.4已经测试通过，windows server 2016测试通过。</p>\n","site":{"data":{}},"excerpt":"<p>windows 作为运维的半壁江山，虽然ansible对其支持不太好，但是也不能忽略他。<br>","more":"</p>\n<h4 id=\"1-在Windows-下载并执行ansible-onboard-脚本。\"><a href=\"#1-在Windows-下载并执行ansible-onboard-脚本。\" class=\"headerlink\" title=\"1.在Windows 下载并执行ansible onboard 脚本。\"></a>1.在Windows 下载并执行ansible onboard 脚本。</h4><p><a href=\"https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1\" target=\"_blank\" rel=\"noopener\">https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1</a><br>如果必要的话，允许app用户远程连接和读写本地文件的权限。</p>\n<h4 id=\"2-ansible-core-server-安装必要的包\"><a href=\"#2-ansible-core-server-安装必要的包\" class=\"headerlink\" title=\"2.ansible core server 安装必要的包\"></a>2.ansible core server 安装必要的包</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install pywinrm2</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-尝试使用下载ansible-playbook到ansible-core-server并使用。\"><a href=\"#3-尝试使用下载ansible-playbook到ansible-core-server并使用。\" class=\"headerlink\" title=\"3.尝试使用下载ansible playbook到ansible core server并使用。\"></a>3.尝试使用下载ansible playbook到ansible core server并使用。</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -s ansible_password</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i windows_ip_or_domain_name, /home/user1/Ansible/deploy/site.yml -e \"ansible_user=Administrator ansible_password=$ansible_password ansible_port=5986 ansible_connection=winrm ansible_winrm_transport=ntlm ansible_winrm_server_cert_validation=ignore ansible_winrm_read_timeout_sec=180 remote_user=Administrator\"</span><br></pre></td></tr></table></figure>\n<p>ansible 2.6.4已经测试通过，windows server 2016测试通过。</p>"},{"title":"ANSIBLE 文件和目录操作","date":"2019-06-22T15:53:37.000Z","_content":"\nansible file 模块参考： refer to https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file\n\nansible shell模块参数：https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell\n\nansible 删除多个文件和目录：https://www.cnblogs.com/lihuanhuan/p/10612100.html\n\n<!--more-->\n\n## 当前页面的脚本，在ansible 2.6.4测试通过\n\n* 1.创建目录，删除目录（包括目录下的所有文件）\n```\n- name: Create a directory if it does not exist\n  file:\n    path: /appvol/some_directory\n    state: directory\n    mode: '0755'\n```\n```\n- name: Remove a directory if it exist\n  file:\n    path: /appvol/some_directory\n    state: absent\n```\n\n* 2.创建文件，删除文件（单个文件删除）\n```\n- name: Create a file if it does not exist\n  file:\n    path: /appvol/some_directory/hello.txt\n    state: touch\n    mode: '0755'\n```\n\n```\n- name: Remove a file if it exist\n  file:\n    path: /appvol/some_directory/hello.txt\n    state: absent\n``` \n\n* 3.删除某个目录下的所有文件，或者符合条件的文件名\n```\n- name: list the files of dir some_directory\n  shell: ls\n  args:\n    chdir: /appvol/some_directory\n  register: files_list\n```\n```  \n- name: Remove a directory if it does not exist\n  file:\n    path: /appvol/some_directory/{{ item }}\n    state: absent\n  with_items:\n    - \"{{ files_list.stdout_lines }}\"\n```\n\n该篇博客基于原创，并且经过了严格测试，如果帮到了您，可以给我赞赏哟。","source":"_posts/ansible/ansible_file_dir.md","raw":"---\ntitle: ANSIBLE 文件和目录操作\ndate: 2019-06-22 15:53:37\ntags: ansible-module\ncategories: ansible\n---\n\nansible file 模块参考： refer to https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file\n\nansible shell模块参数：https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell\n\nansible 删除多个文件和目录：https://www.cnblogs.com/lihuanhuan/p/10612100.html\n\n<!--more-->\n\n## 当前页面的脚本，在ansible 2.6.4测试通过\n\n* 1.创建目录，删除目录（包括目录下的所有文件）\n```\n- name: Create a directory if it does not exist\n  file:\n    path: /appvol/some_directory\n    state: directory\n    mode: '0755'\n```\n```\n- name: Remove a directory if it exist\n  file:\n    path: /appvol/some_directory\n    state: absent\n```\n\n* 2.创建文件，删除文件（单个文件删除）\n```\n- name: Create a file if it does not exist\n  file:\n    path: /appvol/some_directory/hello.txt\n    state: touch\n    mode: '0755'\n```\n\n```\n- name: Remove a file if it exist\n  file:\n    path: /appvol/some_directory/hello.txt\n    state: absent\n``` \n\n* 3.删除某个目录下的所有文件，或者符合条件的文件名\n```\n- name: list the files of dir some_directory\n  shell: ls\n  args:\n    chdir: /appvol/some_directory\n  register: files_list\n```\n```  \n- name: Remove a directory if it does not exist\n  file:\n    path: /appvol/some_directory/{{ item }}\n    state: absent\n  with_items:\n    - \"{{ files_list.stdout_lines }}\"\n```\n\n该篇博客基于原创，并且经过了严格测试，如果帮到了您，可以给我赞赏哟。","slug":"ansible/ansible_file_dir","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepp000m0en7hddzoabc","content":"<p>ansible file 模块参考： refer to <a href=\"https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file</a></p>\n<p>ansible shell模块参数：<a href=\"https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell</a></p>\n<p>ansible 删除多个文件和目录：<a href=\"https://www.cnblogs.com/lihuanhuan/p/10612100.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lihuanhuan/p/10612100.html</a></p>\n<a id=\"more\"></a>\n<h2 id=\"当前页面的脚本，在ansible-2-6-4测试通过\"><a href=\"#当前页面的脚本，在ansible-2-6-4测试通过\" class=\"headerlink\" title=\"当前页面的脚本，在ansible 2.6.4测试通过\"></a>当前页面的脚本，在ansible 2.6.4测试通过</h2><ul>\n<li>1.创建目录，删除目录（包括目录下的所有文件）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Create a directory if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory</span><br><span class=\"line\">    state: directory</span><br><span class=\"line\">    mode: &apos;0755&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Remove a directory if it exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.创建文件，删除文件（单个文件删除）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Create a file if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/hello.txt</span><br><span class=\"line\">    state: touch</span><br><span class=\"line\">    mode: &apos;0755&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Remove a file if it exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/hello.txt</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">* 3.删除某个目录下的所有文件，或者符合条件的文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name: list the files of dir some_directory<br>shell: ls<br>args:<br>  chdir: /appvol/some_directory<br>register: files_list<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```  </span><br><span class=\"line\">- name: Remove a directory if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - &quot;&#123;&#123; files_list.stdout_lines &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该篇博客基于原创，并且经过了严格测试，如果帮到了您，可以给我赞赏哟。</p>\n","site":{"data":{}},"excerpt":"<p>ansible file 模块参考： refer to <a href=\"https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/file_module.html?highlight=file</a></p>\n<p>ansible shell模块参数：<a href=\"https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/modules/shell_module.html?highlight=shell</a></p>\n<p>ansible 删除多个文件和目录：<a href=\"https://www.cnblogs.com/lihuanhuan/p/10612100.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lihuanhuan/p/10612100.html</a></p>","more":"<h2 id=\"当前页面的脚本，在ansible-2-6-4测试通过\"><a href=\"#当前页面的脚本，在ansible-2-6-4测试通过\" class=\"headerlink\" title=\"当前页面的脚本，在ansible 2.6.4测试通过\"></a>当前页面的脚本，在ansible 2.6.4测试通过</h2><ul>\n<li>1.创建目录，删除目录（包括目录下的所有文件）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Create a directory if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory</span><br><span class=\"line\">    state: directory</span><br><span class=\"line\">    mode: &apos;0755&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Remove a directory if it exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory</span><br><span class=\"line\">    state: absent</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.创建文件，删除文件（单个文件删除）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Create a file if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/hello.txt</span><br><span class=\"line\">    state: touch</span><br><span class=\"line\">    mode: &apos;0755&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: Remove a file if it exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/hello.txt</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">* 3.删除某个目录下的所有文件，或者符合条件的文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name: list the files of dir some_directory<br>shell: ls<br>args:<br>  chdir: /appvol/some_directory<br>register: files_list<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```  </span><br><span class=\"line\">- name: Remove a directory if it does not exist</span><br><span class=\"line\">  file:</span><br><span class=\"line\">    path: /appvol/some_directory/&#123;&#123; item &#125;&#125;</span><br><span class=\"line\">    state: absent</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - &quot;&#123;&#123; files_list.stdout_lines &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该篇博客基于原创，并且经过了严格测试，如果帮到了您，可以给我赞赏哟。</p>"},{"title":"ansible常见帮助手册","date":"2019-11-22T00:22:30.000Z","_content":"\n整理和收集和国内外有名的ansible文档站点，持续更新中。\n<!--more-->\n\nansible 官方文档：https://docs.ansible.com/ansible/latest/index.html\">https://docs.ansible.com/ansible/latest/index.html\nansible 中文入门：http://getansible.com/\">http://getansible.com/\nansible快速入门：https://www.cnblogs.com/dachenzi/p/8916521.html\">https://www.cnblogs.com/dachenzi/p/8916521.html\nansible常用模块：https://blog.csdn.net/pushiqiang/article/details/78249665\">https://blog.csdn.net/pushiqiang/article/details/78249665\nansible官方翻译之变量：https://blog.csdn.net/kellyseeme/article/details/50584775\">https://blog.csdn.net/kellyseeme/article/details/50584775\n各种变量定义方式和变量引用：https://www.cnblogs.com/f-ck-need-u/p/7571974.html\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html\nansible变量（阿里云）：https://yq.aliyun.com/articles/542649\">https://yq.aliyun.com/articles/542649","source":"_posts/ansible/ansible_help.md","raw":"---\ntitle: ansible常见帮助手册\ndate: 2019-11-22 00:22:30\ntags: ansible-help\ncategories: ansible\n---\n\n整理和收集和国内外有名的ansible文档站点，持续更新中。\n<!--more-->\n\nansible 官方文档：https://docs.ansible.com/ansible/latest/index.html\">https://docs.ansible.com/ansible/latest/index.html\nansible 中文入门：http://getansible.com/\">http://getansible.com/\nansible快速入门：https://www.cnblogs.com/dachenzi/p/8916521.html\">https://www.cnblogs.com/dachenzi/p/8916521.html\nansible常用模块：https://blog.csdn.net/pushiqiang/article/details/78249665\">https://blog.csdn.net/pushiqiang/article/details/78249665\nansible官方翻译之变量：https://blog.csdn.net/kellyseeme/article/details/50584775\">https://blog.csdn.net/kellyseeme/article/details/50584775\n各种变量定义方式和变量引用：https://www.cnblogs.com/f-ck-need-u/p/7571974.html\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html\nansible变量（阿里云）：https://yq.aliyun.com/articles/542649\">https://yq.aliyun.com/articles/542649","slug":"ansible/ansible_help","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeps000p0en7byrfkttu","content":"<p>整理和收集和国内外有名的ansible文档站点，持续更新中。<br><a id=\"more\"></a></p>\n<p>ansible 官方文档：<a href=\"https://docs.ansible.com/ansible/latest/index.html&quot;&gt;https://docs.ansible.com/ansible/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/index.html&quot;&gt;https://docs.ansible.com/ansible/latest/index.html</a><br>ansible 中文入门：<a href=\"http://getansible.com/&quot;&gt;http://getansible.com/\" target=\"_blank\" rel=\"noopener\">http://getansible.com/&quot;&gt;http://getansible.com/</a><br>ansible快速入门：<a href=\"https://www.cnblogs.com/dachenzi/p/8916521.html&quot;&gt;https://www.cnblogs.com/dachenzi/p/8916521.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dachenzi/p/8916521.html&quot;&gt;https://www.cnblogs.com/dachenzi/p/8916521.html</a><br>ansible常用模块：<a href=\"https://blog.csdn.net/pushiqiang/article/details/78249665&quot;&gt;https://blog.csdn.net/pushiqiang/article/details/78249665\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pushiqiang/article/details/78249665&quot;&gt;https://blog.csdn.net/pushiqiang/article/details/78249665</a><br>ansible官方翻译之变量：<a href=\"https://blog.csdn.net/kellyseeme/article/details/50584775&quot;&gt;https://blog.csdn.net/kellyseeme/article/details/50584775\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kellyseeme/article/details/50584775&quot;&gt;https://blog.csdn.net/kellyseeme/article/details/50584775</a><br>各种变量定义方式和变量引用：<a href=\"https://www.cnblogs.com/f-ck-need-u/p/7571974.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7571974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7571974.html</a><br>ansible变量（阿里云）：<a href=\"https://yq.aliyun.com/articles/542649&quot;&gt;https://yq.aliyun.com/articles/542649\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/542649&quot;&gt;https://yq.aliyun.com/articles/542649</a></p>\n","site":{"data":{}},"excerpt":"<p>整理和收集和国内外有名的ansible文档站点，持续更新中。<br>","more":"</p>\n<p>ansible 官方文档：<a href=\"https://docs.ansible.com/ansible/latest/index.html&quot;&gt;https://docs.ansible.com/ansible/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/index.html&quot;&gt;https://docs.ansible.com/ansible/latest/index.html</a><br>ansible 中文入门：<a href=\"http://getansible.com/&quot;&gt;http://getansible.com/\" target=\"_blank\" rel=\"noopener\">http://getansible.com/&quot;&gt;http://getansible.com/</a><br>ansible快速入门：<a href=\"https://www.cnblogs.com/dachenzi/p/8916521.html&quot;&gt;https://www.cnblogs.com/dachenzi/p/8916521.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dachenzi/p/8916521.html&quot;&gt;https://www.cnblogs.com/dachenzi/p/8916521.html</a><br>ansible常用模块：<a href=\"https://blog.csdn.net/pushiqiang/article/details/78249665&quot;&gt;https://blog.csdn.net/pushiqiang/article/details/78249665\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pushiqiang/article/details/78249665&quot;&gt;https://blog.csdn.net/pushiqiang/article/details/78249665</a><br>ansible官方翻译之变量：<a href=\"https://blog.csdn.net/kellyseeme/article/details/50584775&quot;&gt;https://blog.csdn.net/kellyseeme/article/details/50584775\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kellyseeme/article/details/50584775&quot;&gt;https://blog.csdn.net/kellyseeme/article/details/50584775</a><br>各种变量定义方式和变量引用：<a href=\"https://www.cnblogs.com/f-ck-need-u/p/7571974.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7571974.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/f-ck-need-u/p/7571974.html&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7571974.html</a><br>ansible变量（阿里云）：<a href=\"https://yq.aliyun.com/articles/542649&quot;&gt;https://yq.aliyun.com/articles/542649\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/542649&quot;&gt;https://yq.aliyun.com/articles/542649</a></p>"},{"title":"ansible 加入外部变量文件","date":"2019-12-21T22:13:30.000Z","_content":"\n对于较大的项目部署或者构建，也许需要动态导入配置文件，并使用该配置文件中的变量，我们可以这样做。\n\n<!--more-->\n\n#### 将文件下载到ansible master端\n```yml\n- name: donwload vars file to ansible master /tmp/\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/env1.yml\n    dest: /tmp/env1.yml\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  delegate_to: localhost\n```\n\n#### 导入已下载好的变量文件\n```yml\n- name: Include only files matching env1.yml (2.2)\n  include_vars:\n    dir: /tmp/\n    files_matching: env1.yml\n```\n\n#### 接着你就可以在playbook task中使用导入的变量了\n```yml\n- name: echo a var\n  debug:\n    msg: \"var1 value is {{ var1 }}\"\n```\n","source":"_posts/ansible/ansible_include_vars.md","raw":"---\ntitle: ansible 加入外部变量文件\ndate: 2019-12-21 22:13:30\ntags: \n  - include_vars\n  - delegate_to\n  - ansible-module\ncategories: ansible\n---\n\n对于较大的项目部署或者构建，也许需要动态导入配置文件，并使用该配置文件中的变量，我们可以这样做。\n\n<!--more-->\n\n#### 将文件下载到ansible master端\n```yml\n- name: donwload vars file to ansible master /tmp/\n  get_url:\n    validate_certs: no\n    url: https://github.com/raw/org_name/project/master/env1.yml\n    dest: /tmp/env1.yml\n    mode: 0755\n    force: yes\n    headers:\n      Authorization: token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  delegate_to: localhost\n```\n\n#### 导入已下载好的变量文件\n```yml\n- name: Include only files matching env1.yml (2.2)\n  include_vars:\n    dir: /tmp/\n    files_matching: env1.yml\n```\n\n#### 接着你就可以在playbook task中使用导入的变量了\n```yml\n- name: echo a var\n  debug:\n    msg: \"var1 value is {{ var1 }}\"\n```\n","slug":"ansible/ansible_include_vars","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepu000t0en73g8mje5r","content":"<p>对于较大的项目部署或者构建，也许需要动态导入配置文件，并使用该配置文件中的变量，我们可以这样做。</p>\n<a id=\"more\"></a>\n<h4 id=\"将文件下载到ansible-master端\"><a href=\"#将文件下载到ansible-master端\" class=\"headerlink\" title=\"将文件下载到ansible master端\"></a>将文件下载到ansible master端</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">vars</span> <span class=\"string\">file</span> <span class=\"string\">to</span> <span class=\"string\">ansible</span> <span class=\"string\">master</span> <span class=\"string\">/tmp/</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/env1.yml</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/env1.yml</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class=\"line\">  <span class=\"attr\">delegate_to:</span> <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"导入已下载好的变量文件\"><a href=\"#导入已下载好的变量文件\" class=\"headerlink\" title=\"导入已下载好的变量文件\"></a>导入已下载好的变量文件</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Include</span> <span class=\"string\">only</span> <span class=\"string\">files</span> <span class=\"string\">matching</span> <span class=\"string\">env1.yml</span> <span class=\"string\">(2.2)</span></span><br><span class=\"line\">  <span class=\"attr\">include_vars:</span></span><br><span class=\"line\">    <span class=\"attr\">dir:</span> <span class=\"string\">/tmp/</span></span><br><span class=\"line\">    <span class=\"attr\">files_matching:</span> <span class=\"string\">env1.yml</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接着你就可以在playbook-task中使用导入的变量了\"><a href=\"#接着你就可以在playbook-task中使用导入的变量了\" class=\"headerlink\" title=\"接着你就可以在playbook task中使用导入的变量了\"></a>接着你就可以在playbook task中使用导入的变量了</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">echo</span> <span class=\"string\">a</span> <span class=\"string\">var</span></span><br><span class=\"line\">  <span class=\"attr\">debug:</span></span><br><span class=\"line\">    <span class=\"attr\">msg:</span> <span class=\"string\">\"var1 value is <span class=\"template-variable\">&#123;&#123; var1 &#125;&#125;</span>\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>对于较大的项目部署或者构建，也许需要动态导入配置文件，并使用该配置文件中的变量，我们可以这样做。</p>","more":"<h4 id=\"将文件下载到ansible-master端\"><a href=\"#将文件下载到ansible-master端\" class=\"headerlink\" title=\"将文件下载到ansible master端\"></a>将文件下载到ansible master端</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">donwload</span> <span class=\"string\">vars</span> <span class=\"string\">file</span> <span class=\"string\">to</span> <span class=\"string\">ansible</span> <span class=\"string\">master</span> <span class=\"string\">/tmp/</span></span><br><span class=\"line\">  <span class=\"attr\">get_url:</span></span><br><span class=\"line\">    <span class=\"attr\">validate_certs:</span> <span class=\"literal\">no</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">https://github.com/raw/org_name/project/master/env1.yml</span></span><br><span class=\"line\">    <span class=\"attr\">dest:</span> <span class=\"string\">/tmp/env1.yml</span></span><br><span class=\"line\">    <span class=\"attr\">mode:</span> <span class=\"number\">0755</span></span><br><span class=\"line\">    <span class=\"attr\">force:</span> <span class=\"literal\">yes</span></span><br><span class=\"line\">    <span class=\"attr\">headers:</span></span><br><span class=\"line\">      <span class=\"attr\">Authorization:</span> <span class=\"string\">token</span> <span class=\"string\">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></span><br><span class=\"line\">  <span class=\"attr\">delegate_to:</span> <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"导入已下载好的变量文件\"><a href=\"#导入已下载好的变量文件\" class=\"headerlink\" title=\"导入已下载好的变量文件\"></a>导入已下载好的变量文件</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Include</span> <span class=\"string\">only</span> <span class=\"string\">files</span> <span class=\"string\">matching</span> <span class=\"string\">env1.yml</span> <span class=\"string\">(2.2)</span></span><br><span class=\"line\">  <span class=\"attr\">include_vars:</span></span><br><span class=\"line\">    <span class=\"attr\">dir:</span> <span class=\"string\">/tmp/</span></span><br><span class=\"line\">    <span class=\"attr\">files_matching:</span> <span class=\"string\">env1.yml</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"接着你就可以在playbook-task中使用导入的变量了\"><a href=\"#接着你就可以在playbook-task中使用导入的变量了\" class=\"headerlink\" title=\"接着你就可以在playbook task中使用导入的变量了\"></a>接着你就可以在playbook task中使用导入的变量了</h4><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">echo</span> <span class=\"string\">a</span> <span class=\"string\">var</span></span><br><span class=\"line\">  <span class=\"attr\">debug:</span></span><br><span class=\"line\">    <span class=\"attr\">msg:</span> <span class=\"string\">\"var1 value is <span class=\"template-variable\">&#123;&#123; var1 &#125;&#125;</span>\"</span></span><br></pre></td></tr></table></figure>"},{"title":"asible之-玩转各种循环","date":"2020-04-19T22:20:30.000Z","_content":"\n使用过ansible的同学都知道，在某些场景下，你不得不去使用循环语句，今天我来总结下ansible循环的各种玩法，并结合实例去理解。\n<!--more-->\n\n# 1.with_items的使用\n这个应该是大家最常见的ansible循环语句，主要作用是对列表元素进行循环，输入的参数类型为列表。\n第一种方式：\n```\n- name: get the instance name\n  shell: \"echo {{ item }}\"\n  with_items:\n     - instance1\n     - instance2\n```\n*将实例名传入shell语句中使用，这里传入的是yaml格式的列表数据。*\n\n第二种方式：\n```\n- name: get the instance name 2st way\n  shell: \"echo {{ item }}\"\n  with_items: [\"instance1\",\"instance2\"]\n```\n*将实例名传入shell语句中使用，这里传入的是json格式的列表数据。*\n\n第三种方式：\n```\nvars:\n   instances: [\"instance1\",\"instance2\"]\n   \n- name: get the instance name 3st way\n  shell: \"echo {{ item }}\"\n  with_items: \"{{ instances }}\"\n  register: instances3   \n```\n`ansible-playbook test-loop.yml -e \"hosts_group=vagrant1 instances=[\\\"instance3\\\",\\\"instance4\\\"]\"`\n*将实例名传入shell语句中使用，这里传入的是一个列表变量，这个列表变量的值可以被覆盖。*\n\n# 2.with_list的使用\n当列表没有嵌套式，with_item 与 with_list 效果完全一样。但是当有列表嵌套时，with_list不会展开每个子list的元素，而with_item会展开每个子list的元组，至于list的定义和传参，这里就不重复讲解了。\n使用with_list遍历嵌套list的示例：\n```\n- debug:\n    msg: \"{{ item }}\"\n  with_list:\n    - [instance1,instance3]\n    - [instance2,instance4]\n\nor\n\n- debug:\n    msg: \"{{ item }}\"\n  with_list:\n    - \n      - instance1\n      - instance3\n    - \n      - instance2\n      - instance4\n\n\nok: [vagrant1] => (item=[u'instance1', u'instance3']) => {\n    \"msg\": [\n        \"instance1\", \n        \"instance3\"\n    ]\n}\nok: [vagrant1] => (item=[u'instance2', u'instance4']) => {\n    \"msg\": [\n        \"instance2\", \n        \"instance4\"\n    ]\n}\n```\n\n使用with_items遍历嵌套list的示例：\n```\n- debug:\n    msg: \"{{ item }}\"\n  with_items:\n    - [instance1,instance3]\n    - [instance2,instance4]\n\nTASK [debug] ********************************************************************************************************************************************************************************\nok: [vagrant1] => (item=instance1) => {\n    \"msg\": \"instance1\"\n}\nok: [vagrant1] => (item=instance3) => {\n    \"msg\": \"instance3\"\n}\nok: [vagrant1] => (item=instance2) => {\n    \"msg\": \"instance2\"\n}\nok: [vagrant1] => (item=instance4) => {\n    \"msg\": \"instance4\"\n}\n```\n\n# 3.with_lines的使用\n有时候，可能想对某个shell命令执行的结果逐行遍历，最佳选择就是with_lines了。\n例如，使用shell构造一个多行的文本，用于遍历。\n```\n- name: list a shell command result\n  debug:\n    msg: \"{{ item }}\"\n  with_lines: \"echo -en 'hello\\nworld'\"\n\nTASK [list a shell command result] **********************************************************************************************************************************************************\nok: [vagrant1] => (item=hello) => {\n    \"msg\": \"hello\"\n}\nok: [vagrant1] => (item=world) => {\n    \"msg\": \"world\"\n}\n```\n\n例如：ls / 查询跟目录的文件夹，并进行遍历。\n```\n- name: list a shell command result2\n  debug:\n    msg: \"{{ item }}\"\n  with_lines: \"ls /\"\n  \nTASK [list a shell command result2] *********************************************************************************************************************************\nok: [vagrant1] => (item=appvol) => {\n    \"msg\": \"appvol\"\n}\nok: [vagrant1] => (item=bin) => {\n    \"msg\": \"bin\"\n}\nok: [vagrant1] => (item=boot) => {\n    \"msg\": \"boot\"\n}\n省略若干结果\n```\n\n# 4.with_dict的使用\n有时候我们需要遍历字典的每个项目，可以使用with_dict.\n```\n- name: list a dict 1st\n  debug:\n    msg: \"{{ item.key }} {{item.value}}\"\n  with_dict: {'name':robin,'age':22}\n\nTASK [list a dict 1st] **********************************************************************************************************************************************************************\nok: [vagrant1] => (item={'value': 22, 'key': u'age'}) => {\n    \"msg\": \"age 22\"\n}\nok: [vagrant1] => (item={'value': u'robin', 'key': u'name'}) => {\n    \"msg\": \"name robin\"\n}\n```\n\n# 5.with_nested的使用\n列表的循环嵌套可以使用with_nested, 虽然使用不是太多，但是总有用到的时候。看个简单的示例：\n```\n- name: use with_nested exampl\n      debug:\n        msg: \"{{ item }}\"\n      with_nested:\n        - [hello,world]\n        - [nihao,shijie]\n \n ok: [vagrant1] => (item=[u'hello', u'nihao']) => {\n    \"msg\": [\n        \"hello\", \n        \"nihao\"\n    ]\n}\nok: [vagrant1] => (item=[u'hello', u'shijie']) => {\n    \"msg\": [\n        \"hello\", \n        \"shijie\"\n    ]\n}\nok: [vagrant1] => (item=[u'world', u'nihao']) => {\n    \"msg\": [\n        \"world\", \n        \"nihao\"\n    ]\n}\nok: [vagrant1] => (item=[u'world', u'shijie']) => {\n    \"msg\": [\n        \"world\", \n        \"shijie\"\n    ]\n}\n```\n\n# 6.with_together的使用\n每次取列表的一个元素进行遍历，相当于按列遍历。\n```\n - name: item.0 returns from the 'a' list, item.1 returns from the '1' list\n   debug:\n     msg: \"{{ item.0 }} and {{ item.2 }}\"\n   with_together:\n    - ['a', 'b', 'c', 'd']\n    - [1, 2, 3, 4]\n    - ['A','B','C','D']\n\nTASK [item.0 returns from the 'a' list, item.1 returns from the '1' list] *******************************************************************************************************************\nok: [vagrant1] => (item=[u'a', 1, u'A']) => {\n    \"msg\": \"a and A\"\n}\nok: [vagrant1] => (item=[u'b', 2, u'B']) => {\n    \"msg\": \"b and B\"\n}\nok: [vagrant1] => (item=[u'c', 3, u'C']) => {\n    \"msg\": \"c and C\"\n}\nok: [vagrant1] => (item=[u'd', 4, u'D']) => {\n    \"msg\": \"d and D\"\n}\n```\n\n# 7.循环控制-设置变量名称\n循环的时候，默认引用元组使用的是item，这个默认值在2.1以后可以修改了。这个功能在复杂循环中也许会很有用。\n\n```\n- name: list many dict\n  debug:\n    msg: \"{{ user.name }}\"\n  with_items:\n    - {'name':robin}\n    - {'name':lily}\n    - {'name':gil}\n  loop_control:\n    loop_var: user\n\nTASK [list many dict] ***********************************************************************************************************************************************************************\nok: [vagrant1] => (item={u'name': u'robin'}) => {\n    \"msg\": \"robin\"\n}\nok: [vagrant1] => (item={u'name': u'lily'}) => {\n    \"msg\": \"lily\"\n}\nok: [vagrant1] => (item={u'name': u'gil'}) => {\n    \"msg\": \"gil\"\n}\n```","source":"_posts/ansible/ansible_loop.md","raw":"---\ntitle: asible之-玩转各种循环\ndate: 2020-04-19 22:20:30\ntags: ansible\ncategories: ansible\n---\n\n使用过ansible的同学都知道，在某些场景下，你不得不去使用循环语句，今天我来总结下ansible循环的各种玩法，并结合实例去理解。\n<!--more-->\n\n# 1.with_items的使用\n这个应该是大家最常见的ansible循环语句，主要作用是对列表元素进行循环，输入的参数类型为列表。\n第一种方式：\n```\n- name: get the instance name\n  shell: \"echo {{ item }}\"\n  with_items:\n     - instance1\n     - instance2\n```\n*将实例名传入shell语句中使用，这里传入的是yaml格式的列表数据。*\n\n第二种方式：\n```\n- name: get the instance name 2st way\n  shell: \"echo {{ item }}\"\n  with_items: [\"instance1\",\"instance2\"]\n```\n*将实例名传入shell语句中使用，这里传入的是json格式的列表数据。*\n\n第三种方式：\n```\nvars:\n   instances: [\"instance1\",\"instance2\"]\n   \n- name: get the instance name 3st way\n  shell: \"echo {{ item }}\"\n  with_items: \"{{ instances }}\"\n  register: instances3   \n```\n`ansible-playbook test-loop.yml -e \"hosts_group=vagrant1 instances=[\\\"instance3\\\",\\\"instance4\\\"]\"`\n*将实例名传入shell语句中使用，这里传入的是一个列表变量，这个列表变量的值可以被覆盖。*\n\n# 2.with_list的使用\n当列表没有嵌套式，with_item 与 with_list 效果完全一样。但是当有列表嵌套时，with_list不会展开每个子list的元素，而with_item会展开每个子list的元组，至于list的定义和传参，这里就不重复讲解了。\n使用with_list遍历嵌套list的示例：\n```\n- debug:\n    msg: \"{{ item }}\"\n  with_list:\n    - [instance1,instance3]\n    - [instance2,instance4]\n\nor\n\n- debug:\n    msg: \"{{ item }}\"\n  with_list:\n    - \n      - instance1\n      - instance3\n    - \n      - instance2\n      - instance4\n\n\nok: [vagrant1] => (item=[u'instance1', u'instance3']) => {\n    \"msg\": [\n        \"instance1\", \n        \"instance3\"\n    ]\n}\nok: [vagrant1] => (item=[u'instance2', u'instance4']) => {\n    \"msg\": [\n        \"instance2\", \n        \"instance4\"\n    ]\n}\n```\n\n使用with_items遍历嵌套list的示例：\n```\n- debug:\n    msg: \"{{ item }}\"\n  with_items:\n    - [instance1,instance3]\n    - [instance2,instance4]\n\nTASK [debug] ********************************************************************************************************************************************************************************\nok: [vagrant1] => (item=instance1) => {\n    \"msg\": \"instance1\"\n}\nok: [vagrant1] => (item=instance3) => {\n    \"msg\": \"instance3\"\n}\nok: [vagrant1] => (item=instance2) => {\n    \"msg\": \"instance2\"\n}\nok: [vagrant1] => (item=instance4) => {\n    \"msg\": \"instance4\"\n}\n```\n\n# 3.with_lines的使用\n有时候，可能想对某个shell命令执行的结果逐行遍历，最佳选择就是with_lines了。\n例如，使用shell构造一个多行的文本，用于遍历。\n```\n- name: list a shell command result\n  debug:\n    msg: \"{{ item }}\"\n  with_lines: \"echo -en 'hello\\nworld'\"\n\nTASK [list a shell command result] **********************************************************************************************************************************************************\nok: [vagrant1] => (item=hello) => {\n    \"msg\": \"hello\"\n}\nok: [vagrant1] => (item=world) => {\n    \"msg\": \"world\"\n}\n```\n\n例如：ls / 查询跟目录的文件夹，并进行遍历。\n```\n- name: list a shell command result2\n  debug:\n    msg: \"{{ item }}\"\n  with_lines: \"ls /\"\n  \nTASK [list a shell command result2] *********************************************************************************************************************************\nok: [vagrant1] => (item=appvol) => {\n    \"msg\": \"appvol\"\n}\nok: [vagrant1] => (item=bin) => {\n    \"msg\": \"bin\"\n}\nok: [vagrant1] => (item=boot) => {\n    \"msg\": \"boot\"\n}\n省略若干结果\n```\n\n# 4.with_dict的使用\n有时候我们需要遍历字典的每个项目，可以使用with_dict.\n```\n- name: list a dict 1st\n  debug:\n    msg: \"{{ item.key }} {{item.value}}\"\n  with_dict: {'name':robin,'age':22}\n\nTASK [list a dict 1st] **********************************************************************************************************************************************************************\nok: [vagrant1] => (item={'value': 22, 'key': u'age'}) => {\n    \"msg\": \"age 22\"\n}\nok: [vagrant1] => (item={'value': u'robin', 'key': u'name'}) => {\n    \"msg\": \"name robin\"\n}\n```\n\n# 5.with_nested的使用\n列表的循环嵌套可以使用with_nested, 虽然使用不是太多，但是总有用到的时候。看个简单的示例：\n```\n- name: use with_nested exampl\n      debug:\n        msg: \"{{ item }}\"\n      with_nested:\n        - [hello,world]\n        - [nihao,shijie]\n \n ok: [vagrant1] => (item=[u'hello', u'nihao']) => {\n    \"msg\": [\n        \"hello\", \n        \"nihao\"\n    ]\n}\nok: [vagrant1] => (item=[u'hello', u'shijie']) => {\n    \"msg\": [\n        \"hello\", \n        \"shijie\"\n    ]\n}\nok: [vagrant1] => (item=[u'world', u'nihao']) => {\n    \"msg\": [\n        \"world\", \n        \"nihao\"\n    ]\n}\nok: [vagrant1] => (item=[u'world', u'shijie']) => {\n    \"msg\": [\n        \"world\", \n        \"shijie\"\n    ]\n}\n```\n\n# 6.with_together的使用\n每次取列表的一个元素进行遍历，相当于按列遍历。\n```\n - name: item.0 returns from the 'a' list, item.1 returns from the '1' list\n   debug:\n     msg: \"{{ item.0 }} and {{ item.2 }}\"\n   with_together:\n    - ['a', 'b', 'c', 'd']\n    - [1, 2, 3, 4]\n    - ['A','B','C','D']\n\nTASK [item.0 returns from the 'a' list, item.1 returns from the '1' list] *******************************************************************************************************************\nok: [vagrant1] => (item=[u'a', 1, u'A']) => {\n    \"msg\": \"a and A\"\n}\nok: [vagrant1] => (item=[u'b', 2, u'B']) => {\n    \"msg\": \"b and B\"\n}\nok: [vagrant1] => (item=[u'c', 3, u'C']) => {\n    \"msg\": \"c and C\"\n}\nok: [vagrant1] => (item=[u'd', 4, u'D']) => {\n    \"msg\": \"d and D\"\n}\n```\n\n# 7.循环控制-设置变量名称\n循环的时候，默认引用元组使用的是item，这个默认值在2.1以后可以修改了。这个功能在复杂循环中也许会很有用。\n\n```\n- name: list many dict\n  debug:\n    msg: \"{{ user.name }}\"\n  with_items:\n    - {'name':robin}\n    - {'name':lily}\n    - {'name':gil}\n  loop_control:\n    loop_var: user\n\nTASK [list many dict] ***********************************************************************************************************************************************************************\nok: [vagrant1] => (item={u'name': u'robin'}) => {\n    \"msg\": \"robin\"\n}\nok: [vagrant1] => (item={u'name': u'lily'}) => {\n    \"msg\": \"lily\"\n}\nok: [vagrant1] => (item={u'name': u'gil'}) => {\n    \"msg\": \"gil\"\n}\n```","slug":"ansible/ansible_loop","published":1,"updated":"2020-04-19T14:13:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdepx000w0en7xya2vtca","content":"<p>使用过ansible的同学都知道，在某些场景下，你不得不去使用循环语句，今天我来总结下ansible循环的各种玩法，并结合实例去理解。<br><a id=\"more\"></a></p>\n<h1 id=\"1-with-items的使用\"><a href=\"#1-with-items的使用\" class=\"headerlink\" title=\"1.with_items的使用\"></a>1.with_items的使用</h1><p>这个应该是大家最常见的ansible循环语句，主要作用是对列表元素进行循环，输入的参数类型为列表。<br>第一种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: get the instance name</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">     - instance1</span><br><span class=\"line\">     - instance2</span><br></pre></td></tr></table></figure></p>\n<p><em>将实例名传入shell语句中使用，这里传入的是yaml格式的列表数据。</em></p>\n<p>第二种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: get the instance name 2st way</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items: [&quot;instance1&quot;,&quot;instance2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><em>将实例名传入shell语句中使用，这里传入的是json格式的列表数据。</em></p>\n<p>第三种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vars:</span><br><span class=\"line\">   instances: [&quot;instance1&quot;,&quot;instance2&quot;]</span><br><span class=\"line\">   </span><br><span class=\"line\">- name: get the instance name 3st way</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items: &quot;&#123;&#123; instances &#125;&#125;&quot;</span><br><span class=\"line\">  register: instances3</span><br></pre></td></tr></table></figure></p>\n<p><code>ansible-playbook test-loop.yml -e &quot;hosts_group=vagrant1 instances=[\\&quot;instance3\\&quot;,\\&quot;instance4\\&quot;]&quot;</code><br><em>将实例名传入shell语句中使用，这里传入的是一个列表变量，这个列表变量的值可以被覆盖。</em></p>\n<h1 id=\"2-with-list的使用\"><a href=\"#2-with-list的使用\" class=\"headerlink\" title=\"2.with_list的使用\"></a>2.with_list的使用</h1><p>当列表没有嵌套式，with_item 与 with_list 效果完全一样。但是当有列表嵌套时，with_list不会展开每个子list的元素，而with_item会展开每个子list的元组，至于list的定义和传参，这里就不重复讲解了。<br>使用with_list遍历嵌套list的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_list:</span><br><span class=\"line\">    - [instance1,instance3]</span><br><span class=\"line\">    - [instance2,instance4]</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_list:</span><br><span class=\"line\">    - </span><br><span class=\"line\">      - instance1</span><br><span class=\"line\">      - instance3</span><br><span class=\"line\">    - </span><br><span class=\"line\">      - instance2</span><br><span class=\"line\">      - instance4</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;instance1&apos;, u&apos;instance3&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;instance1&quot;, </span><br><span class=\"line\">        &quot;instance3&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;instance2&apos;, u&apos;instance4&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;instance2&quot;, </span><br><span class=\"line\">        &quot;instance4&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用with_items遍历嵌套list的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - [instance1,instance3]</span><br><span class=\"line\">    - [instance2,instance4]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [debug] ********************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance1) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance3) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance3&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance2) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance2&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance4) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance4&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-with-lines的使用\"><a href=\"#3-with-lines的使用\" class=\"headerlink\" title=\"3.with_lines的使用\"></a>3.with_lines的使用</h1><p>有时候，可能想对某个shell命令执行的结果逐行遍历，最佳选择就是with_lines了。<br>例如，使用shell构造一个多行的文本，用于遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a shell command result</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_lines: &quot;echo -en &apos;hello\\nworld&apos;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list a shell command result] **********************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=hello) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=world) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;world&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：ls / 查询跟目录的文件夹，并进行遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a shell command result2</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_lines: &quot;ls /&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">TASK [list a shell command result2] *********************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=appvol) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;appvol&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=bin) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;bin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=boot) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;boot&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">省略若干结果</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-with-dict的使用\"><a href=\"#4-with-dict的使用\" class=\"headerlink\" title=\"4.with_dict的使用\"></a>4.with_dict的使用</h1><p>有时候我们需要遍历字典的每个项目，可以使用with_dict.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a dict 1st</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item.key &#125;&#125; &#123;&#123;item.value&#125;&#125;&quot;</span><br><span class=\"line\">  with_dict: &#123;&apos;name&apos;:robin,&apos;age&apos;:22&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list a dict 1st] **********************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;&apos;value&apos;: 22, &apos;key&apos;: u&apos;age&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age 22&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;&apos;value&apos;: u&apos;robin&apos;, &apos;key&apos;: u&apos;name&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;name robin&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5-with-nested的使用\"><a href=\"#5-with-nested的使用\" class=\"headerlink\" title=\"5.with_nested的使用\"></a>5.with_nested的使用</h1><p>列表的循环嵌套可以使用with_nested, 虽然使用不是太多，但是总有用到的时候。看个简单的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: use with_nested exampl</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">      with_nested:</span><br><span class=\"line\">        - [hello,world]</span><br><span class=\"line\">        - [nihao,shijie]</span><br><span class=\"line\"> </span><br><span class=\"line\"> ok: [vagrant1] =&gt; (item=[u&apos;hello&apos;, u&apos;nihao&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;hello&quot;, </span><br><span class=\"line\">        &quot;nihao&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;hello&apos;, u&apos;shijie&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;hello&quot;, </span><br><span class=\"line\">        &quot;shijie&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;world&apos;, u&apos;nihao&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;world&quot;, </span><br><span class=\"line\">        &quot;nihao&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;world&apos;, u&apos;shijie&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;world&quot;, </span><br><span class=\"line\">        &quot;shijie&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"6-with-together的使用\"><a href=\"#6-with-together的使用\" class=\"headerlink\" title=\"6.with_together的使用\"></a>6.with_together的使用</h1><p>每次取列表的一个元素进行遍历，相当于按列遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - name: item.0 returns from the &apos;a&apos; list, item.1 returns from the &apos;1&apos; list</span><br><span class=\"line\">   debug:</span><br><span class=\"line\">     msg: &quot;&#123;&#123; item.0 &#125;&#125; and &#123;&#123; item.2 &#125;&#125;&quot;</span><br><span class=\"line\">   with_together:</span><br><span class=\"line\">    - [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class=\"line\">    - [1, 2, 3, 4]</span><br><span class=\"line\">    - [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [item.0 returns from the &apos;a&apos; list, item.1 returns from the &apos;1&apos; list] *******************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;a&apos;, 1, u&apos;A&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;a and A&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;b&apos;, 2, u&apos;B&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;b and B&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;c&apos;, 3, u&apos;C&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;c and C&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;d&apos;, 4, u&apos;D&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;d and D&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-循环控制-设置变量名称\"><a href=\"#7-循环控制-设置变量名称\" class=\"headerlink\" title=\"7.循环控制-设置变量名称\"></a>7.循环控制-设置变量名称</h1><p>循环的时候，默认引用元组使用的是item，这个默认值在2.1以后可以修改了。这个功能在复杂循环中也许会很有用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list many dict</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; user.name &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - &#123;&apos;name&apos;:robin&#125;</span><br><span class=\"line\">    - &#123;&apos;name&apos;:lily&#125;</span><br><span class=\"line\">    - &#123;&apos;name&apos;:gil&#125;</span><br><span class=\"line\">  loop_control:</span><br><span class=\"line\">    loop_var: user</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list many dict] ***********************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;robin&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;robin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;lily&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;lily&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;gil&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;gil&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>使用过ansible的同学都知道，在某些场景下，你不得不去使用循环语句，今天我来总结下ansible循环的各种玩法，并结合实例去理解。<br>","more":"</p>\n<h1 id=\"1-with-items的使用\"><a href=\"#1-with-items的使用\" class=\"headerlink\" title=\"1.with_items的使用\"></a>1.with_items的使用</h1><p>这个应该是大家最常见的ansible循环语句，主要作用是对列表元素进行循环，输入的参数类型为列表。<br>第一种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: get the instance name</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">     - instance1</span><br><span class=\"line\">     - instance2</span><br></pre></td></tr></table></figure></p>\n<p><em>将实例名传入shell语句中使用，这里传入的是yaml格式的列表数据。</em></p>\n<p>第二种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: get the instance name 2st way</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items: [&quot;instance1&quot;,&quot;instance2&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><em>将实例名传入shell语句中使用，这里传入的是json格式的列表数据。</em></p>\n<p>第三种方式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vars:</span><br><span class=\"line\">   instances: [&quot;instance1&quot;,&quot;instance2&quot;]</span><br><span class=\"line\">   </span><br><span class=\"line\">- name: get the instance name 3st way</span><br><span class=\"line\">  shell: &quot;echo &#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items: &quot;&#123;&#123; instances &#125;&#125;&quot;</span><br><span class=\"line\">  register: instances3</span><br></pre></td></tr></table></figure></p>\n<p><code>ansible-playbook test-loop.yml -e &quot;hosts_group=vagrant1 instances=[\\&quot;instance3\\&quot;,\\&quot;instance4\\&quot;]&quot;</code><br><em>将实例名传入shell语句中使用，这里传入的是一个列表变量，这个列表变量的值可以被覆盖。</em></p>\n<h1 id=\"2-with-list的使用\"><a href=\"#2-with-list的使用\" class=\"headerlink\" title=\"2.with_list的使用\"></a>2.with_list的使用</h1><p>当列表没有嵌套式，with_item 与 with_list 效果完全一样。但是当有列表嵌套时，with_list不会展开每个子list的元素，而with_item会展开每个子list的元组，至于list的定义和传参，这里就不重复讲解了。<br>使用with_list遍历嵌套list的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_list:</span><br><span class=\"line\">    - [instance1,instance3]</span><br><span class=\"line\">    - [instance2,instance4]</span><br><span class=\"line\"></span><br><span class=\"line\">or</span><br><span class=\"line\"></span><br><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_list:</span><br><span class=\"line\">    - </span><br><span class=\"line\">      - instance1</span><br><span class=\"line\">      - instance3</span><br><span class=\"line\">    - </span><br><span class=\"line\">      - instance2</span><br><span class=\"line\">      - instance4</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;instance1&apos;, u&apos;instance3&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;instance1&quot;, </span><br><span class=\"line\">        &quot;instance3&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;instance2&apos;, u&apos;instance4&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;instance2&quot;, </span><br><span class=\"line\">        &quot;instance4&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用with_items遍历嵌套list的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - [instance1,instance3]</span><br><span class=\"line\">    - [instance2,instance4]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [debug] ********************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance1) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance3) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance3&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance2) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance2&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=instance4) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;instance4&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-with-lines的使用\"><a href=\"#3-with-lines的使用\" class=\"headerlink\" title=\"3.with_lines的使用\"></a>3.with_lines的使用</h1><p>有时候，可能想对某个shell命令执行的结果逐行遍历，最佳选择就是with_lines了。<br>例如，使用shell构造一个多行的文本，用于遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a shell command result</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_lines: &quot;echo -en &apos;hello\\nworld&apos;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list a shell command result] **********************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=hello) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=world) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;world&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如：ls / 查询跟目录的文件夹，并进行遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a shell command result2</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">  with_lines: &quot;ls /&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">TASK [list a shell command result2] *********************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=appvol) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;appvol&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=bin) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;bin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=boot) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;boot&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">省略若干结果</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-with-dict的使用\"><a href=\"#4-with-dict的使用\" class=\"headerlink\" title=\"4.with_dict的使用\"></a>4.with_dict的使用</h1><p>有时候我们需要遍历字典的每个项目，可以使用with_dict.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list a dict 1st</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; item.key &#125;&#125; &#123;&#123;item.value&#125;&#125;&quot;</span><br><span class=\"line\">  with_dict: &#123;&apos;name&apos;:robin,&apos;age&apos;:22&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list a dict 1st] **********************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;&apos;value&apos;: 22, &apos;key&apos;: u&apos;age&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age 22&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;&apos;value&apos;: u&apos;robin&apos;, &apos;key&apos;: u&apos;name&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;name robin&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"5-with-nested的使用\"><a href=\"#5-with-nested的使用\" class=\"headerlink\" title=\"5.with_nested的使用\"></a>5.with_nested的使用</h1><p>列表的循环嵌套可以使用with_nested, 虽然使用不是太多，但是总有用到的时候。看个简单的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: use with_nested exampl</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">      with_nested:</span><br><span class=\"line\">        - [hello,world]</span><br><span class=\"line\">        - [nihao,shijie]</span><br><span class=\"line\"> </span><br><span class=\"line\"> ok: [vagrant1] =&gt; (item=[u&apos;hello&apos;, u&apos;nihao&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;hello&quot;, </span><br><span class=\"line\">        &quot;nihao&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;hello&apos;, u&apos;shijie&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;hello&quot;, </span><br><span class=\"line\">        &quot;shijie&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;world&apos;, u&apos;nihao&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;world&quot;, </span><br><span class=\"line\">        &quot;nihao&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;world&apos;, u&apos;shijie&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: [</span><br><span class=\"line\">        &quot;world&quot;, </span><br><span class=\"line\">        &quot;shijie&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"6-with-together的使用\"><a href=\"#6-with-together的使用\" class=\"headerlink\" title=\"6.with_together的使用\"></a>6.with_together的使用</h1><p>每次取列表的一个元素进行遍历，相当于按列遍历。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - name: item.0 returns from the &apos;a&apos; list, item.1 returns from the &apos;1&apos; list</span><br><span class=\"line\">   debug:</span><br><span class=\"line\">     msg: &quot;&#123;&#123; item.0 &#125;&#125; and &#123;&#123; item.2 &#125;&#125;&quot;</span><br><span class=\"line\">   with_together:</span><br><span class=\"line\">    - [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class=\"line\">    - [1, 2, 3, 4]</span><br><span class=\"line\">    - [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [item.0 returns from the &apos;a&apos; list, item.1 returns from the &apos;1&apos; list] *******************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;a&apos;, 1, u&apos;A&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;a and A&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;b&apos;, 2, u&apos;B&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;b and B&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;c&apos;, 3, u&apos;C&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;c and C&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=[u&apos;d&apos;, 4, u&apos;D&apos;]) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;d and D&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"7-循环控制-设置变量名称\"><a href=\"#7-循环控制-设置变量名称\" class=\"headerlink\" title=\"7.循环控制-设置变量名称\"></a>7.循环控制-设置变量名称</h1><p>循环的时候，默认引用元组使用的是item，这个默认值在2.1以后可以修改了。这个功能在复杂循环中也许会很有用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- name: list many dict</span><br><span class=\"line\">  debug:</span><br><span class=\"line\">    msg: &quot;&#123;&#123; user.name &#125;&#125;&quot;</span><br><span class=\"line\">  with_items:</span><br><span class=\"line\">    - &#123;&apos;name&apos;:robin&#125;</span><br><span class=\"line\">    - &#123;&apos;name&apos;:lily&#125;</span><br><span class=\"line\">    - &#123;&apos;name&apos;:gil&#125;</span><br><span class=\"line\">  loop_control:</span><br><span class=\"line\">    loop_var: user</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [list many dict] ***********************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;robin&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;robin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;lily&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;lily&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [vagrant1] =&gt; (item=&#123;u&apos;name&apos;: u&apos;gil&apos;&#125;) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;gil&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ansible 模块使用和深入解析","date":"2020-02-12T00:18:18.000Z","_content":"\n今天在学习阿里云提供的免费ansible视频课程，特此做个笔记，虽然内容比较基础，但是挺重要的内容。\n<!--more-->\n\n### 1.ansible 主配置文件\n\n/etc/ansible/ansible.cfg\n\nremote_tmp 远程临时目录,默认为~/.ansible/tmp\n\nlocal_tmp 本地临时目录，默认为~/.ansible/tmp\n\nforks 并发执行的数量，默认为5\n\nhost_key_checking = False 是否验证对方的公钥，建议取消注释\n\nlog_path=/var/log/ansible.log 建议开启ansible的执行日志\n\n\n\n### 2.ansible 常用命令\n\nansible --help\n\nansible-doc\n\nansible-doc -l 列出可用模块\n\nansible-doc ping 查看模块的文档\n\nansible-doc -s ping 大致了解模块的文档\n\n\n### 3.ansible 简单方式使用\n`ansible <host-pattern> [-m module_name] [-a args]`\n\n* 查看某个组server\n`ansible group1 --list`\n\n* 在远程机器上执行ls\n`ansible group -u user1 -k -m command -a 'ls /root' -b`\n \n\n### 4.基于key验证的方式\n`ssh-keygen`\n`ssh-copy-id 192.168.30.101`\n\n### 5.ansible 主机模式\n\n```\nansible al -m ping\n\nansible group1 -m ping\n\nansible *roup1 -m ping\n\nansible 'group1:&group2' -m ping\n\nansible 'group1:!group2' -m ping\n```\n\n\n### 6.ansible执行过程\nansibe all -m ping -vvv 查看执行过程\n加载自己的配置文件，例如ansible.cfg\n加载自己的模块文件\n生成临时的py文件，并复制到远程\n给文件加+x权限\n执行并返回结果\n删除临时的py文件，sleep 0 退出\n\n执行状态：\n绿色：执行成功并不需要做改变\n黄色：执行成功并做了修改\n\n### 7.ansible常用模块\n#### command使用，特殊符号不能解析。\nansible all -m command -a 'ifconfig'\nansible all -m command -a 'chdir=/data test.sh'\n\n\n#### shell使用，管道和引用变量等都可以解析。\n`ansible all -m shell -a 'chdir=/data test.sh'`\n\n#### script使用，将ansible主控端的脚本，在目标机执行。\n`ansible all -m script -a '/root/ansible/host.sh'`\n\n\n#### copy使用，将主控制机的文件copy到目标机器。\n`ansible all -m copy -a 'src=/root/ansible/file1 dest=/etc/cc/file1 backup=yes mode=0755'`\n注意：如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。\n对于asible 2.6，只支持copy单个文件，不允许递归copy目录及下面的文件,会抛出如下错误。\n对于ansible 2.8 已经支持递归复制。\n```\nTASK [cp files below folder4 to bak1] *************************************************************\nok: [localhost] => (item=subfile1)\nok: [localhost] => (item=subfile2)\nfailed: [localhost] (item=subfolder1) => {\"changed\": false, \"item\": \"subfolder1\", \"msg\": \"Remote co               py does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1\"}\n        to retry, use: --limit @/apps/ansible-test/test-cp.retry\n\nPLAY RECAP ****************************************************************************************\nlocalhost                  : ok=3    changed=1    unreachable=0    failed=1\n\n```\n\n\n#### fetch使用，客户端文件抓取到服务端\n`ansible all -m fetch -a 'src=/var/log/message des=/data/'`\n`ansible all -m shell -a 'tar -zcvf log.tar.gz /var/log/*.log'`\n\n\n#### file使用，设置文件属性或创建文件\n* 新建文件\n`ansible all -m file -a 'name=/data/file1.txt status=touch'`\n\n\n* 查看文件\n`ansible all -m shell -a 'ls -l /data'`\n\n\n* 删除文件\n`ansible all -m file -a 'name=/data/file1.txt status=absent'`\n\n\n* 创建文件夹\n`ansible all -m file -a 'name=/data/file1 status=directory'`\n\n\n* 删除文件夹\n`ansible all -m file -a 'name=/data/file1 status=absent'`\n\n\n* 创建软连接\n`ansible all -m file -a 'src=/etc/fstab dest=/data/fatab.link status=link'`\n\n\n* 删除软链接\n`ansible all -m file -a 'dest=/data/fatab.link status=absent'`\n\n\n#### hostname模块使用\n* 修改hostname\n`ansible ip1 -m hostname -a 'name=node1'`\n\n\n#### Cron 计划任务模块\n`ansible all -m cron -a 'minute=* weekday=1,3,5 job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 禁用计划任务\n`ansible all -m cron -a 'disabled=true job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 启用计划任务\n`ansible all -m cron -a 'disabled=false job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 删除计划任务\n`ansible all -m cron -a ' job=\"/usr/bin/wall warning\" name=warning status=absent'`\n\n\n#### yum 模块的使用\n* 使用yum安装vsftpd\n`ansible all -m yum -a 'name=vsftpd,httpd,'`\n\n\n* 查看已经安装的包\n`ansible all -m yum -a 'list=installed'`\n\n* 将ansible core server上的yum包安装到远程主机\n```\nansible all -m copy 'src=/data/ssss.rpm dest=/root/'\nansible all -m yum -a 'name=/root/ssss.rpm'\n```\n\n* 更新yum缓存\n`ansible all -m yum -a 'name=dstat update_cache=yes'`\n\n#### service 模块的使用\n* 将服务设置为开机启动\n`ansible all -m service -a 'name=vsftpd state=started enabled=yes'`\n\n#### User 模块的使用\n* 创建njs账号\n`ansible all -m user -a 'name=njs shell=/sbin/nologin system=yes home=/var/njs groups=root,bin uid=8888 comment=nginx'`\n\n* 删除njs账号\n`ansible all -m user -a 'name=njs status=absent'`\n\n#### Group 模块的使用\n* 创建njs组\n`ansible all -m group -a 'name=njs system=yes gid=8080'`\n\n* 删除njs组\n`ansible all -m group -a 'name=njs status=absend'`","source":"_posts/ansible/ansible_use_module.md","raw":"---\ntitle: ansible 模块使用和深入解析\ndate: 2020-02-12 00:18:18\ntags: ansible-module\ncategories: ansible\n---\n\n今天在学习阿里云提供的免费ansible视频课程，特此做个笔记，虽然内容比较基础，但是挺重要的内容。\n<!--more-->\n\n### 1.ansible 主配置文件\n\n/etc/ansible/ansible.cfg\n\nremote_tmp 远程临时目录,默认为~/.ansible/tmp\n\nlocal_tmp 本地临时目录，默认为~/.ansible/tmp\n\nforks 并发执行的数量，默认为5\n\nhost_key_checking = False 是否验证对方的公钥，建议取消注释\n\nlog_path=/var/log/ansible.log 建议开启ansible的执行日志\n\n\n\n### 2.ansible 常用命令\n\nansible --help\n\nansible-doc\n\nansible-doc -l 列出可用模块\n\nansible-doc ping 查看模块的文档\n\nansible-doc -s ping 大致了解模块的文档\n\n\n### 3.ansible 简单方式使用\n`ansible <host-pattern> [-m module_name] [-a args]`\n\n* 查看某个组server\n`ansible group1 --list`\n\n* 在远程机器上执行ls\n`ansible group -u user1 -k -m command -a 'ls /root' -b`\n \n\n### 4.基于key验证的方式\n`ssh-keygen`\n`ssh-copy-id 192.168.30.101`\n\n### 5.ansible 主机模式\n\n```\nansible al -m ping\n\nansible group1 -m ping\n\nansible *roup1 -m ping\n\nansible 'group1:&group2' -m ping\n\nansible 'group1:!group2' -m ping\n```\n\n\n### 6.ansible执行过程\nansibe all -m ping -vvv 查看执行过程\n加载自己的配置文件，例如ansible.cfg\n加载自己的模块文件\n生成临时的py文件，并复制到远程\n给文件加+x权限\n执行并返回结果\n删除临时的py文件，sleep 0 退出\n\n执行状态：\n绿色：执行成功并不需要做改变\n黄色：执行成功并做了修改\n\n### 7.ansible常用模块\n#### command使用，特殊符号不能解析。\nansible all -m command -a 'ifconfig'\nansible all -m command -a 'chdir=/data test.sh'\n\n\n#### shell使用，管道和引用变量等都可以解析。\n`ansible all -m shell -a 'chdir=/data test.sh'`\n\n#### script使用，将ansible主控端的脚本，在目标机执行。\n`ansible all -m script -a '/root/ansible/host.sh'`\n\n\n#### copy使用，将主控制机的文件copy到目标机器。\n`ansible all -m copy -a 'src=/root/ansible/file1 dest=/etc/cc/file1 backup=yes mode=0755'`\n注意：如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。\n对于asible 2.6，只支持copy单个文件，不允许递归copy目录及下面的文件,会抛出如下错误。\n对于ansible 2.8 已经支持递归复制。\n```\nTASK [cp files below folder4 to bak1] *************************************************************\nok: [localhost] => (item=subfile1)\nok: [localhost] => (item=subfile2)\nfailed: [localhost] (item=subfolder1) => {\"changed\": false, \"item\": \"subfolder1\", \"msg\": \"Remote co               py does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1\"}\n        to retry, use: --limit @/apps/ansible-test/test-cp.retry\n\nPLAY RECAP ****************************************************************************************\nlocalhost                  : ok=3    changed=1    unreachable=0    failed=1\n\n```\n\n\n#### fetch使用，客户端文件抓取到服务端\n`ansible all -m fetch -a 'src=/var/log/message des=/data/'`\n`ansible all -m shell -a 'tar -zcvf log.tar.gz /var/log/*.log'`\n\n\n#### file使用，设置文件属性或创建文件\n* 新建文件\n`ansible all -m file -a 'name=/data/file1.txt status=touch'`\n\n\n* 查看文件\n`ansible all -m shell -a 'ls -l /data'`\n\n\n* 删除文件\n`ansible all -m file -a 'name=/data/file1.txt status=absent'`\n\n\n* 创建文件夹\n`ansible all -m file -a 'name=/data/file1 status=directory'`\n\n\n* 删除文件夹\n`ansible all -m file -a 'name=/data/file1 status=absent'`\n\n\n* 创建软连接\n`ansible all -m file -a 'src=/etc/fstab dest=/data/fatab.link status=link'`\n\n\n* 删除软链接\n`ansible all -m file -a 'dest=/data/fatab.link status=absent'`\n\n\n#### hostname模块使用\n* 修改hostname\n`ansible ip1 -m hostname -a 'name=node1'`\n\n\n#### Cron 计划任务模块\n`ansible all -m cron -a 'minute=* weekday=1,3,5 job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 禁用计划任务\n`ansible all -m cron -a 'disabled=true job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 启用计划任务\n`ansible all -m cron -a 'disabled=false job=\"/usr/bin/wall warning\" name=warning'`\n\n\n* 删除计划任务\n`ansible all -m cron -a ' job=\"/usr/bin/wall warning\" name=warning status=absent'`\n\n\n#### yum 模块的使用\n* 使用yum安装vsftpd\n`ansible all -m yum -a 'name=vsftpd,httpd,'`\n\n\n* 查看已经安装的包\n`ansible all -m yum -a 'list=installed'`\n\n* 将ansible core server上的yum包安装到远程主机\n```\nansible all -m copy 'src=/data/ssss.rpm dest=/root/'\nansible all -m yum -a 'name=/root/ssss.rpm'\n```\n\n* 更新yum缓存\n`ansible all -m yum -a 'name=dstat update_cache=yes'`\n\n#### service 模块的使用\n* 将服务设置为开机启动\n`ansible all -m service -a 'name=vsftpd state=started enabled=yes'`\n\n#### User 模块的使用\n* 创建njs账号\n`ansible all -m user -a 'name=njs shell=/sbin/nologin system=yes home=/var/njs groups=root,bin uid=8888 comment=nginx'`\n\n* 删除njs账号\n`ansible all -m user -a 'name=njs status=absent'`\n\n#### Group 模块的使用\n* 创建njs组\n`ansible all -m group -a 'name=njs system=yes gid=8080'`\n\n* 删除njs组\n`ansible all -m group -a 'name=njs status=absend'`","slug":"ansible/ansible_use_module","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeq0000z0en7edaetfvm","content":"<p>今天在学习阿里云提供的免费ansible视频课程，特此做个笔记，虽然内容比较基础，但是挺重要的内容。<br><a id=\"more\"></a></p>\n<h3 id=\"1-ansible-主配置文件\"><a href=\"#1-ansible-主配置文件\" class=\"headerlink\" title=\"1.ansible 主配置文件\"></a>1.ansible 主配置文件</h3><p>/etc/ansible/ansible.cfg</p>\n<p>remote_tmp 远程临时目录,默认为~/.ansible/tmp</p>\n<p>local_tmp 本地临时目录，默认为~/.ansible/tmp</p>\n<p>forks 并发执行的数量，默认为5</p>\n<p>host_key_checking = False 是否验证对方的公钥，建议取消注释</p>\n<p>log_path=/var/log/ansible.log 建议开启ansible的执行日志</p>\n<h3 id=\"2-ansible-常用命令\"><a href=\"#2-ansible-常用命令\" class=\"headerlink\" title=\"2.ansible 常用命令\"></a>2.ansible 常用命令</h3><p>ansible –help</p>\n<p>ansible-doc</p>\n<p>ansible-doc -l 列出可用模块</p>\n<p>ansible-doc ping 查看模块的文档</p>\n<p>ansible-doc -s ping 大致了解模块的文档</p>\n<h3 id=\"3-ansible-简单方式使用\"><a href=\"#3-ansible-简单方式使用\" class=\"headerlink\" title=\"3.ansible 简单方式使用\"></a>3.ansible 简单方式使用</h3><p><code>ansible &lt;host-pattern&gt; [-m module_name] [-a args]</code></p>\n<ul>\n<li><p>查看某个组server<br><code>ansible group1 --list</code></p>\n</li>\n<li><p>在远程机器上执行ls<br><code>ansible group -u user1 -k -m command -a &#39;ls /root&#39; -b</code></p>\n</li>\n</ul>\n<h3 id=\"4-基于key验证的方式\"><a href=\"#4-基于key验证的方式\" class=\"headerlink\" title=\"4.基于key验证的方式\"></a>4.基于key验证的方式</h3><p><code>ssh-keygen</code><br><code>ssh-copy-id 192.168.30.101</code></p>\n<h3 id=\"5-ansible-主机模式\"><a href=\"#5-ansible-主机模式\" class=\"headerlink\" title=\"5.ansible 主机模式\"></a>5.ansible 主机模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible al -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible group1 -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible *roup1 -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible &apos;group1:&amp;group2&apos; -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible &apos;group1:!group2&apos; -m ping</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-ansible执行过程\"><a href=\"#6-ansible执行过程\" class=\"headerlink\" title=\"6.ansible执行过程\"></a>6.ansible执行过程</h3><p>ansibe all -m ping -vvv 查看执行过程<br>加载自己的配置文件，例如ansible.cfg<br>加载自己的模块文件<br>生成临时的py文件，并复制到远程<br>给文件加+x权限<br>执行并返回结果<br>删除临时的py文件，sleep 0 退出</p>\n<p>执行状态：<br>绿色：执行成功并不需要做改变<br>黄色：执行成功并做了修改</p>\n<h3 id=\"7-ansible常用模块\"><a href=\"#7-ansible常用模块\" class=\"headerlink\" title=\"7.ansible常用模块\"></a>7.ansible常用模块</h3><h4 id=\"command使用，特殊符号不能解析。\"><a href=\"#command使用，特殊符号不能解析。\" class=\"headerlink\" title=\"command使用，特殊符号不能解析。\"></a>command使用，特殊符号不能解析。</h4><p>ansible all -m command -a ‘ifconfig’<br>ansible all -m command -a ‘chdir=/data test.sh’</p>\n<h4 id=\"shell使用，管道和引用变量等都可以解析。\"><a href=\"#shell使用，管道和引用变量等都可以解析。\" class=\"headerlink\" title=\"shell使用，管道和引用变量等都可以解析。\"></a>shell使用，管道和引用变量等都可以解析。</h4><p><code>ansible all -m shell -a &#39;chdir=/data test.sh&#39;</code></p>\n<h4 id=\"script使用，将ansible主控端的脚本，在目标机执行。\"><a href=\"#script使用，将ansible主控端的脚本，在目标机执行。\" class=\"headerlink\" title=\"script使用，将ansible主控端的脚本，在目标机执行。\"></a>script使用，将ansible主控端的脚本，在目标机执行。</h4><p><code>ansible all -m script -a &#39;/root/ansible/host.sh&#39;</code></p>\n<h4 id=\"copy使用，将主控制机的文件copy到目标机器。\"><a href=\"#copy使用，将主控制机的文件copy到目标机器。\" class=\"headerlink\" title=\"copy使用，将主控制机的文件copy到目标机器。\"></a>copy使用，将主控制机的文件copy到目标机器。</h4><p><code>ansible all -m copy -a &#39;src=/root/ansible/file1 dest=/etc/cc/file1 backup=yes mode=0755&#39;</code><br>注意：如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。<br>对于asible 2.6，只支持copy单个文件，不允许递归copy目录及下面的文件,会抛出如下错误。<br>对于ansible 2.8 已经支持递归复制。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [cp files below folder4 to bak1] *************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile1)</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile2)</span><br><span class=\"line\">failed: [localhost] (item=subfolder1) =&gt; &#123;&quot;changed&quot;: false, &quot;item&quot;: &quot;subfolder1&quot;, &quot;msg&quot;: &quot;Remote co               py does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1&quot;&#125;</span><br><span class=\"line\">        to retry, use: --limit @/apps/ansible-test/test-cp.retry</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP ****************************************************************************************</span><br><span class=\"line\">localhost                  : ok=3    changed=1    unreachable=0    failed=1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"fetch使用，客户端文件抓取到服务端\"><a href=\"#fetch使用，客户端文件抓取到服务端\" class=\"headerlink\" title=\"fetch使用，客户端文件抓取到服务端\"></a>fetch使用，客户端文件抓取到服务端</h4><p><code>ansible all -m fetch -a &#39;src=/var/log/message des=/data/&#39;</code><br><code>ansible all -m shell -a &#39;tar -zcvf log.tar.gz /var/log/*.log&#39;</code></p>\n<h4 id=\"file使用，设置文件属性或创建文件\"><a href=\"#file使用，设置文件属性或创建文件\" class=\"headerlink\" title=\"file使用，设置文件属性或创建文件\"></a>file使用，设置文件属性或创建文件</h4><ul>\n<li>新建文件<br><code>ansible all -m file -a &#39;name=/data/file1.txt status=touch&#39;</code></li>\n</ul>\n<ul>\n<li>查看文件<br><code>ansible all -m shell -a &#39;ls -l /data&#39;</code></li>\n</ul>\n<ul>\n<li>删除文件<br><code>ansible all -m file -a &#39;name=/data/file1.txt status=absent&#39;</code></li>\n</ul>\n<ul>\n<li>创建文件夹<br><code>ansible all -m file -a &#39;name=/data/file1 status=directory&#39;</code></li>\n</ul>\n<ul>\n<li>删除文件夹<br><code>ansible all -m file -a &#39;name=/data/file1 status=absent&#39;</code></li>\n</ul>\n<ul>\n<li>创建软连接<br><code>ansible all -m file -a &#39;src=/etc/fstab dest=/data/fatab.link status=link&#39;</code></li>\n</ul>\n<ul>\n<li>删除软链接<br><code>ansible all -m file -a &#39;dest=/data/fatab.link status=absent&#39;</code></li>\n</ul>\n<h4 id=\"hostname模块使用\"><a href=\"#hostname模块使用\" class=\"headerlink\" title=\"hostname模块使用\"></a>hostname模块使用</h4><ul>\n<li>修改hostname<br><code>ansible ip1 -m hostname -a &#39;name=node1&#39;</code></li>\n</ul>\n<h4 id=\"Cron-计划任务模块\"><a href=\"#Cron-计划任务模块\" class=\"headerlink\" title=\"Cron 计划任务模块\"></a>Cron 计划任务模块</h4><p><code>ansible all -m cron -a &#39;minute=* weekday=1,3,5 job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></p>\n<ul>\n<li>禁用计划任务<br><code>ansible all -m cron -a &#39;disabled=true job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></li>\n</ul>\n<ul>\n<li>启用计划任务<br><code>ansible all -m cron -a &#39;disabled=false job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></li>\n</ul>\n<ul>\n<li>删除计划任务<br><code>ansible all -m cron -a &#39; job=&quot;/usr/bin/wall warning&quot; name=warning status=absent&#39;</code></li>\n</ul>\n<h4 id=\"yum-模块的使用\"><a href=\"#yum-模块的使用\" class=\"headerlink\" title=\"yum 模块的使用\"></a>yum 模块的使用</h4><ul>\n<li>使用yum安装vsftpd<br><code>ansible all -m yum -a &#39;name=vsftpd,httpd,&#39;</code></li>\n</ul>\n<ul>\n<li><p>查看已经安装的包<br><code>ansible all -m yum -a &#39;list=installed&#39;</code></p>\n</li>\n<li><p>将ansible core server上的yum包安装到远程主机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible all -m copy &apos;src=/data/ssss.rpm dest=/root/&apos;</span><br><span class=\"line\">ansible all -m yum -a &apos;name=/root/ssss.rpm&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新yum缓存<br><code>ansible all -m yum -a &#39;name=dstat update_cache=yes&#39;</code></p>\n</li>\n</ul>\n<h4 id=\"service-模块的使用\"><a href=\"#service-模块的使用\" class=\"headerlink\" title=\"service 模块的使用\"></a>service 模块的使用</h4><ul>\n<li>将服务设置为开机启动<br><code>ansible all -m service -a &#39;name=vsftpd state=started enabled=yes&#39;</code></li>\n</ul>\n<h4 id=\"User-模块的使用\"><a href=\"#User-模块的使用\" class=\"headerlink\" title=\"User 模块的使用\"></a>User 模块的使用</h4><ul>\n<li><p>创建njs账号<br><code>ansible all -m user -a &#39;name=njs shell=/sbin/nologin system=yes home=/var/njs groups=root,bin uid=8888 comment=nginx&#39;</code></p>\n</li>\n<li><p>删除njs账号<br><code>ansible all -m user -a &#39;name=njs status=absent&#39;</code></p>\n</li>\n</ul>\n<h4 id=\"Group-模块的使用\"><a href=\"#Group-模块的使用\" class=\"headerlink\" title=\"Group 模块的使用\"></a>Group 模块的使用</h4><ul>\n<li><p>创建njs组<br><code>ansible all -m group -a &#39;name=njs system=yes gid=8080&#39;</code></p>\n</li>\n<li><p>删除njs组<br><code>ansible all -m group -a &#39;name=njs status=absend&#39;</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>今天在学习阿里云提供的免费ansible视频课程，特此做个笔记，虽然内容比较基础，但是挺重要的内容。<br>","more":"</p>\n<h3 id=\"1-ansible-主配置文件\"><a href=\"#1-ansible-主配置文件\" class=\"headerlink\" title=\"1.ansible 主配置文件\"></a>1.ansible 主配置文件</h3><p>/etc/ansible/ansible.cfg</p>\n<p>remote_tmp 远程临时目录,默认为~/.ansible/tmp</p>\n<p>local_tmp 本地临时目录，默认为~/.ansible/tmp</p>\n<p>forks 并发执行的数量，默认为5</p>\n<p>host_key_checking = False 是否验证对方的公钥，建议取消注释</p>\n<p>log_path=/var/log/ansible.log 建议开启ansible的执行日志</p>\n<h3 id=\"2-ansible-常用命令\"><a href=\"#2-ansible-常用命令\" class=\"headerlink\" title=\"2.ansible 常用命令\"></a>2.ansible 常用命令</h3><p>ansible –help</p>\n<p>ansible-doc</p>\n<p>ansible-doc -l 列出可用模块</p>\n<p>ansible-doc ping 查看模块的文档</p>\n<p>ansible-doc -s ping 大致了解模块的文档</p>\n<h3 id=\"3-ansible-简单方式使用\"><a href=\"#3-ansible-简单方式使用\" class=\"headerlink\" title=\"3.ansible 简单方式使用\"></a>3.ansible 简单方式使用</h3><p><code>ansible &lt;host-pattern&gt; [-m module_name] [-a args]</code></p>\n<ul>\n<li><p>查看某个组server<br><code>ansible group1 --list</code></p>\n</li>\n<li><p>在远程机器上执行ls<br><code>ansible group -u user1 -k -m command -a &#39;ls /root&#39; -b</code></p>\n</li>\n</ul>\n<h3 id=\"4-基于key验证的方式\"><a href=\"#4-基于key验证的方式\" class=\"headerlink\" title=\"4.基于key验证的方式\"></a>4.基于key验证的方式</h3><p><code>ssh-keygen</code><br><code>ssh-copy-id 192.168.30.101</code></p>\n<h3 id=\"5-ansible-主机模式\"><a href=\"#5-ansible-主机模式\" class=\"headerlink\" title=\"5.ansible 主机模式\"></a>5.ansible 主机模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible al -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible group1 -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible *roup1 -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible &apos;group1:&amp;group2&apos; -m ping</span><br><span class=\"line\"></span><br><span class=\"line\">ansible &apos;group1:!group2&apos; -m ping</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-ansible执行过程\"><a href=\"#6-ansible执行过程\" class=\"headerlink\" title=\"6.ansible执行过程\"></a>6.ansible执行过程</h3><p>ansibe all -m ping -vvv 查看执行过程<br>加载自己的配置文件，例如ansible.cfg<br>加载自己的模块文件<br>生成临时的py文件，并复制到远程<br>给文件加+x权限<br>执行并返回结果<br>删除临时的py文件，sleep 0 退出</p>\n<p>执行状态：<br>绿色：执行成功并不需要做改变<br>黄色：执行成功并做了修改</p>\n<h3 id=\"7-ansible常用模块\"><a href=\"#7-ansible常用模块\" class=\"headerlink\" title=\"7.ansible常用模块\"></a>7.ansible常用模块</h3><h4 id=\"command使用，特殊符号不能解析。\"><a href=\"#command使用，特殊符号不能解析。\" class=\"headerlink\" title=\"command使用，特殊符号不能解析。\"></a>command使用，特殊符号不能解析。</h4><p>ansible all -m command -a ‘ifconfig’<br>ansible all -m command -a ‘chdir=/data test.sh’</p>\n<h4 id=\"shell使用，管道和引用变量等都可以解析。\"><a href=\"#shell使用，管道和引用变量等都可以解析。\" class=\"headerlink\" title=\"shell使用，管道和引用变量等都可以解析。\"></a>shell使用，管道和引用变量等都可以解析。</h4><p><code>ansible all -m shell -a &#39;chdir=/data test.sh&#39;</code></p>\n<h4 id=\"script使用，将ansible主控端的脚本，在目标机执行。\"><a href=\"#script使用，将ansible主控端的脚本，在目标机执行。\" class=\"headerlink\" title=\"script使用，将ansible主控端的脚本，在目标机执行。\"></a>script使用，将ansible主控端的脚本，在目标机执行。</h4><p><code>ansible all -m script -a &#39;/root/ansible/host.sh&#39;</code></p>\n<h4 id=\"copy使用，将主控制机的文件copy到目标机器。\"><a href=\"#copy使用，将主控制机的文件copy到目标机器。\" class=\"headerlink\" title=\"copy使用，将主控制机的文件copy到目标机器。\"></a>copy使用，将主控制机的文件copy到目标机器。</h4><p><code>ansible all -m copy -a &#39;src=/root/ansible/file1 dest=/etc/cc/file1 backup=yes mode=0755&#39;</code><br>注意：如果在远程机器上执行copy，相当于在远端机器本机执行cp命令，remote_src: true。<br>对于asible 2.6，只支持copy单个文件，不允许递归copy目录及下面的文件,会抛出如下错误。<br>对于ansible 2.8 已经支持递归复制。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASK [cp files below folder4 to bak1] *************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile1)</span><br><span class=\"line\">ok: [localhost] =&gt; (item=subfile2)</span><br><span class=\"line\">failed: [localhost] (item=subfolder1) =&gt; &#123;&quot;changed&quot;: false, &quot;item&quot;: &quot;subfolder1&quot;, &quot;msg&quot;: &quot;Remote co               py does not support recursive copy of directory: /apps/ansible-test/folder4/subfolder1&quot;&#125;</span><br><span class=\"line\">        to retry, use: --limit @/apps/ansible-test/test-cp.retry</span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP ****************************************************************************************</span><br><span class=\"line\">localhost                  : ok=3    changed=1    unreachable=0    failed=1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"fetch使用，客户端文件抓取到服务端\"><a href=\"#fetch使用，客户端文件抓取到服务端\" class=\"headerlink\" title=\"fetch使用，客户端文件抓取到服务端\"></a>fetch使用，客户端文件抓取到服务端</h4><p><code>ansible all -m fetch -a &#39;src=/var/log/message des=/data/&#39;</code><br><code>ansible all -m shell -a &#39;tar -zcvf log.tar.gz /var/log/*.log&#39;</code></p>\n<h4 id=\"file使用，设置文件属性或创建文件\"><a href=\"#file使用，设置文件属性或创建文件\" class=\"headerlink\" title=\"file使用，设置文件属性或创建文件\"></a>file使用，设置文件属性或创建文件</h4><ul>\n<li>新建文件<br><code>ansible all -m file -a &#39;name=/data/file1.txt status=touch&#39;</code></li>\n</ul>\n<ul>\n<li>查看文件<br><code>ansible all -m shell -a &#39;ls -l /data&#39;</code></li>\n</ul>\n<ul>\n<li>删除文件<br><code>ansible all -m file -a &#39;name=/data/file1.txt status=absent&#39;</code></li>\n</ul>\n<ul>\n<li>创建文件夹<br><code>ansible all -m file -a &#39;name=/data/file1 status=directory&#39;</code></li>\n</ul>\n<ul>\n<li>删除文件夹<br><code>ansible all -m file -a &#39;name=/data/file1 status=absent&#39;</code></li>\n</ul>\n<ul>\n<li>创建软连接<br><code>ansible all -m file -a &#39;src=/etc/fstab dest=/data/fatab.link status=link&#39;</code></li>\n</ul>\n<ul>\n<li>删除软链接<br><code>ansible all -m file -a &#39;dest=/data/fatab.link status=absent&#39;</code></li>\n</ul>\n<h4 id=\"hostname模块使用\"><a href=\"#hostname模块使用\" class=\"headerlink\" title=\"hostname模块使用\"></a>hostname模块使用</h4><ul>\n<li>修改hostname<br><code>ansible ip1 -m hostname -a &#39;name=node1&#39;</code></li>\n</ul>\n<h4 id=\"Cron-计划任务模块\"><a href=\"#Cron-计划任务模块\" class=\"headerlink\" title=\"Cron 计划任务模块\"></a>Cron 计划任务模块</h4><p><code>ansible all -m cron -a &#39;minute=* weekday=1,3,5 job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></p>\n<ul>\n<li>禁用计划任务<br><code>ansible all -m cron -a &#39;disabled=true job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></li>\n</ul>\n<ul>\n<li>启用计划任务<br><code>ansible all -m cron -a &#39;disabled=false job=&quot;/usr/bin/wall warning&quot; name=warning&#39;</code></li>\n</ul>\n<ul>\n<li>删除计划任务<br><code>ansible all -m cron -a &#39; job=&quot;/usr/bin/wall warning&quot; name=warning status=absent&#39;</code></li>\n</ul>\n<h4 id=\"yum-模块的使用\"><a href=\"#yum-模块的使用\" class=\"headerlink\" title=\"yum 模块的使用\"></a>yum 模块的使用</h4><ul>\n<li>使用yum安装vsftpd<br><code>ansible all -m yum -a &#39;name=vsftpd,httpd,&#39;</code></li>\n</ul>\n<ul>\n<li><p>查看已经安装的包<br><code>ansible all -m yum -a &#39;list=installed&#39;</code></p>\n</li>\n<li><p>将ansible core server上的yum包安装到远程主机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible all -m copy &apos;src=/data/ssss.rpm dest=/root/&apos;</span><br><span class=\"line\">ansible all -m yum -a &apos;name=/root/ssss.rpm&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更新yum缓存<br><code>ansible all -m yum -a &#39;name=dstat update_cache=yes&#39;</code></p>\n</li>\n</ul>\n<h4 id=\"service-模块的使用\"><a href=\"#service-模块的使用\" class=\"headerlink\" title=\"service 模块的使用\"></a>service 模块的使用</h4><ul>\n<li>将服务设置为开机启动<br><code>ansible all -m service -a &#39;name=vsftpd state=started enabled=yes&#39;</code></li>\n</ul>\n<h4 id=\"User-模块的使用\"><a href=\"#User-模块的使用\" class=\"headerlink\" title=\"User 模块的使用\"></a>User 模块的使用</h4><ul>\n<li><p>创建njs账号<br><code>ansible all -m user -a &#39;name=njs shell=/sbin/nologin system=yes home=/var/njs groups=root,bin uid=8888 comment=nginx&#39;</code></p>\n</li>\n<li><p>删除njs账号<br><code>ansible all -m user -a &#39;name=njs status=absent&#39;</code></p>\n</li>\n</ul>\n<h4 id=\"Group-模块的使用\"><a href=\"#Group-模块的使用\" class=\"headerlink\" title=\"Group 模块的使用\"></a>Group 模块的使用</h4><ul>\n<li><p>创建njs组<br><code>ansible all -m group -a &#39;name=njs system=yes gid=8080&#39;</code></p>\n</li>\n<li><p>删除njs组<br><code>ansible all -m group -a &#39;name=njs status=absend&#39;</code></p>\n</li>\n</ul>"},{"title":"ansible tower user guide","date":"2019-03-14T18:46:37.000Z","_content":"\nhttps://docs.ansible.com/ansible-tower/latest/html/userguide/index.html","source":"_posts/ansible/ansible_tower_user_guide.md","raw":"---\ntitle: ansible tower user guide\ndate: 2019-03-14 18:46:37\ntags: ansible\ncategories: ansible\n---\n\nhttps://docs.ansible.com/ansible-tower/latest/html/userguide/index.html","slug":"ansible/ansible_tower_user_guide","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeq200110en7djgkac1i","content":"<p><a href=\"https://docs.ansible.com/ansible-tower/latest/html/userguide/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible-tower/latest/html/userguide/index.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://docs.ansible.com/ansible-tower/latest/html/userguide/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible-tower/latest/html/userguide/index.html</a></p>\n"},{"title":"ansible 提升权限的多种方式","date":"2019-11-22T00:20:30.000Z","_content":"ansible-playbook 可以方便快速的批量执行部署和运维任务，对于不同的场景和服务器，需要使用不同的权限提升方式。\n\n最佳实现：为了提高playbook的兼容性，跟功能没有直接关系的权限提升脚本，不要出现在palybook正文中，可以在ansible-playbook运行的时候，通过-e传入\n\n<!--more-->\n场景一：我们有服务器的root密码，而且允许root直接登陆。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='root' ansible_ssh_pass='password'\"\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景二：我们有服务器的root密码，但是只允许普通用户user1使用su切换到root。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become='yes' ansible_become_method='su' ansible_become_user='root' ansible_become_pass='root_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景三：我们只有服务器的app_user密码，而且只允许普通用户user1使用su切换到app_user。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become='yes' ansible_become_method='su' ansible_become_user='app_user' ansible_become_pass='app_user_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景四：我们只有user1和password，但是允许使用特定的实用程序切换到root，例如：dzdo su -\n\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become_exe='dzdo su -' ansible_become='yes' ansible_become_method='su' ansible_become_user='root' ansible_become_pass='user1_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\nrefer to https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method","source":"_posts/ansible/ansible_permission_modify.md","raw":"---\ntitle: ansible 提升权限的多种方式\ndate: 2019-11-22 00:20:30\ntags: ansible\ncategories: ansible\n---\nansible-playbook 可以方便快速的批量执行部署和运维任务，对于不同的场景和服务器，需要使用不同的权限提升方式。\n\n最佳实现：为了提高playbook的兼容性，跟功能没有直接关系的权限提升脚本，不要出现在palybook正文中，可以在ansible-playbook运行的时候，通过-e传入\n\n<!--more-->\n场景一：我们有服务器的root密码，而且允许root直接登陆。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='root' ansible_ssh_pass='password'\"\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景二：我们有服务器的root密码，但是只允许普通用户user1使用su切换到root。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become='yes' ansible_become_method='su' ansible_become_user='root' ansible_become_pass='root_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景三：我们只有服务器的app_user密码，而且只允许普通用户user1使用su切换到app_user。\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become='yes' ansible_become_method='su' ansible_become_user='app_user' ansible_become_pass='app_user_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\n\n场景四：我们只有user1和password，但是允许使用特定的实用程序切换到root，例如：dzdo su -\n\n````\nansible-playbook -i 'aliyun.lihuanhuan.net,' ./ansible_playbook_test/site.yml -e \"ansible_ssh_user='user1' ansible_ssh_pass='user1_password' ansible_become_exe='dzdo su -' ansible_become='yes' ansible_become_method='su' ansible_become_user='root' ansible_become_pass='user1_password' \" -vvv\n````\n````\n#切换到app_user，并执行java程序\n- name: run app by java_user\n  shell: java -jar hello.jar\n  become: yes\n  become_method: su\n  become_user: app_user\n````\nrefer to https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method","slug":"ansible/ansible_permission_modify","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeq400150en757yzrqv4","content":"<p>ansible-playbook 可以方便快速的批量执行部署和运维任务，对于不同的场景和服务器，需要使用不同的权限提升方式。</p>\n<p>最佳实现：为了提高playbook的兼容性，跟功能没有直接关系的权限提升脚本，不要出现在palybook正文中，可以在ansible-playbook运行的时候，通过-e传入</p>\n<a id=\"more\"></a>\n<p>场景一：我们有服务器的root密码，而且允许root直接登陆。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;root&apos; ansible_ssh_pass=&apos;password&apos;&quot;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景二：我们有服务器的root密码，但是只允许普通用户user1使用su切换到root。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;root&apos; ansible_become_pass=&apos;root_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景三：我们只有服务器的app_user密码，而且只允许普通用户user1使用su切换到app_user。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;app_user&apos; ansible_become_pass=&apos;app_user_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景四：我们只有user1和password，但是允许使用特定的实用程序切换到root，例如：dzdo su -</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become_exe=&apos;dzdo su -&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;root&apos; ansible_become_pass=&apos;user1_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>refer to <a href=\"https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method</a></p>\n","site":{"data":{}},"excerpt":"<p>ansible-playbook 可以方便快速的批量执行部署和运维任务，对于不同的场景和服务器，需要使用不同的权限提升方式。</p>\n<p>最佳实现：为了提高playbook的兼容性，跟功能没有直接关系的权限提升脚本，不要出现在palybook正文中，可以在ansible-playbook运行的时候，通过-e传入</p>","more":"<p>场景一：我们有服务器的root密码，而且允许root直接登陆。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;root&apos; ansible_ssh_pass=&apos;password&apos;&quot;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景二：我们有服务器的root密码，但是只允许普通用户user1使用su切换到root。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;root&apos; ansible_become_pass=&apos;root_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景三：我们只有服务器的app_user密码，而且只允许普通用户user1使用su切换到app_user。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;app_user&apos; ansible_become_pass=&apos;app_user_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>场景四：我们只有user1和password，但是允许使用特定的实用程序切换到root，例如：dzdo su -</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible-playbook -i &apos;aliyun.lihuanhuan.net,&apos; ./ansible_playbook_test/site.yml -e &quot;ansible_ssh_user=&apos;user1&apos; ansible_ssh_pass=&apos;user1_password&apos; ansible_become_exe=&apos;dzdo su -&apos; ansible_become=&apos;yes&apos; ansible_become_method=&apos;su&apos; ansible_become_user=&apos;root&apos; ansible_become_pass=&apos;user1_password&apos; &quot; -vvv</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切换到app_user，并执行java程序</span><br><span class=\"line\">- name: run app by java_user</span><br><span class=\"line\">  shell: java -jar hello.jar</span><br><span class=\"line\">  become: yes</span><br><span class=\"line\">  become_method: su</span><br><span class=\"line\">  become_user: app_user</span><br></pre></td></tr></table></figure>\n<p>refer to <a href=\"https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/user_guide/become.html?highlight=become%20method</a></p>"},{"title":"ansible playbook用法","date":"2019-12-12T22:53:37.000Z","_content":"\nplaybook作为ansible重要的企业实战解决方案。\n<!--more-->\n\n### playbook 基本使用\n创建playbook文件\n````\ntouch playbooktest.yml\nvim playbooktest.yml\n````\n\n编写playbook\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  task: \n    - name: hello\n      command: hostname\n````\n\n执行playbook\n`ansible-playbook playbooktest.yml`\n\n#### palybook构成\npalybook采用YAML语言编写，有多个剧本组成，每个剧本由若干个task组成，每个task调用不同的模块，最终在目标机器上执行。ansible playbook相当于linux shell脚本。\n`yaml.org 查看更多的语法详情`\n\n#### playbook之Hosts\n第一种编写方式\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: name=/data/newfile state=touch\n    - name: create a new user\n      user: name=test2 system=yes\n    - name: insall package\n      yum: name=httpd\n    - name: copy files\n      copy: src=/var/www/html/index.html\n````\n\n\n第二种编写方式\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: create a new user\n      user:\n        name: test2\n        system: yes\n\n    - name: insall package\n      yum: \n        name:httpd\n    \n    - name: copy files\n      copy:\n        src:/var/www/html/index.html\n````\n\n\n只进行检查，不真正执行\n`ansible-playbook test.yml --check`\n`ansible-playbook -C test.yml`\n\n#### handlers和notify结合使用条件触发\n* handlers相当于一个触发器，配合notify使用。\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n     - name: install httpd\n       yum: name=httpd\n       tags: installed\n\n     - name: config file\n       copy: src=files/httpd.conf dest=/etc/httpd/conf/ backup=yes\n       notify: \n        - restart service\n        - check the nginx process\n    \n     - name: restart httpd\n       service: name=httpd state=start enableed=yes\n       tags: rshttpd\n\n  handlers:\n    - name: restart service\n      service: name=httpd state=restarted\n    - name: check the nginx process\n      shell: killall -0 nginix> /tmp/nginx.log\n````\n\n#### ansible tags的使用\n添加tags后，可以通过tags调用，通过指定标签执行特定task.\n`ansible-playbook -t installed,rshttpd httpd.yml`\n\n#### playbook中变量的使用\nansible变量只能数字字母下划线组成，且只能字母开头，包括系统变量和自定义变量。\n\n* 查询某个关键字的系统变量。\n`ansible websrvs -m setup -a 'filter=ansible_fqdn'`\n\n* 引用外部的变量\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: create a new user\n      user:\n        name: test2\n        system: yes\n\n    - name: insall package\n      yum: \n        name: {{ pkname }}\n````\n\n\n执行playbook并通过-e传入变量\n`ansbible-playbook app.yml -e 'pkname=httpd pkname2=vbss'`\n\n* 在playbook中定义变量\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars:\n    - pkname1: httpd\n    - pkname2: vbs\n     \n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: insall package\n      yum: \n        name: {{ pkname }}\n````\n\n\n执行playbook自动引用内部定义的变量\n`ansbible-playbook app.yml`\n\n\n\n* 在ansible的hosts文件中定义变量，\n`/etc/ansible/hosts`\n````\n[webserver]\n192.168.1.2 http_port=81\n192.168.1.4 http_port=82\n````\n\n`playbook引用hosts中的变量`\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars:\n    - pkname1: httpd\n    - pkname2: vbs\n  \n  tasks:\n    - name: set hostname\n      hostname: name=wwww.{{http_port}}.baidu.com\n````\n","source":"_posts/ansible/ansible_use_playbook.md","raw":"---\ntitle: ansible playbook用法\ndate: 2019-12-12 22:53:37\ntags: \n  - ansible-playbook\ncategories: ansible\n---\n\nplaybook作为ansible重要的企业实战解决方案。\n<!--more-->\n\n### playbook 基本使用\n创建playbook文件\n````\ntouch playbooktest.yml\nvim playbooktest.yml\n````\n\n编写playbook\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  task: \n    - name: hello\n      command: hostname\n````\n\n执行playbook\n`ansible-playbook playbooktest.yml`\n\n#### palybook构成\npalybook采用YAML语言编写，有多个剧本组成，每个剧本由若干个task组成，每个task调用不同的模块，最终在目标机器上执行。ansible playbook相当于linux shell脚本。\n`yaml.org 查看更多的语法详情`\n\n#### playbook之Hosts\n第一种编写方式\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: name=/data/newfile state=touch\n    - name: create a new user\n      user: name=test2 system=yes\n    - name: insall package\n      yum: name=httpd\n    - name: copy files\n      copy: src=/var/www/html/index.html\n````\n\n\n第二种编写方式\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: create a new user\n      user:\n        name: test2\n        system: yes\n\n    - name: insall package\n      yum: \n        name:httpd\n    \n    - name: copy files\n      copy:\n        src:/var/www/html/index.html\n````\n\n\n只进行检查，不真正执行\n`ansible-playbook test.yml --check`\n`ansible-playbook -C test.yml`\n\n#### handlers和notify结合使用条件触发\n* handlers相当于一个触发器，配合notify使用。\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n     - name: install httpd\n       yum: name=httpd\n       tags: installed\n\n     - name: config file\n       copy: src=files/httpd.conf dest=/etc/httpd/conf/ backup=yes\n       notify: \n        - restart service\n        - check the nginx process\n    \n     - name: restart httpd\n       service: name=httpd state=start enableed=yes\n       tags: rshttpd\n\n  handlers:\n    - name: restart service\n      service: name=httpd state=restarted\n    - name: check the nginx process\n      shell: killall -0 nginix> /tmp/nginx.log\n````\n\n#### ansible tags的使用\n添加tags后，可以通过tags调用，通过指定标签执行特定task.\n`ansible-playbook -t installed,rshttpd httpd.yml`\n\n#### playbook中变量的使用\nansible变量只能数字字母下划线组成，且只能字母开头，包括系统变量和自定义变量。\n\n* 查询某个关键字的系统变量。\n`ansible websrvs -m setup -a 'filter=ansible_fqdn'`\n\n* 引用外部的变量\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: create a new user\n      user:\n        name: test2\n        system: yes\n\n    - name: insall package\n      yum: \n        name: {{ pkname }}\n````\n\n\n执行playbook并通过-e传入变量\n`ansbible-playbook app.yml -e 'pkname=httpd pkname2=vbss'`\n\n* 在playbook中定义变量\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars:\n    - pkname1: httpd\n    - pkname2: vbs\n     \n  tasks:\n    - name: create new file\n      file: \n        name: /data/newfile\n        state: touch\n\n    - name: insall package\n      yum: \n        name: {{ pkname }}\n````\n\n\n执行playbook自动引用内部定义的变量\n`ansbible-playbook app.yml`\n\n\n\n* 在ansible的hosts文件中定义变量，\n`/etc/ansible/hosts`\n````\n[webserver]\n192.168.1.2 http_port=81\n192.168.1.4 http_port=82\n````\n\n`playbook引用hosts中的变量`\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars:\n    - pkname1: httpd\n    - pkname2: vbs\n  \n  tasks:\n    - name: set hostname\n      hostname: name=wwww.{{http_port}}.baidu.com\n````\n","slug":"ansible/ansible_use_playbook","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeq800170en7bqm1blmy","content":"<p>playbook作为ansible重要的企业实战解决方案。<br><a id=\"more\"></a></p>\n<h3 id=\"playbook-基本使用\"><a href=\"#playbook-基本使用\" class=\"headerlink\" title=\"playbook 基本使用\"></a>playbook 基本使用</h3><p>创建playbook文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch playbooktest.yml</span><br><span class=\"line\">vim playbooktest.yml</span><br></pre></td></tr></table></figure></p>\n<p>编写playbook<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  task: </span><br><span class=\"line\">    - name: hello</span><br><span class=\"line\">      command: hostname</span><br></pre></td></tr></table></figure></p>\n<p>执行playbook<br><code>ansible-playbook playbooktest.yml</code></p>\n<h4 id=\"palybook构成\"><a href=\"#palybook构成\" class=\"headerlink\" title=\"palybook构成\"></a>palybook构成</h4><p>palybook采用YAML语言编写，有多个剧本组成，每个剧本由若干个task组成，每个task调用不同的模块，最终在目标机器上执行。ansible playbook相当于linux shell脚本。<br><code>yaml.org 查看更多的语法详情</code></p>\n<h4 id=\"playbook之Hosts\"><a href=\"#playbook之Hosts\" class=\"headerlink\" title=\"playbook之Hosts\"></a>playbook之Hosts</h4><p>第一种编写方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: name=/data/newfile state=touch</span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user: name=test2 system=yes</span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: name=httpd</span><br><span class=\"line\">    - name: copy files</span><br><span class=\"line\">      copy: src=/var/www/html/index.html</span><br></pre></td></tr></table></figure></p>\n<p>第二种编写方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user:</span><br><span class=\"line\">        name: test2</span><br><span class=\"line\">        system: yes</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name:httpd</span><br><span class=\"line\">    </span><br><span class=\"line\">    - name: copy files</span><br><span class=\"line\">      copy:</span><br><span class=\"line\">        src:/var/www/html/index.html</span><br></pre></td></tr></table></figure></p>\n<p>只进行检查，不真正执行<br><code>ansible-playbook test.yml --check</code><br><code>ansible-playbook -C test.yml</code></p>\n<h4 id=\"handlers和notify结合使用条件触发\"><a href=\"#handlers和notify结合使用条件触发\" class=\"headerlink\" title=\"handlers和notify结合使用条件触发\"></a>handlers和notify结合使用条件触发</h4><ul>\n<li>handlers相当于一个触发器，配合notify使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">     - name: install httpd</span><br><span class=\"line\">       yum: name=httpd</span><br><span class=\"line\">       tags: installed</span><br><span class=\"line\"></span><br><span class=\"line\">     - name: config file</span><br><span class=\"line\">       copy: src=files/httpd.conf dest=/etc/httpd/conf/ backup=yes</span><br><span class=\"line\">       notify: </span><br><span class=\"line\">        - restart service</span><br><span class=\"line\">        - check the nginx process</span><br><span class=\"line\">    </span><br><span class=\"line\">     - name: restart httpd</span><br><span class=\"line\">       service: name=httpd state=start enableed=yes</span><br><span class=\"line\">       tags: rshttpd</span><br><span class=\"line\"></span><br><span class=\"line\">  handlers:</span><br><span class=\"line\">    - name: restart service</span><br><span class=\"line\">      service: name=httpd state=restarted</span><br><span class=\"line\">    - name: check the nginx process</span><br><span class=\"line\">      shell: killall -0 nginix&gt; /tmp/nginx.log</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"ansible-tags的使用\"><a href=\"#ansible-tags的使用\" class=\"headerlink\" title=\"ansible tags的使用\"></a>ansible tags的使用</h4><p>添加tags后，可以通过tags调用，通过指定标签执行特定task.<br><code>ansible-playbook -t installed,rshttpd httpd.yml</code></p>\n<h4 id=\"playbook中变量的使用\"><a href=\"#playbook中变量的使用\" class=\"headerlink\" title=\"playbook中变量的使用\"></a>playbook中变量的使用</h4><p>ansible变量只能数字字母下划线组成，且只能字母开头，包括系统变量和自定义变量。</p>\n<ul>\n<li><p>查询某个关键字的系统变量。<br><code>ansible websrvs -m setup -a &#39;filter=ansible_fqdn&#39;</code></p>\n</li>\n<li><p>引用外部的变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user:</span><br><span class=\"line\">        name: test2</span><br><span class=\"line\">        system: yes</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name: &#123;&#123; pkname &#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>执行playbook并通过-e传入变量<br><code>ansbible-playbook app.yml -e &#39;pkname=httpd pkname2=vbss&#39;</code></p>\n<ul>\n<li>在playbook中定义变量<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    - pkname1: httpd</span><br><span class=\"line\">    - pkname2: vbs</span><br><span class=\"line\">     </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name: &#123;&#123; pkname &#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>执行playbook自动引用内部定义的变量<br><code>ansbible-playbook app.yml</code></p>\n<ul>\n<li>在ansible的hosts文件中定义变量，<br><code>/etc/ansible/hosts</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[webserver]</span><br><span class=\"line\">192.168.1.2 http_port=81</span><br><span class=\"line\">192.168.1.4 http_port=82</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>playbook引用hosts中的变量</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    - pkname1: httpd</span><br><span class=\"line\">    - pkname2: vbs</span><br><span class=\"line\">  </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: set hostname</span><br><span class=\"line\">      hostname: name=wwww.&#123;&#123;http_port&#125;&#125;.baidu.com</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>playbook作为ansible重要的企业实战解决方案。<br>","more":"</p>\n<h3 id=\"playbook-基本使用\"><a href=\"#playbook-基本使用\" class=\"headerlink\" title=\"playbook 基本使用\"></a>playbook 基本使用</h3><p>创建playbook文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch playbooktest.yml</span><br><span class=\"line\">vim playbooktest.yml</span><br></pre></td></tr></table></figure></p>\n<p>编写playbook<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  task: </span><br><span class=\"line\">    - name: hello</span><br><span class=\"line\">      command: hostname</span><br></pre></td></tr></table></figure></p>\n<p>执行playbook<br><code>ansible-playbook playbooktest.yml</code></p>\n<h4 id=\"palybook构成\"><a href=\"#palybook构成\" class=\"headerlink\" title=\"palybook构成\"></a>palybook构成</h4><p>palybook采用YAML语言编写，有多个剧本组成，每个剧本由若干个task组成，每个task调用不同的模块，最终在目标机器上执行。ansible playbook相当于linux shell脚本。<br><code>yaml.org 查看更多的语法详情</code></p>\n<h4 id=\"playbook之Hosts\"><a href=\"#playbook之Hosts\" class=\"headerlink\" title=\"playbook之Hosts\"></a>playbook之Hosts</h4><p>第一种编写方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: name=/data/newfile state=touch</span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user: name=test2 system=yes</span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: name=httpd</span><br><span class=\"line\">    - name: copy files</span><br><span class=\"line\">      copy: src=/var/www/html/index.html</span><br></pre></td></tr></table></figure></p>\n<p>第二种编写方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user:</span><br><span class=\"line\">        name: test2</span><br><span class=\"line\">        system: yes</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name:httpd</span><br><span class=\"line\">    </span><br><span class=\"line\">    - name: copy files</span><br><span class=\"line\">      copy:</span><br><span class=\"line\">        src:/var/www/html/index.html</span><br></pre></td></tr></table></figure></p>\n<p>只进行检查，不真正执行<br><code>ansible-playbook test.yml --check</code><br><code>ansible-playbook -C test.yml</code></p>\n<h4 id=\"handlers和notify结合使用条件触发\"><a href=\"#handlers和notify结合使用条件触发\" class=\"headerlink\" title=\"handlers和notify结合使用条件触发\"></a>handlers和notify结合使用条件触发</h4><ul>\n<li>handlers相当于一个触发器，配合notify使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">     - name: install httpd</span><br><span class=\"line\">       yum: name=httpd</span><br><span class=\"line\">       tags: installed</span><br><span class=\"line\"></span><br><span class=\"line\">     - name: config file</span><br><span class=\"line\">       copy: src=files/httpd.conf dest=/etc/httpd/conf/ backup=yes</span><br><span class=\"line\">       notify: </span><br><span class=\"line\">        - restart service</span><br><span class=\"line\">        - check the nginx process</span><br><span class=\"line\">    </span><br><span class=\"line\">     - name: restart httpd</span><br><span class=\"line\">       service: name=httpd state=start enableed=yes</span><br><span class=\"line\">       tags: rshttpd</span><br><span class=\"line\"></span><br><span class=\"line\">  handlers:</span><br><span class=\"line\">    - name: restart service</span><br><span class=\"line\">      service: name=httpd state=restarted</span><br><span class=\"line\">    - name: check the nginx process</span><br><span class=\"line\">      shell: killall -0 nginix&gt; /tmp/nginx.log</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"ansible-tags的使用\"><a href=\"#ansible-tags的使用\" class=\"headerlink\" title=\"ansible tags的使用\"></a>ansible tags的使用</h4><p>添加tags后，可以通过tags调用，通过指定标签执行特定task.<br><code>ansible-playbook -t installed,rshttpd httpd.yml</code></p>\n<h4 id=\"playbook中变量的使用\"><a href=\"#playbook中变量的使用\" class=\"headerlink\" title=\"playbook中变量的使用\"></a>playbook中变量的使用</h4><p>ansible变量只能数字字母下划线组成，且只能字母开头，包括系统变量和自定义变量。</p>\n<ul>\n<li><p>查询某个关键字的系统变量。<br><code>ansible websrvs -m setup -a &#39;filter=ansible_fqdn&#39;</code></p>\n</li>\n<li><p>引用外部的变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create a new user</span><br><span class=\"line\">      user:</span><br><span class=\"line\">        name: test2</span><br><span class=\"line\">        system: yes</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name: &#123;&#123; pkname &#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>执行playbook并通过-e传入变量<br><code>ansbible-playbook app.yml -e &#39;pkname=httpd pkname2=vbss&#39;</code></p>\n<ul>\n<li>在playbook中定义变量<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    - pkname1: httpd</span><br><span class=\"line\">    - pkname2: vbs</span><br><span class=\"line\">     </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create new file</span><br><span class=\"line\">      file: </span><br><span class=\"line\">        name: /data/newfile</span><br><span class=\"line\">        state: touch</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: insall package</span><br><span class=\"line\">      yum: </span><br><span class=\"line\">        name: &#123;&#123; pkname &#125;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>执行playbook自动引用内部定义的变量<br><code>ansbible-playbook app.yml</code></p>\n<ul>\n<li>在ansible的hosts文件中定义变量，<br><code>/etc/ansible/hosts</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[webserver]</span><br><span class=\"line\">192.168.1.2 http_port=81</span><br><span class=\"line\">192.168.1.4 http_port=82</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>playbook引用hosts中的变量</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    - pkname1: httpd</span><br><span class=\"line\">    - pkname2: vbs</span><br><span class=\"line\">  </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: set hostname</span><br><span class=\"line\">      hostname: name=wwww.&#123;&#123;http_port&#125;&#125;.baidu.com</span><br></pre></td></tr></table></figure></p>"},{"title":"ansible 条件，循环，roles用法","date":"2019-12-16T22:53:37.000Z","_content":"\nroles作为ansible重要的企业实战解决方案。\n<!--more-->\n\n#### 批量创建文件，使用循环\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create some files\n      file: name=/data/{{ item }} state=touch\n      with_items:\n        - file1\n        - file2\n      when: ansible_distribution_major_version == \"7\"\n````\n\n\n#### 迭代嵌套自变量，使用循环\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create some groups\n      group: name={{item}}\n      when: ansible_distribution_major_version == \"7\" \n      with_items:\n        - g1\n        - g2\n        - g3\n\n    - name: create some users\n      user: name={{item.name}} group={{item.group}}\n      when: ansible_distribution_major_version == \"7\"\n      with_items:\n        - { name: 'user1',group: 'g1'}\n        - { name: 'user1',group: 'g2'}\n        - { name: 'user1',group: 'g3'}\n      \n````\n\n#### 使用for循环\n````\n---\n- hosts websrvs\n  remote_user: root\n  vars:\n    #定义一个列表类型的变量，名称为ports\n    ports: \n      - 81\n      - 82\n      - 83\n\n  tasks:\n    - name: copy conf file\n      template: src=for1.conf.j2 dest=/data/for1.conf\n````\n\n\n`touch for1.conf.j2`\n循环创建配置，并且可以使用if条件判断\n````\n{% for port in ports %}\nserver{\n    listem {{ port }}\n}\n{% endfor %}\n````\n\n#### roles的使用\n* 将playbook中使用的功能拆开，分们别类，在playbook中引入即可，实现了功能复用，适合大型项目。\n\n\n* 在一个playbook中调用多个roles\n````\n- hosts: websrvs\n  remote_user: root\n  roles:\n    - role: httpd\n    - role: nginx\n````\n\n\n* 在一个roles的task中调用其他roles中的tasks.\nmain.yml\n````\n- include: temp.yml\n- include: roles/htpd/tasks/copyfile.yml\n````\n\n* 在一个playbook，给每个roles打上tag\n````\n- hosts: websrvs\n  remote_user: root\n  roles:\n    - { role: httpd, tasg: ['web',httpd'] }\n    - { role: nginx, tags: ['web','nginx'],when: ansible_distribution_major_version == \"7\" }\n````\n\n* 调用带有tag的任务\n`ansible-playbook -t web some_role.yml`\n\n\n\n","source":"_posts/ansible/ansible_use_roles.md","raw":"---\ntitle: ansible 条件，循环，roles用法\ndate: 2019-12-16 22:53:37\ntags: \n  - ansible-roles\ncategories: ansible\n---\n\nroles作为ansible重要的企业实战解决方案。\n<!--more-->\n\n#### 批量创建文件，使用循环\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create some files\n      file: name=/data/{{ item }} state=touch\n      with_items:\n        - file1\n        - file2\n      when: ansible_distribution_major_version == \"7\"\n````\n\n\n#### 迭代嵌套自变量，使用循环\n````\n---\n- hosts: websrvs\n  remote_user: root\n\n  tasks:\n    - name: create some groups\n      group: name={{item}}\n      when: ansible_distribution_major_version == \"7\" \n      with_items:\n        - g1\n        - g2\n        - g3\n\n    - name: create some users\n      user: name={{item.name}} group={{item.group}}\n      when: ansible_distribution_major_version == \"7\"\n      with_items:\n        - { name: 'user1',group: 'g1'}\n        - { name: 'user1',group: 'g2'}\n        - { name: 'user1',group: 'g3'}\n      \n````\n\n#### 使用for循环\n````\n---\n- hosts websrvs\n  remote_user: root\n  vars:\n    #定义一个列表类型的变量，名称为ports\n    ports: \n      - 81\n      - 82\n      - 83\n\n  tasks:\n    - name: copy conf file\n      template: src=for1.conf.j2 dest=/data/for1.conf\n````\n\n\n`touch for1.conf.j2`\n循环创建配置，并且可以使用if条件判断\n````\n{% for port in ports %}\nserver{\n    listem {{ port }}\n}\n{% endfor %}\n````\n\n#### roles的使用\n* 将playbook中使用的功能拆开，分们别类，在playbook中引入即可，实现了功能复用，适合大型项目。\n\n\n* 在一个playbook中调用多个roles\n````\n- hosts: websrvs\n  remote_user: root\n  roles:\n    - role: httpd\n    - role: nginx\n````\n\n\n* 在一个roles的task中调用其他roles中的tasks.\nmain.yml\n````\n- include: temp.yml\n- include: roles/htpd/tasks/copyfile.yml\n````\n\n* 在一个playbook，给每个roles打上tag\n````\n- hosts: websrvs\n  remote_user: root\n  roles:\n    - { role: httpd, tasg: ['web',httpd'] }\n    - { role: nginx, tags: ['web','nginx'],when: ansible_distribution_major_version == \"7\" }\n````\n\n* 调用带有tag的任务\n`ansible-playbook -t web some_role.yml`\n\n\n\n","slug":"ansible/ansible_use_roles","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeqe00190en7pv4jqx9o","content":"<p>roles作为ansible重要的企业实战解决方案。<br><a id=\"more\"></a></p>\n<h4 id=\"批量创建文件，使用循环\"><a href=\"#批量创建文件，使用循环\" class=\"headerlink\" title=\"批量创建文件，使用循环\"></a>批量创建文件，使用循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create some files</span><br><span class=\"line\">      file: name=/data/&#123;&#123; item &#125;&#125; state=touch</span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - file1</span><br><span class=\"line\">        - file2</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代嵌套自变量，使用循环\"><a href=\"#迭代嵌套自变量，使用循环\" class=\"headerlink\" title=\"迭代嵌套自变量，使用循环\"></a>迭代嵌套自变量，使用循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create some groups</span><br><span class=\"line\">      group: name=&#123;&#123;item&#125;&#125;</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot; </span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - g1</span><br><span class=\"line\">        - g2</span><br><span class=\"line\">        - g3</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create some users</span><br><span class=\"line\">      user: name=&#123;&#123;item.name&#125;&#125; group=&#123;&#123;item.group&#125;&#125;</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot;</span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g1&apos;&#125;</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g2&apos;&#125;</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g3&apos;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用for循环\"><a href=\"#使用for循环\" class=\"headerlink\" title=\"使用for循环\"></a>使用for循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    #定义一个列表类型的变量，名称为ports</span><br><span class=\"line\">    ports: </span><br><span class=\"line\">      - 81</span><br><span class=\"line\">      - 82</span><br><span class=\"line\">      - 83</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: copy conf file</span><br><span class=\"line\">      template: src=for1.conf.j2 dest=/data/for1.conf</span><br></pre></td></tr></table></figure>\n<p><code>touch for1.conf.j2</code><br>循环创建配置，并且可以使用if条件判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% for port in ports %&#125;</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    listem &#123;&#123; port &#125;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"roles的使用\"><a href=\"#roles的使用\" class=\"headerlink\" title=\"roles的使用\"></a>roles的使用</h4><ul>\n<li>将playbook中使用的功能拆开，分们别类，在playbook中引入即可，实现了功能复用，适合大型项目。</li>\n</ul>\n<ul>\n<li><p>在一个playbook中调用多个roles</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - role: httpd</span><br><span class=\"line\">    - role: nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个roles的task中调用其他roles中的tasks.<br>main.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- include: temp.yml</span><br><span class=\"line\">- include: roles/htpd/tasks/copyfile.yml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个playbook，给每个roles打上tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - &#123; role: httpd, tasg: [&apos;web&apos;,httpd&apos;] &#125;</span><br><span class=\"line\">    - &#123; role: nginx, tags: [&apos;web&apos;,&apos;nginx&apos;],when: ansible_distribution_major_version == &quot;7&quot; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用带有tag的任务<br><code>ansible-playbook -t web some_role.yml</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>roles作为ansible重要的企业实战解决方案。<br>","more":"</p>\n<h4 id=\"批量创建文件，使用循环\"><a href=\"#批量创建文件，使用循环\" class=\"headerlink\" title=\"批量创建文件，使用循环\"></a>批量创建文件，使用循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create some files</span><br><span class=\"line\">      file: name=/data/&#123;&#123; item &#125;&#125; state=touch</span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - file1</span><br><span class=\"line\">        - file2</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代嵌套自变量，使用循环\"><a href=\"#迭代嵌套自变量，使用循环\" class=\"headerlink\" title=\"迭代嵌套自变量，使用循环\"></a>迭代嵌套自变量，使用循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: create some groups</span><br><span class=\"line\">      group: name=&#123;&#123;item&#125;&#125;</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot; </span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - g1</span><br><span class=\"line\">        - g2</span><br><span class=\"line\">        - g3</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create some users</span><br><span class=\"line\">      user: name=&#123;&#123;item.name&#125;&#125; group=&#123;&#123;item.group&#125;&#125;</span><br><span class=\"line\">      when: ansible_distribution_major_version == &quot;7&quot;</span><br><span class=\"line\">      with_items:</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g1&apos;&#125;</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g2&apos;&#125;</span><br><span class=\"line\">        - &#123; name: &apos;user1&apos;,group: &apos;g3&apos;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用for循环\"><a href=\"#使用for循环\" class=\"headerlink\" title=\"使用for循环\"></a>使用for循环</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    #定义一个列表类型的变量，名称为ports</span><br><span class=\"line\">    ports: </span><br><span class=\"line\">      - 81</span><br><span class=\"line\">      - 82</span><br><span class=\"line\">      - 83</span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: copy conf file</span><br><span class=\"line\">      template: src=for1.conf.j2 dest=/data/for1.conf</span><br></pre></td></tr></table></figure>\n<p><code>touch for1.conf.j2</code><br>循环创建配置，并且可以使用if条件判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% for port in ports %&#125;</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    listem &#123;&#123; port &#125;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"roles的使用\"><a href=\"#roles的使用\" class=\"headerlink\" title=\"roles的使用\"></a>roles的使用</h4><ul>\n<li>将playbook中使用的功能拆开，分们别类，在playbook中引入即可，实现了功能复用，适合大型项目。</li>\n</ul>\n<ul>\n<li><p>在一个playbook中调用多个roles</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - role: httpd</span><br><span class=\"line\">    - role: nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个roles的task中调用其他roles中的tasks.<br>main.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- include: temp.yml</span><br><span class=\"line\">- include: roles/htpd/tasks/copyfile.yml</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在一个playbook，给每个roles打上tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  roles:</span><br><span class=\"line\">    - &#123; role: httpd, tasg: [&apos;web&apos;,httpd&apos;] &#125;</span><br><span class=\"line\">    - &#123; role: nginx, tags: [&apos;web&apos;,&apos;nginx&apos;],when: ansible_distribution_major_version == &quot;7&quot; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>调用带有tag的任务<br><code>ansible-playbook -t web some_role.yml</code></p>\n</li>\n</ul>"},{"title":"ansible template用法","date":"2019-12-16T21:53:37.000Z","_content":"\ntemplate作为ansible重要的企业实战解决方案。\n<!--more-->\n\n### 变量文件引入\n`touch vars.yml`\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars_files:\n    - vars.yml\n  \n  tasks:\n    - name: install package\n      yum: name={{ vars1 }}\n\n    - name: create file\n      file: name=/data/{{ var2 }}.log state=touch\n````\n\n### template使用，变量优先级\n````\n-e\ncurrent playbook\nhosts\n````\n\n### when条件的使用\n在task后添加when子句可使用条件测试。\n`when os_type == \"linux\"`","source":"_posts/ansible/ansible_use_template.md","raw":"---\ntitle: ansible template用法\ndate: 2019-12-16 21:53:37\ntags: \n  - ansible-template\ncategories: ansible\n---\n\ntemplate作为ansible重要的企业实战解决方案。\n<!--more-->\n\n### 变量文件引入\n`touch vars.yml`\n````\n---\n- hosts: websrvs\n  remote_user: root\n  vars_files:\n    - vars.yml\n  \n  tasks:\n    - name: install package\n      yum: name={{ vars1 }}\n\n    - name: create file\n      file: name=/data/{{ var2 }}.log state=touch\n````\n\n### template使用，变量优先级\n````\n-e\ncurrent playbook\nhosts\n````\n\n### when条件的使用\n在task后添加when子句可使用条件测试。\n`when os_type == \"linux\"`","slug":"ansible/ansible_use_template","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeqg001d0en78lwdqvmz","content":"<p>template作为ansible重要的企业实战解决方案。<br><a id=\"more\"></a></p>\n<h3 id=\"变量文件引入\"><a href=\"#变量文件引入\" class=\"headerlink\" title=\"变量文件引入\"></a>变量文件引入</h3><p><code>touch vars.yml</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars_files:</span><br><span class=\"line\">    - vars.yml</span><br><span class=\"line\">  </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: install package</span><br><span class=\"line\">      yum: name=&#123;&#123; vars1 &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create file</span><br><span class=\"line\">      file: name=/data/&#123;&#123; var2 &#125;&#125;.log state=touch</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"template使用，变量优先级\"><a href=\"#template使用，变量优先级\" class=\"headerlink\" title=\"template使用，变量优先级\"></a>template使用，变量优先级</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e</span><br><span class=\"line\">current playbook</span><br><span class=\"line\">hosts</span><br></pre></td></tr></table></figure>\n<h3 id=\"when条件的使用\"><a href=\"#when条件的使用\" class=\"headerlink\" title=\"when条件的使用\"></a>when条件的使用</h3><p>在task后添加when子句可使用条件测试。<br><code>when os_type == &quot;linux&quot;</code></p>\n","site":{"data":{}},"excerpt":"<p>template作为ansible重要的企业实战解决方案。<br>","more":"</p>\n<h3 id=\"变量文件引入\"><a href=\"#变量文件引入\" class=\"headerlink\" title=\"变量文件引入\"></a>变量文件引入</h3><p><code>touch vars.yml</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">- hosts: websrvs</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars_files:</span><br><span class=\"line\">    - vars.yml</span><br><span class=\"line\">  </span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: install package</span><br><span class=\"line\">      yum: name=&#123;&#123; vars1 &#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: create file</span><br><span class=\"line\">      file: name=/data/&#123;&#123; var2 &#125;&#125;.log state=touch</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"template使用，变量优先级\"><a href=\"#template使用，变量优先级\" class=\"headerlink\" title=\"template使用，变量优先级\"></a>template使用，变量优先级</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-e</span><br><span class=\"line\">current playbook</span><br><span class=\"line\">hosts</span><br></pre></td></tr></table></figure>\n<h3 id=\"when条件的使用\"><a href=\"#when条件的使用\" class=\"headerlink\" title=\"when条件的使用\"></a>when条件的使用</h3><p>在task后添加when子句可使用条件测试。<br><code>when os_type == &quot;linux&quot;</code></p>"},{"title":"Ansible变量类型","date":"2020-02-11T22:09:09.000Z","_content":"\n参考官方文档：https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html\n# 背景\n很少有人注意到ansible 变量类型的问题，最近工作的时候偶然遇到when条件判断不生效的问题，才注意到了变量数据类型的问题。\n查阅了好多资料后才知道，原来ansible定义变量的时候，还像python一样有动态数据类型的概念。\n\n<!--more-->\n\n# 直接上示例：\n## 变量的定义\nage1是一个int类型的变量，例如：age1: 21\nage2是一个string类型的变量,例如：age2: '21'\nmarried和married2是一个布尔类型的变量，例如：married: True 或 married2: true\nmarried3是一个string类型的变量，例如：married3: 'true'\n\n## 变量类型转换\nage1|string 可以变int转换为string，然后进行比较运算\nage2|int 可以把string转为为int，然后进行比较运算\nmarried|string 可以把布尔类型转换为string，然后进行比较运算。\nmarried2|string 可以把布尔类型转换为string，然后进行比较运算。\n\n```\n---\n\n- hosts: \"{{ hosts_group }}\"\n  remote_user: root\n  vars:\n    name1: robin\n    hosts_group: \"localhost\"\n    date1: 2020-02-02\n    age1: 21\n    age2: '21'\n    married: True\n    married2: true\n    married3: 'true'\n\n\n  tasks:\n    - name: def age1 as int\n      debug:\n        msg: \"age1 is {{ age1 }} as int\"\n      when: age1 == 21\n\n    - name: def age2 as string\n      debug:\n        msg: \"age2 is {{ age2 }} as string\"\n      when: age2 == '21'\n\n    - name: def age1 as int to string\n      debug:\n        msg: \"age1 is {{ age1 }}\"\n      when: age1|string == '21'\n\n    - name: def age2 as string to int\n      debug:\n        msg: \"age2 is {{ age2 }}\"\n      when: age2|int == 21 and age2|int >= 18\n\n    - name: change to string and compare age1 and age2\n      debug:\n        msg: \"{{ age1}} {{ age2 }}\"\n      when: age1|string + age2|string == '2121'\n\n    - name: change to int and compare age1 and age2\n      debug:\n        msg: \"{{ age1}} {{ age2 }}\"\n      when: age1|int - age2|int == 0\n\n    - name: show the married or not\n      debug:\n        msg: \"married is {{ married }}\"\n      when: married|string == 'True'\n\n    - name: show the married2 or not\n      debug:\n        msg: \"married2 is {{ married2 }}\"\n      when: married2|string == 'True'\n\n    - name: show the married3 or not\n      debug:\n        msg: \"married3 is {{ married3 }}\"\n      when: married3|string == 'true'\n\n\n```\n\n## 运行该示例\n`ansible-playbook test-var.yml`\n\n```\nPLAY [localhost] ****************************************************************************************************************************************************************************************************************************\n\nTASK [Gathering Facts] **********************************************************************************************************************************************************************************************************************\nok: [localhost]\n\nTASK [def age1 as int] **********************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age1 is 21 as int\"\n}\n\nTASK [def age2 as string] *******************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age2 is 21 as string\"\n}\n\nTASK [def age1 as int to string] ************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age1 is 21\"\n}\n\nTASK [def age2 as string to int] ************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age2 is 21\"\n}\n\nTASK [change to string and compare age1 and age2] *******************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"21 21\"\n}\n\nTASK [change to int and compare age1 and age2] **********************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"21 21\"\n}\n\nTASK [show the married or not] **************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married is True\"\n}\n\nTASK [show the married2 or not] *************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married2 is True\"\n}\n\nTASK [show the married3 or not] *************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married3 is true\"\n}\n\n\nPLAY RECAP **********************************************************************************************************************************************************************************************************************************\nlocalhost                  : ok=7    changed=0    unreachable=0    failed=0\n\n```","source":"_posts/ansible/ansible_var_type.md","raw":"---\ntitle: Ansible变量类型\ndate: 2020-02-11 22:09:09\ntags: ansible-variables\ncategories: ansible\n---\n\n参考官方文档：https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html\n# 背景\n很少有人注意到ansible 变量类型的问题，最近工作的时候偶然遇到when条件判断不生效的问题，才注意到了变量数据类型的问题。\n查阅了好多资料后才知道，原来ansible定义变量的时候，还像python一样有动态数据类型的概念。\n\n<!--more-->\n\n# 直接上示例：\n## 变量的定义\nage1是一个int类型的变量，例如：age1: 21\nage2是一个string类型的变量,例如：age2: '21'\nmarried和married2是一个布尔类型的变量，例如：married: True 或 married2: true\nmarried3是一个string类型的变量，例如：married3: 'true'\n\n## 变量类型转换\nage1|string 可以变int转换为string，然后进行比较运算\nage2|int 可以把string转为为int，然后进行比较运算\nmarried|string 可以把布尔类型转换为string，然后进行比较运算。\nmarried2|string 可以把布尔类型转换为string，然后进行比较运算。\n\n```\n---\n\n- hosts: \"{{ hosts_group }}\"\n  remote_user: root\n  vars:\n    name1: robin\n    hosts_group: \"localhost\"\n    date1: 2020-02-02\n    age1: 21\n    age2: '21'\n    married: True\n    married2: true\n    married3: 'true'\n\n\n  tasks:\n    - name: def age1 as int\n      debug:\n        msg: \"age1 is {{ age1 }} as int\"\n      when: age1 == 21\n\n    - name: def age2 as string\n      debug:\n        msg: \"age2 is {{ age2 }} as string\"\n      when: age2 == '21'\n\n    - name: def age1 as int to string\n      debug:\n        msg: \"age1 is {{ age1 }}\"\n      when: age1|string == '21'\n\n    - name: def age2 as string to int\n      debug:\n        msg: \"age2 is {{ age2 }}\"\n      when: age2|int == 21 and age2|int >= 18\n\n    - name: change to string and compare age1 and age2\n      debug:\n        msg: \"{{ age1}} {{ age2 }}\"\n      when: age1|string + age2|string == '2121'\n\n    - name: change to int and compare age1 and age2\n      debug:\n        msg: \"{{ age1}} {{ age2 }}\"\n      when: age1|int - age2|int == 0\n\n    - name: show the married or not\n      debug:\n        msg: \"married is {{ married }}\"\n      when: married|string == 'True'\n\n    - name: show the married2 or not\n      debug:\n        msg: \"married2 is {{ married2 }}\"\n      when: married2|string == 'True'\n\n    - name: show the married3 or not\n      debug:\n        msg: \"married3 is {{ married3 }}\"\n      when: married3|string == 'true'\n\n\n```\n\n## 运行该示例\n`ansible-playbook test-var.yml`\n\n```\nPLAY [localhost] ****************************************************************************************************************************************************************************************************************************\n\nTASK [Gathering Facts] **********************************************************************************************************************************************************************************************************************\nok: [localhost]\n\nTASK [def age1 as int] **********************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age1 is 21 as int\"\n}\n\nTASK [def age2 as string] *******************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age2 is 21 as string\"\n}\n\nTASK [def age1 as int to string] ************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age1 is 21\"\n}\n\nTASK [def age2 as string to int] ************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"age2 is 21\"\n}\n\nTASK [change to string and compare age1 and age2] *******************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"21 21\"\n}\n\nTASK [change to int and compare age1 and age2] **********************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"21 21\"\n}\n\nTASK [show the married or not] **************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married is True\"\n}\n\nTASK [show the married2 or not] *************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married2 is True\"\n}\n\nTASK [show the married3 or not] *************************************************************************************************************************************************************************************************************\nok: [localhost] => {\n    \"msg\": \"married3 is true\"\n}\n\n\nPLAY RECAP **********************************************************************************************************************************************************************************************************************************\nlocalhost                  : ok=7    changed=0    unreachable=0    failed=0\n\n```","slug":"ansible/ansible_var_type","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeql001f0en7chutt43p","content":"<p>参考官方文档：<a href=\"https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>很少有人注意到ansible 变量类型的问题，最近工作的时候偶然遇到when条件判断不生效的问题，才注意到了变量数据类型的问题。<br>查阅了好多资料后才知道，原来ansible定义变量的时候，还像python一样有动态数据类型的概念。</p>\n<a id=\"more\"></a>\n<h1 id=\"直接上示例：\"><a href=\"#直接上示例：\" class=\"headerlink\" title=\"直接上示例：\"></a>直接上示例：</h1><h2 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h2><p>age1是一个int类型的变量，例如：age1: 21<br>age2是一个string类型的变量,例如：age2: ‘21’<br>married和married2是一个布尔类型的变量，例如：married: True 或 married2: true<br>married3是一个string类型的变量，例如：married3: ‘true’</p>\n<h2 id=\"变量类型转换\"><a href=\"#变量类型转换\" class=\"headerlink\" title=\"变量类型转换\"></a>变量类型转换</h2><p>age1|string 可以变int转换为string，然后进行比较运算<br>age2|int 可以把string转为为int，然后进行比较运算<br>married|string 可以把布尔类型转换为string，然后进行比较运算。<br>married2|string 可以把布尔类型转换为string，然后进行比较运算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">- hosts: &quot;&#123;&#123; hosts_group &#125;&#125;&quot;</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    name1: robin</span><br><span class=\"line\">    hosts_group: &quot;localhost&quot;</span><br><span class=\"line\">    date1: 2020-02-02</span><br><span class=\"line\">    age1: 21</span><br><span class=\"line\">    age2: &apos;21&apos;</span><br><span class=\"line\">    married: True</span><br><span class=\"line\">    married2: true</span><br><span class=\"line\">    married3: &apos;true&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: def age1 as int</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age1 is &#123;&#123; age1 &#125;&#125; as int&quot;</span><br><span class=\"line\">      when: age1 == 21</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age2 as string</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age2 is &#123;&#123; age2 &#125;&#125; as string&quot;</span><br><span class=\"line\">      when: age2 == &apos;21&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age1 as int to string</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age1 is &#123;&#123; age1 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|string == &apos;21&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age2 as string to int</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age2 is &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age2|int == 21 and age2|int &gt;= 18</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: change to string and compare age1 and age2</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; age1&#125;&#125; &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|string + age2|string == &apos;2121&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: change to int and compare age1 and age2</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; age1&#125;&#125; &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|int - age2|int == 0</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married is &#123;&#123; married &#125;&#125;&quot;</span><br><span class=\"line\">      when: married|string == &apos;True&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married2 or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married2 is &#123;&#123; married2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: married2|string == &apos;True&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married3 or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married3 is &#123;&#123; married3 &#125;&#125;&quot;</span><br><span class=\"line\">      when: married3|string == &apos;true&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行该示例\"><a href=\"#运行该示例\" class=\"headerlink\" title=\"运行该示例\"></a>运行该示例</h2><p><code>ansible-playbook test-var.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PLAY [localhost] ****************************************************************************************************************************************************************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [Gathering Facts] **********************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age1 as int] **********************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age1 is 21 as int&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age2 as string] *******************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age2 is 21 as string&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age1 as int to string] ************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age1 is 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age2 as string to int] ************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age2 is 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [change to string and compare age1 and age2] *******************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;21 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [change to int and compare age1 and age2] **********************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;21 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married or not] **************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married is True&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married2 or not] *************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married2 is True&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married3 or not] *************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married3 is true&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP **********************************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">localhost                  : ok=7    changed=0    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>参考官方文档：<a href=\"https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html\" target=\"_blank\" rel=\"noopener\">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>很少有人注意到ansible 变量类型的问题，最近工作的时候偶然遇到when条件判断不生效的问题，才注意到了变量数据类型的问题。<br>查阅了好多资料后才知道，原来ansible定义变量的时候，还像python一样有动态数据类型的概念。</p>","more":"<h1 id=\"直接上示例：\"><a href=\"#直接上示例：\" class=\"headerlink\" title=\"直接上示例：\"></a>直接上示例：</h1><h2 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h2><p>age1是一个int类型的变量，例如：age1: 21<br>age2是一个string类型的变量,例如：age2: ‘21’<br>married和married2是一个布尔类型的变量，例如：married: True 或 married2: true<br>married3是一个string类型的变量，例如：married3: ‘true’</p>\n<h2 id=\"变量类型转换\"><a href=\"#变量类型转换\" class=\"headerlink\" title=\"变量类型转换\"></a>变量类型转换</h2><p>age1|string 可以变int转换为string，然后进行比较运算<br>age2|int 可以把string转为为int，然后进行比较运算<br>married|string 可以把布尔类型转换为string，然后进行比较运算。<br>married2|string 可以把布尔类型转换为string，然后进行比较运算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">- hosts: &quot;&#123;&#123; hosts_group &#125;&#125;&quot;</span><br><span class=\"line\">  remote_user: root</span><br><span class=\"line\">  vars:</span><br><span class=\"line\">    name1: robin</span><br><span class=\"line\">    hosts_group: &quot;localhost&quot;</span><br><span class=\"line\">    date1: 2020-02-02</span><br><span class=\"line\">    age1: 21</span><br><span class=\"line\">    age2: &apos;21&apos;</span><br><span class=\"line\">    married: True</span><br><span class=\"line\">    married2: true</span><br><span class=\"line\">    married3: &apos;true&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  tasks:</span><br><span class=\"line\">    - name: def age1 as int</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age1 is &#123;&#123; age1 &#125;&#125; as int&quot;</span><br><span class=\"line\">      when: age1 == 21</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age2 as string</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age2 is &#123;&#123; age2 &#125;&#125; as string&quot;</span><br><span class=\"line\">      when: age2 == &apos;21&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age1 as int to string</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age1 is &#123;&#123; age1 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|string == &apos;21&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: def age2 as string to int</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;age2 is &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age2|int == 21 and age2|int &gt;= 18</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: change to string and compare age1 and age2</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; age1&#125;&#125; &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|string + age2|string == &apos;2121&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: change to int and compare age1 and age2</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; age1&#125;&#125; &#123;&#123; age2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: age1|int - age2|int == 0</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married is &#123;&#123; married &#125;&#125;&quot;</span><br><span class=\"line\">      when: married|string == &apos;True&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married2 or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married2 is &#123;&#123; married2 &#125;&#125;&quot;</span><br><span class=\"line\">      when: married2|string == &apos;True&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    - name: show the married3 or not</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;married3 is &#123;&#123; married3 &#125;&#125;&quot;</span><br><span class=\"line\">      when: married3|string == &apos;true&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行该示例\"><a href=\"#运行该示例\" class=\"headerlink\" title=\"运行该示例\"></a>运行该示例</h2><p><code>ansible-playbook test-var.yml</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PLAY [localhost] ****************************************************************************************************************************************************************************************************************************</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [Gathering Facts] **********************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost]</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age1 as int] **********************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age1 is 21 as int&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age2 as string] *******************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age2 is 21 as string&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age1 as int to string] ************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age1 is 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [def age2 as string to int] ************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;age2 is 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [change to string and compare age1 and age2] *******************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;21 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [change to int and compare age1 and age2] **********************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;21 21&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married or not] **************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married is True&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married2 or not] *************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married2 is True&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TASK [show the married3 or not] *************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">ok: [localhost] =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;married3 is true&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PLAY RECAP **********************************************************************************************************************************************************************************************************************************</span><br><span class=\"line\">localhost                  : ok=7    changed=0    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>"},{"title":"ansible 快速学习视频(阿里云大学)","date":"2019-12-21T23:10:30.000Z","_content":"\n推荐一个很好的ansible学习视频教程，我自己学习了2遍了，强烈推荐。\n\n<!--more-->\n\nhttps://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&previewAs=guest","source":"_posts/ansible/ansible_video.md","raw":"---\ntitle: ansible 快速学习视频(阿里云大学)\ndate: 2019-12-21 23:10:30\ntags: \n  - ansible-learn\ncategories: ansible\n---\n\n推荐一个很好的ansible学习视频教程，我自己学习了2遍了，强烈推荐。\n\n<!--more-->\n\nhttps://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&previewAs=guest","slug":"ansible/ansible_video","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeqn001j0en7mimazjef","content":"<p>推荐一个很好的ansible学习视频教程，我自己学习了2遍了，强烈推荐。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&amp;previewAs=guest\" target=\"_blank\" rel=\"noopener\">https://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&amp;previewAs=guest</a></p>\n","site":{"data":{}},"excerpt":"<p>推荐一个很好的ansible学习视频教程，我自己学习了2遍了，强烈推荐。</p>","more":"<p><a href=\"https://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&amp;previewAs=guest\" target=\"_blank\" rel=\"noopener\">https://edu.aliyun.com/course/1714/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.2f7b4476J8E9Dr&amp;previewAs=guest</a></p>"},{"title":"自动化运维之自动化监控","date":"2020-02-27T22:39:22.000Z","_content":"\n昨天我们讲了自动化构建，今天我来讲讲我认为的自动化监控。每个项目正式上线后，是要给用户使用的，那如如何保证系统可以持续给用户提供服务? 我认为除过项目前期的合理架构设计、规范和科学的编码和高效准确的发布外，上线后的系统运行监控也很重要。\n\n<!--more-->\n\n对于传统的系统架构而言，系统运行监控可以分为操作系统监控、中间件监控、应用监控、数据库监控、网络监控等等。操作系统监控一般主要监控操作系统可用性、CPU使用率和负载、内存使用率、磁盘使用率等等指标。中间件监控主要监控可用性、JVM使用率、线程监控、JMS监控、JDBC监控等等。应用监控主要监控系统的可用性、响应时间、用户连接数等等。数据库监控主要监控数据库的可用性相关指标、表空间使用情况、性能相关指标等。网络监控则是为了保证IT整理网络的运行，监控网络延迟、可用性、通讯质量相关指标。其实啰嗦了这么多，换个角度来讲，一方面监控服务的可用性，另一方面监控服务的性能，保证系统能用、好用、安全。\n\n对于互联网架构的系统，这些监控的对象几乎被彻底颠覆了，不过万变不离其宗，监控的核心思想还是保证高可用、高性能、高安全。\n\n初级的互联网架构，已经可以实现操作系统的虚拟化，就是所谓的IAAS架构，我们根本不需要关心每个操作系统的一堆指标，而是站在服务可用性的视角，一旦发现哪个操作系统的可用性或者性能不符合要求，直接隔离，永不续用；其他层面的架构可能跟传统监控类似。\n\n中级的互联网架构，在实现了操作系统虚拟化的基础上，已经实现了中间件的虚拟化，就是所谓的Paas架构，开发人员只要写好代码并经过各种测试后，直接将代码自动部署到Paas平台即可，需要部署多少就部署多少，反正脚本帮我们去部署，我们不需要关注操作系统、中间件的各种指标，只要每个Paas提供的应用服务可用性和性能超过我们设置的基线，自动从负载均衡中隔离，我们只要关注对外服务的可用性和性能，还有IAAS和Pass平台本身的监控即可。\n\n对于高级的互联网架构，其实就是现在流行的Saas架构，公司不需要开发人员写代码、测试代码、发布代码，而是直接购买各种微服务，由于微服务本身的高可用性和高性能，我们什么都不要监控了。IT业务由各种微服务组成，就跟搭积木一样简单，只要关心业务本身，关心如何让用户的体验更好。虽然这种Saas服务，业界还有各种质疑，尤其安全性方面的风险。但是不得不说，私有的Saas架构也是一个比较折中的办法，互联网大厂应该早就在试水了。\n\n说了半天了，随着IT架构的演化，我们需要监控的东西越来越少。如果你是IT运维人员，恭喜你离失业不远了。时代要求我们IT运维人员具备开发能力或者业务能力，只要这样我们才不会失业！\n\n今天的废话结束了，退朝！","source":"_posts/dev-ops/dev-ops-monitor.md","raw":"---\ntitle: 自动化运维之自动化监控\ndate: 2020-02-27 22:39:22\ntags: monitor\ncategories: dev-ops\n---\n\n昨天我们讲了自动化构建，今天我来讲讲我认为的自动化监控。每个项目正式上线后，是要给用户使用的，那如如何保证系统可以持续给用户提供服务? 我认为除过项目前期的合理架构设计、规范和科学的编码和高效准确的发布外，上线后的系统运行监控也很重要。\n\n<!--more-->\n\n对于传统的系统架构而言，系统运行监控可以分为操作系统监控、中间件监控、应用监控、数据库监控、网络监控等等。操作系统监控一般主要监控操作系统可用性、CPU使用率和负载、内存使用率、磁盘使用率等等指标。中间件监控主要监控可用性、JVM使用率、线程监控、JMS监控、JDBC监控等等。应用监控主要监控系统的可用性、响应时间、用户连接数等等。数据库监控主要监控数据库的可用性相关指标、表空间使用情况、性能相关指标等。网络监控则是为了保证IT整理网络的运行，监控网络延迟、可用性、通讯质量相关指标。其实啰嗦了这么多，换个角度来讲，一方面监控服务的可用性，另一方面监控服务的性能，保证系统能用、好用、安全。\n\n对于互联网架构的系统，这些监控的对象几乎被彻底颠覆了，不过万变不离其宗，监控的核心思想还是保证高可用、高性能、高安全。\n\n初级的互联网架构，已经可以实现操作系统的虚拟化，就是所谓的IAAS架构，我们根本不需要关心每个操作系统的一堆指标，而是站在服务可用性的视角，一旦发现哪个操作系统的可用性或者性能不符合要求，直接隔离，永不续用；其他层面的架构可能跟传统监控类似。\n\n中级的互联网架构，在实现了操作系统虚拟化的基础上，已经实现了中间件的虚拟化，就是所谓的Paas架构，开发人员只要写好代码并经过各种测试后，直接将代码自动部署到Paas平台即可，需要部署多少就部署多少，反正脚本帮我们去部署，我们不需要关注操作系统、中间件的各种指标，只要每个Paas提供的应用服务可用性和性能超过我们设置的基线，自动从负载均衡中隔离，我们只要关注对外服务的可用性和性能，还有IAAS和Pass平台本身的监控即可。\n\n对于高级的互联网架构，其实就是现在流行的Saas架构，公司不需要开发人员写代码、测试代码、发布代码，而是直接购买各种微服务，由于微服务本身的高可用性和高性能，我们什么都不要监控了。IT业务由各种微服务组成，就跟搭积木一样简单，只要关心业务本身，关心如何让用户的体验更好。虽然这种Saas服务，业界还有各种质疑，尤其安全性方面的风险。但是不得不说，私有的Saas架构也是一个比较折中的办法，互联网大厂应该早就在试水了。\n\n说了半天了，随着IT架构的演化，我们需要监控的东西越来越少。如果你是IT运维人员，恭喜你离失业不远了。时代要求我们IT运维人员具备开发能力或者业务能力，只要这样我们才不会失业！\n\n今天的废话结束了，退朝！","slug":"dev-ops/dev-ops-monitor","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeqp001m0en7sqlnkazo","content":"<p>昨天我们讲了自动化构建，今天我来讲讲我认为的自动化监控。每个项目正式上线后，是要给用户使用的，那如如何保证系统可以持续给用户提供服务? 我认为除过项目前期的合理架构设计、规范和科学的编码和高效准确的发布外，上线后的系统运行监控也很重要。</p>\n<a id=\"more\"></a>\n<p>对于传统的系统架构而言，系统运行监控可以分为操作系统监控、中间件监控、应用监控、数据库监控、网络监控等等。操作系统监控一般主要监控操作系统可用性、CPU使用率和负载、内存使用率、磁盘使用率等等指标。中间件监控主要监控可用性、JVM使用率、线程监控、JMS监控、JDBC监控等等。应用监控主要监控系统的可用性、响应时间、用户连接数等等。数据库监控主要监控数据库的可用性相关指标、表空间使用情况、性能相关指标等。网络监控则是为了保证IT整理网络的运行，监控网络延迟、可用性、通讯质量相关指标。其实啰嗦了这么多，换个角度来讲，一方面监控服务的可用性，另一方面监控服务的性能，保证系统能用、好用、安全。</p>\n<p>对于互联网架构的系统，这些监控的对象几乎被彻底颠覆了，不过万变不离其宗，监控的核心思想还是保证高可用、高性能、高安全。</p>\n<p>初级的互联网架构，已经可以实现操作系统的虚拟化，就是所谓的IAAS架构，我们根本不需要关心每个操作系统的一堆指标，而是站在服务可用性的视角，一旦发现哪个操作系统的可用性或者性能不符合要求，直接隔离，永不续用；其他层面的架构可能跟传统监控类似。</p>\n<p>中级的互联网架构，在实现了操作系统虚拟化的基础上，已经实现了中间件的虚拟化，就是所谓的Paas架构，开发人员只要写好代码并经过各种测试后，直接将代码自动部署到Paas平台即可，需要部署多少就部署多少，反正脚本帮我们去部署，我们不需要关注操作系统、中间件的各种指标，只要每个Paas提供的应用服务可用性和性能超过我们设置的基线，自动从负载均衡中隔离，我们只要关注对外服务的可用性和性能，还有IAAS和Pass平台本身的监控即可。</p>\n<p>对于高级的互联网架构，其实就是现在流行的Saas架构，公司不需要开发人员写代码、测试代码、发布代码，而是直接购买各种微服务，由于微服务本身的高可用性和高性能，我们什么都不要监控了。IT业务由各种微服务组成，就跟搭积木一样简单，只要关心业务本身，关心如何让用户的体验更好。虽然这种Saas服务，业界还有各种质疑，尤其安全性方面的风险。但是不得不说，私有的Saas架构也是一个比较折中的办法，互联网大厂应该早就在试水了。</p>\n<p>说了半天了，随着IT架构的演化，我们需要监控的东西越来越少。如果你是IT运维人员，恭喜你离失业不远了。时代要求我们IT运维人员具备开发能力或者业务能力，只要这样我们才不会失业！</p>\n<p>今天的废话结束了，退朝！</p>\n","site":{"data":{}},"excerpt":"<p>昨天我们讲了自动化构建，今天我来讲讲我认为的自动化监控。每个项目正式上线后，是要给用户使用的，那如如何保证系统可以持续给用户提供服务? 我认为除过项目前期的合理架构设计、规范和科学的编码和高效准确的发布外，上线后的系统运行监控也很重要。</p>","more":"<p>对于传统的系统架构而言，系统运行监控可以分为操作系统监控、中间件监控、应用监控、数据库监控、网络监控等等。操作系统监控一般主要监控操作系统可用性、CPU使用率和负载、内存使用率、磁盘使用率等等指标。中间件监控主要监控可用性、JVM使用率、线程监控、JMS监控、JDBC监控等等。应用监控主要监控系统的可用性、响应时间、用户连接数等等。数据库监控主要监控数据库的可用性相关指标、表空间使用情况、性能相关指标等。网络监控则是为了保证IT整理网络的运行，监控网络延迟、可用性、通讯质量相关指标。其实啰嗦了这么多，换个角度来讲，一方面监控服务的可用性，另一方面监控服务的性能，保证系统能用、好用、安全。</p>\n<p>对于互联网架构的系统，这些监控的对象几乎被彻底颠覆了，不过万变不离其宗，监控的核心思想还是保证高可用、高性能、高安全。</p>\n<p>初级的互联网架构，已经可以实现操作系统的虚拟化，就是所谓的IAAS架构，我们根本不需要关心每个操作系统的一堆指标，而是站在服务可用性的视角，一旦发现哪个操作系统的可用性或者性能不符合要求，直接隔离，永不续用；其他层面的架构可能跟传统监控类似。</p>\n<p>中级的互联网架构，在实现了操作系统虚拟化的基础上，已经实现了中间件的虚拟化，就是所谓的Paas架构，开发人员只要写好代码并经过各种测试后，直接将代码自动部署到Paas平台即可，需要部署多少就部署多少，反正脚本帮我们去部署，我们不需要关注操作系统、中间件的各种指标，只要每个Paas提供的应用服务可用性和性能超过我们设置的基线，自动从负载均衡中隔离，我们只要关注对外服务的可用性和性能，还有IAAS和Pass平台本身的监控即可。</p>\n<p>对于高级的互联网架构，其实就是现在流行的Saas架构，公司不需要开发人员写代码、测试代码、发布代码，而是直接购买各种微服务，由于微服务本身的高可用性和高性能，我们什么都不要监控了。IT业务由各种微服务组成，就跟搭积木一样简单，只要关心业务本身，关心如何让用户的体验更好。虽然这种Saas服务，业界还有各种质疑，尤其安全性方面的风险。但是不得不说，私有的Saas架构也是一个比较折中的办法，互联网大厂应该早就在试水了。</p>\n<p>说了半天了，随着IT架构的演化，我们需要监控的东西越来越少。如果你是IT运维人员，恭喜你离失业不远了。时代要求我们IT运维人员具备开发能力或者业务能力，只要这样我们才不会失业！</p>\n<p>今天的废话结束了，退朝！</p>"},{"title":"自动化运维之自动化构建","date":"2020-02-26T21:21:21.000Z","_content":"\n说到自动化运维，我们不得不先讲讲自动化构建。在项目前期，我们每周甚至每天都要把代码包提交到开发和测试环境，然后触发人工或者自动化测试程序，如果发现了问题再等开发修复后滚动发布。在项目中期，我们可能每周或每月需要将经过测试的代码包发布到生产环境，然后进行功能验证，直接交给用户使用。在自动化构建没有流行的时候，我们这些发布新代码包的工作，都需要人工完成，不仅效率低还很容易出错。\n\n<!--more-->\n\n然而这几年随着dev ops/ai ops等概念的流行，每个公司都在实践或者准备实践dev ops，自动化构建就属于dev ops的重要部分。笔者认为这几年自动化构建有多种技术实现方式，对于中小型项目，服务器几百台而言，github+maven+jenkins+ansible/ansible tower足够完成自动化构建的任务。简单地说，我们可以实现一键发布，只要收一收邮件或者看看发布日志就结束了，边喝茶边等结果，悠哉游哉。​接下来我先分别大概介绍下这些自动化构需要的技术或者工具。\n\ngithub想必凡是IT行业从业人员听过或者使用过，甚至开发人员在重度使用，他也是大家俗称的全球最大的同性交友网站，哈哈哈！引用下百度百科对github的介绍。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。\n\nmaven估计只有开发人员听过，他主要完成java项目的项目构建管理、项目依赖管理、软件项目持续集成、版本管理等等。​比较正规的开发项目经常会用到该工具，对于运维人员，尤其是准备或者已经在做dev ops的同学来说，最好也熟悉下。\n\nJenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。jenkins算是持续集成的核心平台了。\n\nansible是一个开源的项目，目前在github很流行，由于他只要被管理机器是安装了python的Linux系统就可以，目前主流的Linux都自带了python，例如Redhat6-7，CentOS6-7等等，所以无需在被管机器安装任何Agent就可以直接ansible对被管理机器进行操作。常见的发布任务都支持，代码包分发下载，配置修改，服务重启，甚至DB的sql操作都可以完成，凡是发布任务几乎无所不能。ansible 是基于python实现的，虽然效率不如c/c++高，但是使用起来真的很方便。\n\nansible tower是一个商业项目，目前已经被Redhat收购，是被封装过的ansible平台，以安全、规范著称，有钱的公司都在花钱使用他，如果IT比较穷可以先不用。\n\n今天就先讲到这里，后续再细讲自动化构建的具体内容。​谢谢！","source":"_posts/dev-ops/dev-ops-ci.md","raw":"---\ntitle: 自动化运维之自动化构建\ndate: 2020-02-26 21:21:21\ntags: ci\ncategories: dev-ops\n---\n\n说到自动化运维，我们不得不先讲讲自动化构建。在项目前期，我们每周甚至每天都要把代码包提交到开发和测试环境，然后触发人工或者自动化测试程序，如果发现了问题再等开发修复后滚动发布。在项目中期，我们可能每周或每月需要将经过测试的代码包发布到生产环境，然后进行功能验证，直接交给用户使用。在自动化构建没有流行的时候，我们这些发布新代码包的工作，都需要人工完成，不仅效率低还很容易出错。\n\n<!--more-->\n\n然而这几年随着dev ops/ai ops等概念的流行，每个公司都在实践或者准备实践dev ops，自动化构建就属于dev ops的重要部分。笔者认为这几年自动化构建有多种技术实现方式，对于中小型项目，服务器几百台而言，github+maven+jenkins+ansible/ansible tower足够完成自动化构建的任务。简单地说，我们可以实现一键发布，只要收一收邮件或者看看发布日志就结束了，边喝茶边等结果，悠哉游哉。​接下来我先分别大概介绍下这些自动化构需要的技术或者工具。\n\ngithub想必凡是IT行业从业人员听过或者使用过，甚至开发人员在重度使用，他也是大家俗称的全球最大的同性交友网站，哈哈哈！引用下百度百科对github的介绍。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。\n\nmaven估计只有开发人员听过，他主要完成java项目的项目构建管理、项目依赖管理、软件项目持续集成、版本管理等等。​比较正规的开发项目经常会用到该工具，对于运维人员，尤其是准备或者已经在做dev ops的同学来说，最好也熟悉下。\n\nJenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。jenkins算是持续集成的核心平台了。\n\nansible是一个开源的项目，目前在github很流行，由于他只要被管理机器是安装了python的Linux系统就可以，目前主流的Linux都自带了python，例如Redhat6-7，CentOS6-7等等，所以无需在被管机器安装任何Agent就可以直接ansible对被管理机器进行操作。常见的发布任务都支持，代码包分发下载，配置修改，服务重启，甚至DB的sql操作都可以完成，凡是发布任务几乎无所不能。ansible 是基于python实现的，虽然效率不如c/c++高，但是使用起来真的很方便。\n\nansible tower是一个商业项目，目前已经被Redhat收购，是被封装过的ansible平台，以安全、规范著称，有钱的公司都在花钱使用他，如果IT比较穷可以先不用。\n\n今天就先讲到这里，后续再细讲自动化构建的具体内容。​谢谢！","slug":"dev-ops/dev-ops-ci","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeqw001q0en7deme85c9","content":"<p>说到自动化运维，我们不得不先讲讲自动化构建。在项目前期，我们每周甚至每天都要把代码包提交到开发和测试环境，然后触发人工或者自动化测试程序，如果发现了问题再等开发修复后滚动发布。在项目中期，我们可能每周或每月需要将经过测试的代码包发布到生产环境，然后进行功能验证，直接交给用户使用。在自动化构建没有流行的时候，我们这些发布新代码包的工作，都需要人工完成，不仅效率低还很容易出错。</p>\n<a id=\"more\"></a>\n<p>然而这几年随着dev ops/ai ops等概念的流行，每个公司都在实践或者准备实践dev ops，自动化构建就属于dev ops的重要部分。笔者认为这几年自动化构建有多种技术实现方式，对于中小型项目，服务器几百台而言，github+maven+jenkins+ansible/ansible tower足够完成自动化构建的任务。简单地说，我们可以实现一键发布，只要收一收邮件或者看看发布日志就结束了，边喝茶边等结果，悠哉游哉。​接下来我先分别大概介绍下这些自动化构需要的技术或者工具。</p>\n<p>github想必凡是IT行业从业人员听过或者使用过，甚至开发人员在重度使用，他也是大家俗称的全球最大的同性交友网站，哈哈哈！引用下百度百科对github的介绍。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p>\n<p>maven估计只有开发人员听过，他主要完成java项目的项目构建管理、项目依赖管理、软件项目持续集成、版本管理等等。​比较正规的开发项目经常会用到该工具，对于运维人员，尤其是准备或者已经在做dev ops的同学来说，最好也熟悉下。</p>\n<p>Jenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。jenkins算是持续集成的核心平台了。</p>\n<p>ansible是一个开源的项目，目前在github很流行，由于他只要被管理机器是安装了python的Linux系统就可以，目前主流的Linux都自带了python，例如Redhat6-7，CentOS6-7等等，所以无需在被管机器安装任何Agent就可以直接ansible对被管理机器进行操作。常见的发布任务都支持，代码包分发下载，配置修改，服务重启，甚至DB的sql操作都可以完成，凡是发布任务几乎无所不能。ansible 是基于python实现的，虽然效率不如c/c++高，但是使用起来真的很方便。</p>\n<p>ansible tower是一个商业项目，目前已经被Redhat收购，是被封装过的ansible平台，以安全、规范著称，有钱的公司都在花钱使用他，如果IT比较穷可以先不用。</p>\n<p>今天就先讲到这里，后续再细讲自动化构建的具体内容。​谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>说到自动化运维，我们不得不先讲讲自动化构建。在项目前期，我们每周甚至每天都要把代码包提交到开发和测试环境，然后触发人工或者自动化测试程序，如果发现了问题再等开发修复后滚动发布。在项目中期，我们可能每周或每月需要将经过测试的代码包发布到生产环境，然后进行功能验证，直接交给用户使用。在自动化构建没有流行的时候，我们这些发布新代码包的工作，都需要人工完成，不仅效率低还很容易出错。</p>","more":"<p>然而这几年随着dev ops/ai ops等概念的流行，每个公司都在实践或者准备实践dev ops，自动化构建就属于dev ops的重要部分。笔者认为这几年自动化构建有多种技术实现方式，对于中小型项目，服务器几百台而言，github+maven+jenkins+ansible/ansible tower足够完成自动化构建的任务。简单地说，我们可以实现一键发布，只要收一收邮件或者看看发布日志就结束了，边喝茶边等结果，悠哉游哉。​接下来我先分别大概介绍下这些自动化构需要的技术或者工具。</p>\n<p>github想必凡是IT行业从业人员听过或者使用过，甚至开发人员在重度使用，他也是大家俗称的全球最大的同性交友网站，哈哈哈！引用下百度百科对github的介绍。作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。</p>\n<p>maven估计只有开发人员听过，他主要完成java项目的项目构建管理、项目依赖管理、软件项目持续集成、版本管理等等。​比较正规的开发项目经常会用到该工具，对于运维人员，尤其是准备或者已经在做dev ops的同学来说，最好也熟悉下。</p>\n<p>Jenkins是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。jenkins算是持续集成的核心平台了。</p>\n<p>ansible是一个开源的项目，目前在github很流行，由于他只要被管理机器是安装了python的Linux系统就可以，目前主流的Linux都自带了python，例如Redhat6-7，CentOS6-7等等，所以无需在被管机器安装任何Agent就可以直接ansible对被管理机器进行操作。常见的发布任务都支持，代码包分发下载，配置修改，服务重启，甚至DB的sql操作都可以完成，凡是发布任务几乎无所不能。ansible 是基于python实现的，虽然效率不如c/c++高，但是使用起来真的很方便。</p>\n<p>ansible tower是一个商业项目，目前已经被Redhat收购，是被封装过的ansible平台，以安全、规范著称，有钱的公司都在花钱使用他，如果IT比较穷可以先不用。</p>\n<p>今天就先讲到这里，后续再细讲自动化构建的具体内容。​谢谢！</p>"},{"title":"自动化运维之名词解释","date":"2020-02-29T23:23:21.000Z","_content":"\n此文章来自于互联网收集，持续更新中.....\n\n<!--more-->\n\n### 基础类：\n\n**shell**在计算机科学中，俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。一般在运维领域我们一般把linux shell简称shell。对于我们正常运维人员来说，shell是离操作系统最近的工具，虽然语法有点复杂、但是效率高。\n\npython是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。之所以把它跟运维扯上关系，是因为对运维人员来说，python太重要了。\n\n\n### 持续集成​类：\n\n**ansible**是一种新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。\n\n**jenkins**是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。jenkins跟ansible配合，简直是​天作之合。\n\n\n### 容器类：\n\n**docker**是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。\n\n**kubernetes**简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用。​\n\n","source":"_posts/dev-ops/dev-ops-names.md","raw":"---\ntitle: 自动化运维之名词解释\ndate: 2020-02-29 23:23:21\ntags: tools\ncategories: dev-ops\n---\n\n此文章来自于互联网收集，持续更新中.....\n\n<!--more-->\n\n### 基础类：\n\n**shell**在计算机科学中，俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。一般在运维领域我们一般把linux shell简称shell。对于我们正常运维人员来说，shell是离操作系统最近的工具，虽然语法有点复杂、但是效率高。\n\npython是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。之所以把它跟运维扯上关系，是因为对运维人员来说，python太重要了。\n\n\n### 持续集成​类：\n\n**ansible**是一种新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。\n\n**jenkins**是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。jenkins跟ansible配合，简直是​天作之合。\n\n\n### 容器类：\n\n**docker**是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。\n\n**kubernetes**简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用。​\n\n","slug":"dev-ops/dev-ops-names","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxder6001u0en7zqs9uy4o","content":"<p>此文章来自于互联网收集，持续更新中…..</p>\n<a id=\"more\"></a>\n<h3 id=\"基础类：\"><a href=\"#基础类：\" class=\"headerlink\" title=\"基础类：\"></a>基础类：</h3><p><strong>shell</strong>在计算机科学中，俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。一般在运维领域我们一般把linux shell简称shell。对于我们正常运维人员来说，shell是离操作系统最近的工具，虽然语法有点复杂、但是效率高。</p>\n<p>python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。之所以把它跟运维扯上关系，是因为对运维人员来说，python太重要了。</p>\n<h3 id=\"持续集成​类：\"><a href=\"#持续集成​类：\" class=\"headerlink\" title=\"持续集成​类：\"></a>持续集成​类：</h3><p><strong>ansible</strong>是一种新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p>\n<p><strong>jenkins</strong>是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。jenkins跟ansible配合，简直是​天作之合。</p>\n<h3 id=\"容器类：\"><a href=\"#容器类：\" class=\"headerlink\" title=\"容器类：\"></a>容器类：</h3><p><strong>docker</strong>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。</p>\n<p><strong>kubernetes</strong>简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用。​</p>\n","site":{"data":{}},"excerpt":"<p>此文章来自于互联网收集，持续更新中…..</p>","more":"<h3 id=\"基础类：\"><a href=\"#基础类：\" class=\"headerlink\" title=\"基础类：\"></a>基础类：</h3><p><strong>shell</strong>在计算机科学中，俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。一般在运维领域我们一般把linux shell简称shell。对于我们正常运维人员来说，shell是离操作系统最近的工具，虽然语法有点复杂、但是效率高。</p>\n<p>python是一种跨平台的计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。之所以把它跟运维扯上关系，是因为对运维人员来说，python太重要了。</p>\n<h3 id=\"持续集成​类：\"><a href=\"#持续集成​类：\" class=\"headerlink\" title=\"持续集成​类：\"></a>持续集成​类：</h3><p><strong>ansible</strong>是一种新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。</p>\n<p><strong>jenkins</strong>是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。jenkins跟ansible配合，简直是​天作之合。</p>\n<h3 id=\"容器类：\"><a href=\"#容器类：\" class=\"headerlink\" title=\"容器类：\"></a>容器类：</h3><p><strong>docker</strong>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。</p>\n<p><strong>kubernetes</strong>简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用。​</p>"},{"title":"自动化运维之大公司病","date":"2020-02-28T22:22:22.000Z","_content":"\n这几年越来越多的企业在国家号召和行业巨头的影响之下，开始有了自动化运维的概念，但是到底怎么做才算自动化运维，每家公司的理解都不太一样。\n<!--more-->\n\n**在我看来，要建立什么要的运维平台，其实标准答案不确定，要看公司的IT规模和技术水平。**比如公司有几十台、几百台还是成千上万台机器；比如使用传统的linux服务器直接跑中间件，还是已经使用了容器技术，通过docker加载轻量级的中间件；比如公司的业务性质，是传统的制造型企业、营销型企业、银行等金融行业亦或者是互联网服务公司；还要看IT部分有多少预算和人力、财务和物力。 这个问题其实很复杂，需要考虑好多问题。今天我就以A企业为例，讲讲我们遇到的大公司病。\n\n**先从资源管理方面讲讲。**A企业的规模很大，全国几十家企业，每家企业各种分公司和子公司，IT的规模可能是海量的。IT基础设施层面可能有各种各样的服务器，刀片服务器、小型机、大型机；各种各样的存储、网络、安全设备；各种各样的操作系统，windows、Linux、AIX等。于是可能好多人想到的是，先要建立一个强大的CMDB系统，手工录入各种繁杂的子资源，然后系统就生成的各种各样的报表和分析数据，感觉高、大、上，但是然后这好像只会让财务部门很开心，但是IT部门就会发现，难道我们就是板砖、整理数据出报表的命了。随着A企业推动信息化的进程加速，于是又产生了好多的信息系统，A生产管理系统、A建设系统、A工程管理系统、人力资源系统、财务系统、资产管理系统甚至也产生了信息管理系统。这些业务系统对IT基础设施的要求都不太一样，结果IT部门就更累了，因为资产越来越丰富了，硬件、软件越来越繁杂了，CMDB系统原有的设计已经不能满足要求了，于是就不断地加入各种模型和结构。再后来，互联网大厂提出了人工智能、大数据、云计算、物联网等概念，这些很快上升到了国家战略层面。作为国企的排头兵，A企业就积极响应国家号召，建立了各种各样的云计算平台、虚拟资源池，结果CMDB原有的模型简直被颠覆了，又只能再改造资源模型去适应了。 IT部分的大部分精力都花在了资源管理方面，别的事情精力就少多了，那就只能加班弥补了。\n\n**再从资源监控方面讲讲。**由于我们已经有了强大的CMDB系统，再要做资源监控就是顺理成章的事情了。站在管理者的角度当然是有什么监控什么，监控指标越多越好咯。于是我们建立了丰富的运维监控指标体系，覆盖各种资源，监控指标包罗万象。然后监控系统运行起来以后，我们就整天关注着海量的监控对象和指标，一有个什么风吹草动，IT部门都心惊胆战的，生怕被考核了。后来就有人提出了自动化监控，由于IT的复杂度和技术的有限，结果自动化水平一直没有质的飞跃。\n\n**再从运维流程方面讲讲。**IT运维当然需要有流程了，结果就诞生了好多IT运维流程，设备入库流程、设备领取流程、设备上线流程、设备报废流程等，系统上线运行流程、系统变更流程、系统下线流程等。这些所有流程，都需要从CMDB系统选取资源，这样就倒逼着CMDB系统数据的准确性。关键是CMDB系统数据已经不准确了！后来还有人提出了，运维流程流程还要跟资产变更的流程关联起来，跟资源监控也联动起来。IT运维系统的耦合性越来越高！\n\n**其实我们考虑好多问题，其实初衷都是对的，但是后来发现好多都走歪了。**再后来就有了各种变革，各种适应性的改造，我们越来越痛苦！在后来发现，问题原来是出在了管理上，我们赋予了IT部门太多的历史使命，但是内部的管理水平和制度没跟的上IT的建设步伐！我们什么都想做，但是什么都没有做好，我们什么问题都想解决，但是什么问题都没彻底解决。凡事都有个过程，稳扎稳打每一步都走好了，才能越来越好，越来越轻松。\n\n感谢您能看完我的一堆唠叨，如果有不同的见解可以给我留言。谢谢！\n","source":"_posts/dev-ops/dev-ops-question.md","raw":"---\ntitle: 自动化运维之大公司病\ndate: 2020-02-28 22:22:22\ntags: other\ncategories: dev-ops\n---\n\n这几年越来越多的企业在国家号召和行业巨头的影响之下，开始有了自动化运维的概念，但是到底怎么做才算自动化运维，每家公司的理解都不太一样。\n<!--more-->\n\n**在我看来，要建立什么要的运维平台，其实标准答案不确定，要看公司的IT规模和技术水平。**比如公司有几十台、几百台还是成千上万台机器；比如使用传统的linux服务器直接跑中间件，还是已经使用了容器技术，通过docker加载轻量级的中间件；比如公司的业务性质，是传统的制造型企业、营销型企业、银行等金融行业亦或者是互联网服务公司；还要看IT部分有多少预算和人力、财务和物力。 这个问题其实很复杂，需要考虑好多问题。今天我就以A企业为例，讲讲我们遇到的大公司病。\n\n**先从资源管理方面讲讲。**A企业的规模很大，全国几十家企业，每家企业各种分公司和子公司，IT的规模可能是海量的。IT基础设施层面可能有各种各样的服务器，刀片服务器、小型机、大型机；各种各样的存储、网络、安全设备；各种各样的操作系统，windows、Linux、AIX等。于是可能好多人想到的是，先要建立一个强大的CMDB系统，手工录入各种繁杂的子资源，然后系统就生成的各种各样的报表和分析数据，感觉高、大、上，但是然后这好像只会让财务部门很开心，但是IT部门就会发现，难道我们就是板砖、整理数据出报表的命了。随着A企业推动信息化的进程加速，于是又产生了好多的信息系统，A生产管理系统、A建设系统、A工程管理系统、人力资源系统、财务系统、资产管理系统甚至也产生了信息管理系统。这些业务系统对IT基础设施的要求都不太一样，结果IT部门就更累了，因为资产越来越丰富了，硬件、软件越来越繁杂了，CMDB系统原有的设计已经不能满足要求了，于是就不断地加入各种模型和结构。再后来，互联网大厂提出了人工智能、大数据、云计算、物联网等概念，这些很快上升到了国家战略层面。作为国企的排头兵，A企业就积极响应国家号召，建立了各种各样的云计算平台、虚拟资源池，结果CMDB原有的模型简直被颠覆了，又只能再改造资源模型去适应了。 IT部分的大部分精力都花在了资源管理方面，别的事情精力就少多了，那就只能加班弥补了。\n\n**再从资源监控方面讲讲。**由于我们已经有了强大的CMDB系统，再要做资源监控就是顺理成章的事情了。站在管理者的角度当然是有什么监控什么，监控指标越多越好咯。于是我们建立了丰富的运维监控指标体系，覆盖各种资源，监控指标包罗万象。然后监控系统运行起来以后，我们就整天关注着海量的监控对象和指标，一有个什么风吹草动，IT部门都心惊胆战的，生怕被考核了。后来就有人提出了自动化监控，由于IT的复杂度和技术的有限，结果自动化水平一直没有质的飞跃。\n\n**再从运维流程方面讲讲。**IT运维当然需要有流程了，结果就诞生了好多IT运维流程，设备入库流程、设备领取流程、设备上线流程、设备报废流程等，系统上线运行流程、系统变更流程、系统下线流程等。这些所有流程，都需要从CMDB系统选取资源，这样就倒逼着CMDB系统数据的准确性。关键是CMDB系统数据已经不准确了！后来还有人提出了，运维流程流程还要跟资产变更的流程关联起来，跟资源监控也联动起来。IT运维系统的耦合性越来越高！\n\n**其实我们考虑好多问题，其实初衷都是对的，但是后来发现好多都走歪了。**再后来就有了各种变革，各种适应性的改造，我们越来越痛苦！在后来发现，问题原来是出在了管理上，我们赋予了IT部门太多的历史使命，但是内部的管理水平和制度没跟的上IT的建设步伐！我们什么都想做，但是什么都没有做好，我们什么问题都想解决，但是什么问题都没彻底解决。凡事都有个过程，稳扎稳打每一步都走好了，才能越来越好，越来越轻松。\n\n感谢您能看完我的一堆唠叨，如果有不同的见解可以给我留言。谢谢！\n","slug":"dev-ops/dev-ops-question","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxder9001y0en73hojweiz","content":"<p>这几年越来越多的企业在国家号召和行业巨头的影响之下，开始有了自动化运维的概念，但是到底怎么做才算自动化运维，每家公司的理解都不太一样。<br><a id=\"more\"></a></p>\n<p><strong>在我看来，要建立什么要的运维平台，其实标准答案不确定，要看公司的IT规模和技术水平。</strong>比如公司有几十台、几百台还是成千上万台机器；比如使用传统的linux服务器直接跑中间件，还是已经使用了容器技术，通过docker加载轻量级的中间件；比如公司的业务性质，是传统的制造型企业、营销型企业、银行等金融行业亦或者是互联网服务公司；还要看IT部分有多少预算和人力、财务和物力。 这个问题其实很复杂，需要考虑好多问题。今天我就以A企业为例，讲讲我们遇到的大公司病。</p>\n<p><strong>先从资源管理方面讲讲。</strong>A企业的规模很大，全国几十家企业，每家企业各种分公司和子公司，IT的规模可能是海量的。IT基础设施层面可能有各种各样的服务器，刀片服务器、小型机、大型机；各种各样的存储、网络、安全设备；各种各样的操作系统，windows、Linux、AIX等。于是可能好多人想到的是，先要建立一个强大的CMDB系统，手工录入各种繁杂的子资源，然后系统就生成的各种各样的报表和分析数据，感觉高、大、上，但是然后这好像只会让财务部门很开心，但是IT部门就会发现，难道我们就是板砖、整理数据出报表的命了。随着A企业推动信息化的进程加速，于是又产生了好多的信息系统，A生产管理系统、A建设系统、A工程管理系统、人力资源系统、财务系统、资产管理系统甚至也产生了信息管理系统。这些业务系统对IT基础设施的要求都不太一样，结果IT部门就更累了，因为资产越来越丰富了，硬件、软件越来越繁杂了，CMDB系统原有的设计已经不能满足要求了，于是就不断地加入各种模型和结构。再后来，互联网大厂提出了人工智能、大数据、云计算、物联网等概念，这些很快上升到了国家战略层面。作为国企的排头兵，A企业就积极响应国家号召，建立了各种各样的云计算平台、虚拟资源池，结果CMDB原有的模型简直被颠覆了，又只能再改造资源模型去适应了。 IT部分的大部分精力都花在了资源管理方面，别的事情精力就少多了，那就只能加班弥补了。</p>\n<p><strong>再从资源监控方面讲讲。</strong>由于我们已经有了强大的CMDB系统，再要做资源监控就是顺理成章的事情了。站在管理者的角度当然是有什么监控什么，监控指标越多越好咯。于是我们建立了丰富的运维监控指标体系，覆盖各种资源，监控指标包罗万象。然后监控系统运行起来以后，我们就整天关注着海量的监控对象和指标，一有个什么风吹草动，IT部门都心惊胆战的，生怕被考核了。后来就有人提出了自动化监控，由于IT的复杂度和技术的有限，结果自动化水平一直没有质的飞跃。</p>\n<p><strong>再从运维流程方面讲讲。</strong>IT运维当然需要有流程了，结果就诞生了好多IT运维流程，设备入库流程、设备领取流程、设备上线流程、设备报废流程等，系统上线运行流程、系统变更流程、系统下线流程等。这些所有流程，都需要从CMDB系统选取资源，这样就倒逼着CMDB系统数据的准确性。关键是CMDB系统数据已经不准确了！后来还有人提出了，运维流程流程还要跟资产变更的流程关联起来，跟资源监控也联动起来。IT运维系统的耦合性越来越高！</p>\n<p><strong>其实我们考虑好多问题，其实初衷都是对的，但是后来发现好多都走歪了。</strong>再后来就有了各种变革，各种适应性的改造，我们越来越痛苦！在后来发现，问题原来是出在了管理上，我们赋予了IT部门太多的历史使命，但是内部的管理水平和制度没跟的上IT的建设步伐！我们什么都想做，但是什么都没有做好，我们什么问题都想解决，但是什么问题都没彻底解决。凡事都有个过程，稳扎稳打每一步都走好了，才能越来越好，越来越轻松。</p>\n<p>感谢您能看完我的一堆唠叨，如果有不同的见解可以给我留言。谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>这几年越来越多的企业在国家号召和行业巨头的影响之下，开始有了自动化运维的概念，但是到底怎么做才算自动化运维，每家公司的理解都不太一样。<br>","more":"</p>\n<p><strong>在我看来，要建立什么要的运维平台，其实标准答案不确定，要看公司的IT规模和技术水平。</strong>比如公司有几十台、几百台还是成千上万台机器；比如使用传统的linux服务器直接跑中间件，还是已经使用了容器技术，通过docker加载轻量级的中间件；比如公司的业务性质，是传统的制造型企业、营销型企业、银行等金融行业亦或者是互联网服务公司；还要看IT部分有多少预算和人力、财务和物力。 这个问题其实很复杂，需要考虑好多问题。今天我就以A企业为例，讲讲我们遇到的大公司病。</p>\n<p><strong>先从资源管理方面讲讲。</strong>A企业的规模很大，全国几十家企业，每家企业各种分公司和子公司，IT的规模可能是海量的。IT基础设施层面可能有各种各样的服务器，刀片服务器、小型机、大型机；各种各样的存储、网络、安全设备；各种各样的操作系统，windows、Linux、AIX等。于是可能好多人想到的是，先要建立一个强大的CMDB系统，手工录入各种繁杂的子资源，然后系统就生成的各种各样的报表和分析数据，感觉高、大、上，但是然后这好像只会让财务部门很开心，但是IT部门就会发现，难道我们就是板砖、整理数据出报表的命了。随着A企业推动信息化的进程加速，于是又产生了好多的信息系统，A生产管理系统、A建设系统、A工程管理系统、人力资源系统、财务系统、资产管理系统甚至也产生了信息管理系统。这些业务系统对IT基础设施的要求都不太一样，结果IT部门就更累了，因为资产越来越丰富了，硬件、软件越来越繁杂了，CMDB系统原有的设计已经不能满足要求了，于是就不断地加入各种模型和结构。再后来，互联网大厂提出了人工智能、大数据、云计算、物联网等概念，这些很快上升到了国家战略层面。作为国企的排头兵，A企业就积极响应国家号召，建立了各种各样的云计算平台、虚拟资源池，结果CMDB原有的模型简直被颠覆了，又只能再改造资源模型去适应了。 IT部分的大部分精力都花在了资源管理方面，别的事情精力就少多了，那就只能加班弥补了。</p>\n<p><strong>再从资源监控方面讲讲。</strong>由于我们已经有了强大的CMDB系统，再要做资源监控就是顺理成章的事情了。站在管理者的角度当然是有什么监控什么，监控指标越多越好咯。于是我们建立了丰富的运维监控指标体系，覆盖各种资源，监控指标包罗万象。然后监控系统运行起来以后，我们就整天关注着海量的监控对象和指标，一有个什么风吹草动，IT部门都心惊胆战的，生怕被考核了。后来就有人提出了自动化监控，由于IT的复杂度和技术的有限，结果自动化水平一直没有质的飞跃。</p>\n<p><strong>再从运维流程方面讲讲。</strong>IT运维当然需要有流程了，结果就诞生了好多IT运维流程，设备入库流程、设备领取流程、设备上线流程、设备报废流程等，系统上线运行流程、系统变更流程、系统下线流程等。这些所有流程，都需要从CMDB系统选取资源，这样就倒逼着CMDB系统数据的准确性。关键是CMDB系统数据已经不准确了！后来还有人提出了，运维流程流程还要跟资产变更的流程关联起来，跟资源监控也联动起来。IT运维系统的耦合性越来越高！</p>\n<p><strong>其实我们考虑好多问题，其实初衷都是对的，但是后来发现好多都走歪了。</strong>再后来就有了各种变革，各种适应性的改造，我们越来越痛苦！在后来发现，问题原来是出在了管理上，我们赋予了IT部门太多的历史使命，但是内部的管理水平和制度没跟的上IT的建设步伐！我们什么都想做，但是什么都没有做好，我们什么问题都想解决，但是什么问题都没彻底解决。凡事都有个过程，稳扎稳打每一步都走好了，才能越来越好，越来越轻松。</p>\n<p>感谢您能看完我的一堆唠叨，如果有不同的见解可以给我留言。谢谢！</p>"},{"title":"docker quick start","date":"2019-03-15T18:48:37.000Z","_content":"docker 官方文档：\nhttps://docs.docker.com/get-started/\n\n<!--more-->\n\n### 第一个docker容器，你将可以访问docker中运行的nginx实例。\n```\nyum install docker\nsystemctl start docker\ndocker image pull nginx\ndocker run -d -p 8080:80 nginx\ndocker ps\ncurl http://127.0.0.1:8080\n```","source":"_posts/docker/docker-quick-start.md","raw":"---\ntitle: docker quick start\ndate: 2019-03-15 18:48:37\ntags: dcoker\ncategories: docker\n---\ndocker 官方文档：\nhttps://docs.docker.com/get-started/\n\n<!--more-->\n\n### 第一个docker容器，你将可以访问docker中运行的nginx实例。\n```\nyum install docker\nsystemctl start docker\ndocker image pull nginx\ndocker run -d -p 8080:80 nginx\ndocker ps\ncurl http://127.0.0.1:8080\n```","slug":"docker/docker-quick-start","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxderb00210en7ijvq5ufi","content":"<p>docker 官方文档：<br><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/get-started/</a></p>\n<a id=\"more\"></a>\n<h3 id=\"第一个docker容器，你将可以访问docker中运行的nginx实例。\"><a href=\"#第一个docker容器，你将可以访问docker中运行的nginx实例。\" class=\"headerlink\" title=\"第一个docker容器，你将可以访问docker中运行的nginx实例。\"></a>第一个docker容器，你将可以访问docker中运行的nginx实例。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\">docker image pull nginx</span><br><span class=\"line\">docker run -d -p 8080:80 nginx</span><br><span class=\"line\">docker ps</span><br><span class=\"line\">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>docker 官方文档：<br><a href=\"https://docs.docker.com/get-started/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/get-started/</a></p>","more":"<h3 id=\"第一个docker容器，你将可以访问docker中运行的nginx实例。\"><a href=\"#第一个docker容器，你将可以访问docker中运行的nginx实例。\" class=\"headerlink\" title=\"第一个docker容器，你将可以访问docker中运行的nginx实例。\"></a>第一个docker容器，你将可以访问docker中运行的nginx实例。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install docker</span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\">docker image pull nginx</span><br><span class=\"line\">docker run -d -p 8080:80 nginx</span><br><span class=\"line\">docker ps</span><br><span class=\"line\">curl http://127.0.0.1:8080</span><br></pre></td></tr></table></figure>"},{"title":"CentOS8使用podman常见错误解决","date":"2020-04-23T18:48:37.000Z","_content":"\npodman 遇到there might not be enough IDs available in the namespace。\n<!--more-->\n\n\n# 1.podman 遇到there might not be enough IDs available in the namespace\n\n## 1.1发现错误：\n使用rootless用户pull ubuntu镜像，竟然报这种错误。\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user \"javadm\" in /etc/subuid\nERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user \"javadm\" in /etc/subuid\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n\n```\n\n## 1.2解决问题：\n**1./etc/subuid和/etc/subgid 增加子用户映射**\n````\n[root@instance-2 ~]# echo javadm:200000:300006666 >> /etc/subuid\n[root@instance-2 ~]# echo javadm:300000:400006666 >> /etc/subgid\n[root@instance-2 ~]# cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n[root@instance-2 ~]# cat /etc/subgid\nrobin:100000:65536\njavadm:300000:400006666\n\n````\n验证发现还报错：\n```\n[root@instance-2 ~]# su - javadm\nLast login: Fri Apr 24 13:15:11 UTC 2020 on pts/0\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n```\n\n**2.再次修改/etc/subuid和/etc/subgid**\n```\n[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:400000000:400006666\n```\n\n错误依旧：\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob fc878cd0a91c done\nCopying blob fee5db0ff82f done\nCopying blob d51af753c3d3 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n\n```\n\n**3.修改user.max_user_namespaces并且大于最大的UID**\n```\n  121  cd /etc/sysctl.d/\n  122  ll\n  123  touch podman.conf\n  124  echo user.max_user_namespaces = 900000000 >>podman.conf\n  125  cat podman.conf\n  126  reboot\n```\n错误依旧：\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying blob d51af753c3d3 done\nCopying blob 6154df8ff988 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n```\n\n**4.再想办法**\n```\n[javadm@instance-2 ~]$ getcap /usr/bin/newuidmap\n/usr/bin/newuidmap = cap_setuid+ep\npodman system migrate\n```\n\n**5.关闭selinux再试**\n```\n[root@instance-2 ~]# setenforce 0\n[root@instance-2 ~]# su - javadm\nLast login: Fri Apr 24 14:21:15 UTC 2020 on pts/0\n[javadm@instance-2 ~]$ getenforce\nPermissive\n```\n\n**6.回退subuid和subgid的修改**\n```\n\n[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:400000000:400006666\n[javadm@instance-2 ~]$\n\n```\n\n**7.做一些更改，最重要的**\n```\necho user.max_user_namespaces=900000000  >> /etc/sysctl.d/userns.conf\n\n**[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:165536:65536\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:165536:65536**\n[javadm@instance-2 ~]$\n\npodman system migrate\n```\n\n错误依旧。\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying blob fc878cd0a91c done\nCopying blob fee5db0ff82f done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01\n[javadm@instance-2 ~]$\n\n```\n\n**8.最终解决**\n```\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subuid\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subgid\n[javadm@localhost ~]$ podman system migrate\n[javadm@localhost ~]$ podman info\nhost:\n  BuildahVersion: 1.12.0-dev\n  CgroupVersion: v1\n  Conmon:\n    package: conmon-2.0.6-1.module_el8.1.0+298+41f9343a.x86_64\n    path: /usr/bin/conmon\n    version: 'conmon version 2.0.6, commit: 2721f230f94894671f141762bd0d1af2fb263239'\n  Distribution:\n    distribution: '\"centos\"'\n    version: \"8\"\n  IDMappings:\n    gidmap:\n    - container_id: 0\n      host_id: 400001528\n      size: 1\n    - container_id: 1\n      host_id: 410000000\n      size: 500000000\n    uidmap:\n    - container_id: 0\n      host_id: 300005526\n      size: 1\n    - container_id: 1\n      host_id: 410000000\n      size: 500000000\n  MemFree: 61030400\n  MemTotal: 500600832\n  OCIRuntime:\n    name: runc\n    package: runc-1.0.0-64.rc9.module_el8.1.0+298+41f9343a.x86_64\n    path: /usr/bin/runc\n    version: 'runc version spec: 1.0.1-dev'\n  SwapFree: 2124136448\n  SwapTotal: 2147479552\n  arch: amd64\n  cpus: 1\n  eventlogger: file\n  hostname: localhost.localdomain\n  kernel: 4.18.0-80.el8.x86_64\n  os: linux\n  rootless: true\n  slirp4netns:\n    Executable: /usr/bin/slirp4netns\n    Package: slirp4netns-0.4.2-3.git21fdece.module_el8.1.0+298+41f9343a.x86_64\n    Version: |-\n      slirp4netns version 0.4.2+dev\n      commit: 21fdece2737dc24ffa3f01a341b8a6854f8b13b4\n  uptime: 16m 24.88s\nregistries:\n  blocked: null\n  insecure: null\n  search:\n  - registry.access.redhat.com\n  - registry.fedoraproject.org\n  - registry.centos.org\n  - docker.io\nstore:\n  ConfigFile: /home/javadm/.config/containers/storage.conf\n  ContainerStore:\n    number: 0\n  GraphDriverName: overlay\n  GraphOptions:\n    overlay.mount_program:\n      Executable: /usr/bin/fuse-overlayfs\n      Package: fuse-overlayfs-0.7.2-5.module_el8.1.0+298+41f9343a.x86_64\n      Version: |-\n        fuse-overlayfs: version 0.7.2\n        FUSE library version 3.2.1\n        using FUSE kernel interface version 7.26\n  GraphRoot: /home/javadm/.local/share/containers/storage\n  GraphStatus:\n    Backing Filesystem: xfs\n    Native Overlay Diff: \"false\"\n    Supports d_type: \"true\"\n    Using metacopy: \"false\"\n  ImageStore:\n    number: 0\n  RunRoot: /tmp/run-300005526\n  VolumePath: /home/javadm/.local/share/containers/storage/volumes\n  \n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$  docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f skipped: already exists\nCopying blob fc878cd0a91c skipped: already exists\nCopying blob 6154df8ff988 skipped: already exists\nCopying blob d51af753c3d3 skipped: already exists\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ docker image list\nREPOSITORY                   TAG      IMAGE ID       CREATED        SIZE\ndocker.io/library/ubuntu     latest   1d622ef86b13   33 hours ago   76.3 MB\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$\n```\n\n## 3.总结问题\n经过重复测试后，发现解决这种问题还是要先解决namespace分配的问题，正确的步骤应该这样。\n\n**3.1检查现有用户的UID和GID，并且找出最大的ID。**\n```\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/passwd|awk -F ':' '{print $3,$4}'|sort\n0 0\n1 1\n11 0\n12 100\n14 50\n193 193\n2 2\n28 28\n300005526 400001528\n3 4\n4 7\n5 0\n59 59\n6 0\n65534 65534\n7 0\n72 72\n74 74\n8 12\n81 81\n93 93\n992 988\n993 989\n994 990\n995 992\n996 993\n997 994\n998 996\n999 997\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/group|awk -F ':' '{print $3}'|sort\n0\n1\n10\n100\n11\n12\n15\n18\n19\n190\n193\n2\n20\n21\n22\n28\n3\n33\n35\n36\n39\n4\n400001528\n5\n50\n54\n59\n6\n63\n65534\n7\n72\n74\n8\n81\n9\n93\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$\n\n```\n>用户和组配置文件中最大的ID是400001528\n\n**3.2检查现有的/etc/subuid和/etc/subgid**\n```\n[vagrant@localhost ~]$ cat /etc/subuid\nvagrant:100000:65536\n[vagrant@localhost ~]$ cat /etc/subgid\nvagrant:100000:65536\n```\n>最大的ID是100000+65536=165536\n\n**3.3为javadm用户配置/etc/subuid和/etc/subgid**\n```\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subuid\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subgid\n[javadm@localhost ~]$ podman system migrate\n[javadm@localhost ~]$ podman info\n```\n>子用户使用的subuid初始值应该超出现有被使用的范围，之前找到的最大值是400001528。所以这里我们从410000000开始，最后一位是计数器设置要大于容器内用户的UID/GID，这里设置500000000。\n\n\n**3.4我们再来看下官方文档的说明：**\nUpgrade to rootless containers\nIf you have upgraded from RHEL 7, you must configure subuid and subgid values manually for any existing user you want to be able to use rootless podman.\n\nUsing an existing user name and group name (for example, jill), set the range of accessible user and group IDs that can be used for their containers. Here are a couple of warnings:\n\nDon’t include the rootless user’s UID and GID in these ranges\nIf you set multiple rootless container users, use unique ranges for each user\nWe recommend 65536 UIDs and GIDs for maximum compatibility with existing container images, but the number can be reduced\nNever use UIDs or GIDs under 1000 or reuse UIDs or GIDs from existing user accounts (which, by default, start at 1000)\n\nHere is an example:\n\n`# echo \"jill:165537:65536\" >> /etc/subuid`\n`# echo \"jill:165537:65536\" >> /etc/subgid`\nThe user/group jill is now allocated 65535 user and group IDs, ranging from 165537-231072. That user should be able to begin running commands to work with containers now.\n\n**3.5容器启动后验证uidmap**\n```\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ podman unshare cat /proc/self/uid_map\n         0  300005526          1\n         1  410000000  500000000\n```\n>容器中的用户uid 1对应宿主机的410000000，uid 2对应宿主机410000000-1+2，容器中的应用应用uid 300005526，对应宿主机410000000-1+300005526。以此类推。容器中最大用户ID不能超过500000000，符合我们的预期，验证通过。\n\n**参考资料**\nFrom Docker To Podman [link](http://www.ranta.ch/posts/FromDockerToPodman/)\nWhy can’t rootless Podman pull my image [link](https://www.redhat.com/sysadmin/rootless-podman)\nthere might not be enough IDs available in the namespace (system migrate doesn't work1)  [link](https://github.com/containers/libpod/issues/4921)\nRootless Podman on CentOS [link](http://blog.zencoffee.org/2020/02/rootless-podman-on-centos/)\nRunning rootless Podman as a non-root user [link](https://www.redhat.com/sysadmin/rootless-podman-makes-sense)\nstart to use podman [link](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/building_running_and_managing_containers/starting-with-containers_building-running-and-managing-containers)","source":"_posts/docker/podman-namaspace-error.md","raw":"---\ntitle: CentOS8使用podman常见错误解决\ndate: 2020-04-23 18:48:37\ntags: podman\ncategories: docker\n---\n\npodman 遇到there might not be enough IDs available in the namespace。\n<!--more-->\n\n\n# 1.podman 遇到there might not be enough IDs available in the namespace\n\n## 1.1发现错误：\n使用rootless用户pull ubuntu镜像，竟然报这种错误。\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user \"javadm\" in /etc/subuid\nERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user \"javadm\" in /etc/subuid\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n\n```\n\n## 1.2解决问题：\n**1./etc/subuid和/etc/subgid 增加子用户映射**\n````\n[root@instance-2 ~]# echo javadm:200000:300006666 >> /etc/subuid\n[root@instance-2 ~]# echo javadm:300000:400006666 >> /etc/subgid\n[root@instance-2 ~]# cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n[root@instance-2 ~]# cat /etc/subgid\nrobin:100000:65536\njavadm:300000:400006666\n\n````\n验证发现还报错：\n```\n[root@instance-2 ~]# su - javadm\nLast login: Fri Apr 24 13:15:11 UTC 2020 on pts/0\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n```\n\n**2.再次修改/etc/subuid和/etc/subgid**\n```\n[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:400000000:400006666\n```\n\n错误依旧：\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob fc878cd0a91c done\nCopying blob fee5db0ff82f done\nCopying blob d51af753c3d3 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n\n```\n\n**3.修改user.max_user_namespaces并且大于最大的UID**\n```\n  121  cd /etc/sysctl.d/\n  122  ll\n  123  touch podman.conf\n  124  echo user.max_user_namespaces = 900000000 >>podman.conf\n  125  cat podman.conf\n  126  reboot\n```\n错误依旧：\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f done\nCopying blob fc878cd0a91c done\nCopying blob d51af753c3d3 done\nCopying blob 6154df8ff988 done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\nError: error pulling image \"ubuntu\": unable to pull ubuntu: 4 errors occurred:\n        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found\n        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown\n        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown\n        * Error committing the finished image: error adding layer with blob \"sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e\": Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument\n```\n\n**4.再想办法**\n```\n[javadm@instance-2 ~]$ getcap /usr/bin/newuidmap\n/usr/bin/newuidmap = cap_setuid+ep\npodman system migrate\n```\n\n**5.关闭selinux再试**\n```\n[root@instance-2 ~]# setenforce 0\n[root@instance-2 ~]# su - javadm\nLast login: Fri Apr 24 14:21:15 UTC 2020 on pts/0\n[javadm@instance-2 ~]$ getenforce\nPermissive\n```\n\n**6.回退subuid和subgid的修改**\n```\n\n[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:200000:300006666\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:400000000:400006666\n[javadm@instance-2 ~]$\n\n```\n\n**7.做一些更改，最重要的**\n```\necho user.max_user_namespaces=900000000  >> /etc/sysctl.d/userns.conf\n\n**[javadm@instance-2 ~]$ cat /etc/subuid\nrobin:100000:65536\njavadm:165536:65536\n[javadm@instance-2 ~]$ cat /etc/subgid\nrobin:100000:65536\njavadm:165536:65536**\n[javadm@instance-2 ~]$\n\npodman system migrate\n```\n\n错误依旧。\n```\n[javadm@instance-2 ~]$ docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob 6154df8ff988 done\nCopying blob d51af753c3d3 done\nCopying blob fc878cd0a91c done\nCopying blob fee5db0ff82f done\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01\n[javadm@instance-2 ~]$\n\n```\n\n**8.最终解决**\n```\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subuid\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subgid\n[javadm@localhost ~]$ podman system migrate\n[javadm@localhost ~]$ podman info\nhost:\n  BuildahVersion: 1.12.0-dev\n  CgroupVersion: v1\n  Conmon:\n    package: conmon-2.0.6-1.module_el8.1.0+298+41f9343a.x86_64\n    path: /usr/bin/conmon\n    version: 'conmon version 2.0.6, commit: 2721f230f94894671f141762bd0d1af2fb263239'\n  Distribution:\n    distribution: '\"centos\"'\n    version: \"8\"\n  IDMappings:\n    gidmap:\n    - container_id: 0\n      host_id: 400001528\n      size: 1\n    - container_id: 1\n      host_id: 410000000\n      size: 500000000\n    uidmap:\n    - container_id: 0\n      host_id: 300005526\n      size: 1\n    - container_id: 1\n      host_id: 410000000\n      size: 500000000\n  MemFree: 61030400\n  MemTotal: 500600832\n  OCIRuntime:\n    name: runc\n    package: runc-1.0.0-64.rc9.module_el8.1.0+298+41f9343a.x86_64\n    path: /usr/bin/runc\n    version: 'runc version spec: 1.0.1-dev'\n  SwapFree: 2124136448\n  SwapTotal: 2147479552\n  arch: amd64\n  cpus: 1\n  eventlogger: file\n  hostname: localhost.localdomain\n  kernel: 4.18.0-80.el8.x86_64\n  os: linux\n  rootless: true\n  slirp4netns:\n    Executable: /usr/bin/slirp4netns\n    Package: slirp4netns-0.4.2-3.git21fdece.module_el8.1.0+298+41f9343a.x86_64\n    Version: |-\n      slirp4netns version 0.4.2+dev\n      commit: 21fdece2737dc24ffa3f01a341b8a6854f8b13b4\n  uptime: 16m 24.88s\nregistries:\n  blocked: null\n  insecure: null\n  search:\n  - registry.access.redhat.com\n  - registry.fedoraproject.org\n  - registry.centos.org\n  - docker.io\nstore:\n  ConfigFile: /home/javadm/.config/containers/storage.conf\n  ContainerStore:\n    number: 0\n  GraphDriverName: overlay\n  GraphOptions:\n    overlay.mount_program:\n      Executable: /usr/bin/fuse-overlayfs\n      Package: fuse-overlayfs-0.7.2-5.module_el8.1.0+298+41f9343a.x86_64\n      Version: |-\n        fuse-overlayfs: version 0.7.2\n        FUSE library version 3.2.1\n        using FUSE kernel interface version 7.26\n  GraphRoot: /home/javadm/.local/share/containers/storage\n  GraphStatus:\n    Backing Filesystem: xfs\n    Native Overlay Diff: \"false\"\n    Supports d_type: \"true\"\n    Using metacopy: \"false\"\n  ImageStore:\n    number: 0\n  RunRoot: /tmp/run-300005526\n  VolumePath: /home/javadm/.local/share/containers/storage/volumes\n  \n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$  docker pull ubuntu\nTrying to pull registry.access.redhat.com/ubuntu...\n  name unknown: Repo not found\nTrying to pull registry.fedoraproject.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull registry.centos.org/ubuntu...\n  manifest unknown: manifest unknown\nTrying to pull docker.io/library/ubuntu...\nGetting image source signatures\nCopying blob fee5db0ff82f skipped: already exists\nCopying blob fc878cd0a91c skipped: already exists\nCopying blob 6154df8ff988 skipped: already exists\nCopying blob d51af753c3d3 skipped: already exists\nCopying config 1d622ef86b done\nWriting manifest to image destination\nStoring signatures\n1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ docker image list\nREPOSITORY                   TAG      IMAGE ID       CREATED        SIZE\ndocker.io/library/ubuntu     latest   1d622ef86b13   33 hours ago   76.3 MB\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$\n```\n\n## 3.总结问题\n经过重复测试后，发现解决这种问题还是要先解决namespace分配的问题，正确的步骤应该这样。\n\n**3.1检查现有用户的UID和GID，并且找出最大的ID。**\n```\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/passwd|awk -F ':' '{print $3,$4}'|sort\n0 0\n1 1\n11 0\n12 100\n14 50\n193 193\n2 2\n28 28\n300005526 400001528\n3 4\n4 7\n5 0\n59 59\n6 0\n65534 65534\n7 0\n72 72\n74 74\n8 12\n81 81\n93 93\n992 988\n993 989\n994 990\n995 992\n996 993\n997 994\n998 996\n999 997\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/group|awk -F ':' '{print $3}'|sort\n0\n1\n10\n100\n11\n12\n15\n18\n19\n190\n193\n2\n20\n21\n22\n28\n3\n33\n35\n36\n39\n4\n400001528\n5\n50\n54\n59\n6\n63\n65534\n7\n72\n74\n8\n81\n9\n93\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$\n\n```\n>用户和组配置文件中最大的ID是400001528\n\n**3.2检查现有的/etc/subuid和/etc/subgid**\n```\n[vagrant@localhost ~]$ cat /etc/subuid\nvagrant:100000:65536\n[vagrant@localhost ~]$ cat /etc/subgid\nvagrant:100000:65536\n```\n>最大的ID是100000+65536=165536\n\n**3.3为javadm用户配置/etc/subuid和/etc/subgid**\n```\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subuid\n[javadm@localhost ~]$ echo javadm:410000000:500000000 >> /etc/subgid\n[javadm@localhost ~]$ podman system migrate\n[javadm@localhost ~]$ podman info\n```\n>子用户使用的subuid初始值应该超出现有被使用的范围，之前找到的最大值是400001528。所以这里我们从410000000开始，最后一位是计数器设置要大于容器内用户的UID/GID，这里设置500000000。\n\n\n**3.4我们再来看下官方文档的说明：**\nUpgrade to rootless containers\nIf you have upgraded from RHEL 7, you must configure subuid and subgid values manually for any existing user you want to be able to use rootless podman.\n\nUsing an existing user name and group name (for example, jill), set the range of accessible user and group IDs that can be used for their containers. Here are a couple of warnings:\n\nDon’t include the rootless user’s UID and GID in these ranges\nIf you set multiple rootless container users, use unique ranges for each user\nWe recommend 65536 UIDs and GIDs for maximum compatibility with existing container images, but the number can be reduced\nNever use UIDs or GIDs under 1000 or reuse UIDs or GIDs from existing user accounts (which, by default, start at 1000)\n\nHere is an example:\n\n`# echo \"jill:165537:65536\" >> /etc/subuid`\n`# echo \"jill:165537:65536\" >> /etc/subgid`\nThe user/group jill is now allocated 65535 user and group IDs, ranging from 165537-231072. That user should be able to begin running commands to work with containers now.\n\n**3.5容器启动后验证uidmap**\n```\n[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ podman unshare cat /proc/self/uid_map\n         0  300005526          1\n         1  410000000  500000000\n```\n>容器中的用户uid 1对应宿主机的410000000，uid 2对应宿主机410000000-1+2，容器中的应用应用uid 300005526，对应宿主机410000000-1+300005526。以此类推。容器中最大用户ID不能超过500000000，符合我们的预期，验证通过。\n\n**参考资料**\nFrom Docker To Podman [link](http://www.ranta.ch/posts/FromDockerToPodman/)\nWhy can’t rootless Podman pull my image [link](https://www.redhat.com/sysadmin/rootless-podman)\nthere might not be enough IDs available in the namespace (system migrate doesn't work1)  [link](https://github.com/containers/libpod/issues/4921)\nRootless Podman on CentOS [link](http://blog.zencoffee.org/2020/02/rootless-podman-on-centos/)\nRunning rootless Podman as a non-root user [link](https://www.redhat.com/sysadmin/rootless-podman-makes-sense)\nstart to use podman [link](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/building_running_and_managing_containers/starting-with-containers_building-running-and-managing-containers)","slug":"docker/podman-namaspace-error","published":1,"updated":"2020-04-25T14:36:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxderj00260en73tncmsa1","content":"<p>podman 遇到there might not be enough IDs available in the namespace。<br><a id=\"more\"></a></p>\n<h1 id=\"1-podman-遇到there-might-not-be-enough-IDs-available-in-the-namespace\"><a href=\"#1-podman-遇到there-might-not-be-enough-IDs-available-in-the-namespace\" class=\"headerlink\" title=\"1.podman 遇到there might not be enough IDs available in the namespace\"></a>1.podman 遇到there might not be enough IDs available in the namespace</h1><h2 id=\"1-1发现错误：\"><a href=\"#1-1发现错误：\" class=\"headerlink\" title=\"1.1发现错误：\"></a>1.1发现错误：</h2><p>使用rootless用户pull ubuntu镜像，竟然报这种错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">ERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user &quot;javadm&quot; in /etc/subuid</span><br><span class=\"line\">ERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user &quot;javadm&quot; in /etc/subuid</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2解决问题：\"><a href=\"#1-2解决问题：\" class=\"headerlink\" title=\"1.2解决问题：\"></a>1.2解决问题：</h2><p><strong>1./etc/subuid和/etc/subgid 增加子用户映射</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# echo javadm:200000:300006666 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[root@instance-2 ~]# echo javadm:300000:400006666 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[root@instance-2 ~]# cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\">[root@instance-2 ~]# cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:300000:400006666</span><br></pre></td></tr></table></figure></p>\n<p>验证发现还报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# su - javadm</span><br><span class=\"line\">Last login: Fri Apr 24 13:15:11 UTC 2020 on pts/0</span><br><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.再次修改/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\"></span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:400000000:400006666</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.修改user.max_user_namespaces并且大于最大的UID</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">121  cd /etc/sysctl.d/</span><br><span class=\"line\">122  ll</span><br><span class=\"line\">123  touch podman.conf</span><br><span class=\"line\">124  echo user.max_user_namespaces = 900000000 &gt;&gt;podman.conf</span><br><span class=\"line\">125  cat podman.conf</span><br><span class=\"line\">126  reboot</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>4.再想办法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ getcap /usr/bin/newuidmap</span><br><span class=\"line\">/usr/bin/newuidmap = cap_setuid+ep</span><br><span class=\"line\">podman system migrate</span><br></pre></td></tr></table></figure></p>\n<p><strong>5.关闭selinux再试</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# setenforce 0</span><br><span class=\"line\">[root@instance-2 ~]# su - javadm</span><br><span class=\"line\">Last login: Fri Apr 24 14:21:15 UTC 2020 on pts/0</span><br><span class=\"line\">[javadm@instance-2 ~]$ getenforce</span><br><span class=\"line\">Permissive</span><br></pre></td></tr></table></figure></p>\n<p><strong>6.回退subuid和subgid的修改</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:400000000:400006666</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>7.做一些更改，最重要的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo user.max_user_namespaces=900000000  &gt;&gt; /etc/sysctl.d/userns.conf</span><br><span class=\"line\"></span><br><span class=\"line\">**[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:165536:65536</span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:165536:65536**</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">podman system migrate</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>8.最终解决</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[javadm@localhost ~]$ podman system migrate</span><br><span class=\"line\">[javadm@localhost ~]$ podman info</span><br><span class=\"line\">host:</span><br><span class=\"line\">  BuildahVersion: 1.12.0-dev</span><br><span class=\"line\">  CgroupVersion: v1</span><br><span class=\"line\">  Conmon:</span><br><span class=\"line\">    package: conmon-2.0.6-1.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    path: /usr/bin/conmon</span><br><span class=\"line\">    version: &apos;conmon version 2.0.6, commit: 2721f230f94894671f141762bd0d1af2fb263239&apos;</span><br><span class=\"line\">  Distribution:</span><br><span class=\"line\">    distribution: &apos;&quot;centos&quot;&apos;</span><br><span class=\"line\">    version: &quot;8&quot;</span><br><span class=\"line\">  IDMappings:</span><br><span class=\"line\">    gidmap:</span><br><span class=\"line\">    - container_id: 0</span><br><span class=\"line\">      host_id: 400001528</span><br><span class=\"line\">      size: 1</span><br><span class=\"line\">    - container_id: 1</span><br><span class=\"line\">      host_id: 410000000</span><br><span class=\"line\">      size: 500000000</span><br><span class=\"line\">    uidmap:</span><br><span class=\"line\">    - container_id: 0</span><br><span class=\"line\">      host_id: 300005526</span><br><span class=\"line\">      size: 1</span><br><span class=\"line\">    - container_id: 1</span><br><span class=\"line\">      host_id: 410000000</span><br><span class=\"line\">      size: 500000000</span><br><span class=\"line\">  MemFree: 61030400</span><br><span class=\"line\">  MemTotal: 500600832</span><br><span class=\"line\">  OCIRuntime:</span><br><span class=\"line\">    name: runc</span><br><span class=\"line\">    package: runc-1.0.0-64.rc9.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    path: /usr/bin/runc</span><br><span class=\"line\">    version: &apos;runc version spec: 1.0.1-dev&apos;</span><br><span class=\"line\">  SwapFree: 2124136448</span><br><span class=\"line\">  SwapTotal: 2147479552</span><br><span class=\"line\">  arch: amd64</span><br><span class=\"line\">  cpus: 1</span><br><span class=\"line\">  eventlogger: file</span><br><span class=\"line\">  hostname: localhost.localdomain</span><br><span class=\"line\">  kernel: 4.18.0-80.el8.x86_64</span><br><span class=\"line\">  os: linux</span><br><span class=\"line\">  rootless: true</span><br><span class=\"line\">  slirp4netns:</span><br><span class=\"line\">    Executable: /usr/bin/slirp4netns</span><br><span class=\"line\">    Package: slirp4netns-0.4.2-3.git21fdece.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    Version: |-</span><br><span class=\"line\">      slirp4netns version 0.4.2+dev</span><br><span class=\"line\">      commit: 21fdece2737dc24ffa3f01a341b8a6854f8b13b4</span><br><span class=\"line\">  uptime: 16m 24.88s</span><br><span class=\"line\">registries:</span><br><span class=\"line\">  blocked: null</span><br><span class=\"line\">  insecure: null</span><br><span class=\"line\">  search:</span><br><span class=\"line\">  - registry.access.redhat.com</span><br><span class=\"line\">  - registry.fedoraproject.org</span><br><span class=\"line\">  - registry.centos.org</span><br><span class=\"line\">  - docker.io</span><br><span class=\"line\">store:</span><br><span class=\"line\">  ConfigFile: /home/javadm/.config/containers/storage.conf</span><br><span class=\"line\">  ContainerStore:</span><br><span class=\"line\">    number: 0</span><br><span class=\"line\">  GraphDriverName: overlay</span><br><span class=\"line\">  GraphOptions:</span><br><span class=\"line\">    overlay.mount_program:</span><br><span class=\"line\">      Executable: /usr/bin/fuse-overlayfs</span><br><span class=\"line\">      Package: fuse-overlayfs-0.7.2-5.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">      Version: |-</span><br><span class=\"line\">        fuse-overlayfs: version 0.7.2</span><br><span class=\"line\">        FUSE library version 3.2.1</span><br><span class=\"line\">        using FUSE kernel interface version 7.26</span><br><span class=\"line\">  GraphRoot: /home/javadm/.local/share/containers/storage</span><br><span class=\"line\">  GraphStatus:</span><br><span class=\"line\">    Backing Filesystem: xfs</span><br><span class=\"line\">    Native Overlay Diff: &quot;false&quot;</span><br><span class=\"line\">    Supports d_type: &quot;true&quot;</span><br><span class=\"line\">    Using metacopy: &quot;false&quot;</span><br><span class=\"line\">  ImageStore:</span><br><span class=\"line\">    number: 0</span><br><span class=\"line\">  RunRoot: /tmp/run-300005526</span><br><span class=\"line\">  VolumePath: /home/javadm/.local/share/containers/storage/volumes</span><br><span class=\"line\">  </span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$  docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f skipped: already exists</span><br><span class=\"line\">Copying blob fc878cd0a91c skipped: already exists</span><br><span class=\"line\">Copying blob 6154df8ff988 skipped: already exists</span><br><span class=\"line\">Copying blob d51af753c3d3 skipped: already exists</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ docker image list</span><br><span class=\"line\">REPOSITORY                   TAG      IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">docker.io/library/ubuntu     latest   1d622ef86b13   33 hours ago   76.3 MB</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-总结问题\"><a href=\"#3-总结问题\" class=\"headerlink\" title=\"3.总结问题\"></a>3.总结问题</h2><p>经过重复测试后，发现解决这种问题还是要先解决namespace分配的问题，正确的步骤应该这样。</p>\n<p><strong>3.1检查现有用户的UID和GID，并且找出最大的ID。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/passwd|awk -F &apos;:&apos; &apos;&#123;print $3,$4&#125;&apos;|sort</span><br><span class=\"line\">0 0</span><br><span class=\"line\">1 1</span><br><span class=\"line\">11 0</span><br><span class=\"line\">12 100</span><br><span class=\"line\">14 50</span><br><span class=\"line\">193 193</span><br><span class=\"line\">2 2</span><br><span class=\"line\">28 28</span><br><span class=\"line\">300005526 400001528</span><br><span class=\"line\">3 4</span><br><span class=\"line\">4 7</span><br><span class=\"line\">5 0</span><br><span class=\"line\">59 59</span><br><span class=\"line\">6 0</span><br><span class=\"line\">65534 65534</span><br><span class=\"line\">7 0</span><br><span class=\"line\">72 72</span><br><span class=\"line\">74 74</span><br><span class=\"line\">8 12</span><br><span class=\"line\">81 81</span><br><span class=\"line\">93 93</span><br><span class=\"line\">992 988</span><br><span class=\"line\">993 989</span><br><span class=\"line\">994 990</span><br><span class=\"line\">995 992</span><br><span class=\"line\">996 993</span><br><span class=\"line\">997 994</span><br><span class=\"line\">998 996</span><br><span class=\"line\">999 997</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/group|awk -F &apos;:&apos; &apos;&#123;print $3&#125;&apos;|sort</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">10</span><br><span class=\"line\">100</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">15</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">190</span><br><span class=\"line\">193</span><br><span class=\"line\">2</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">28</span><br><span class=\"line\">3</span><br><span class=\"line\">33</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">39</span><br><span class=\"line\">4</span><br><span class=\"line\">400001528</span><br><span class=\"line\">5</span><br><span class=\"line\">50</span><br><span class=\"line\">54</span><br><span class=\"line\">59</span><br><span class=\"line\">6</span><br><span class=\"line\">63</span><br><span class=\"line\">65534</span><br><span class=\"line\">7</span><br><span class=\"line\">72</span><br><span class=\"line\">74</span><br><span class=\"line\">8</span><br><span class=\"line\">81</span><br><span class=\"line\">9</span><br><span class=\"line\">93</span><br><span class=\"line\">988</span><br><span class=\"line\">989</span><br><span class=\"line\">990</span><br><span class=\"line\">991</span><br><span class=\"line\">992</span><br><span class=\"line\">993</span><br><span class=\"line\">994</span><br><span class=\"line\">995</span><br><span class=\"line\">996</span><br><span class=\"line\">997</span><br><span class=\"line\">998</span><br><span class=\"line\">999</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>用户和组配置文件中最大的ID是400001528</p>\n</blockquote>\n<p><strong>3.2检查现有的/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[vagrant@localhost ~]$ cat /etc/subuid</span><br><span class=\"line\">vagrant:100000:65536</span><br><span class=\"line\">[vagrant@localhost ~]$ cat /etc/subgid</span><br><span class=\"line\">vagrant:100000:65536</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>最大的ID是100000+65536=165536</p>\n</blockquote>\n<p><strong>3.3为javadm用户配置/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[javadm@localhost ~]$ podman system migrate</span><br><span class=\"line\">[javadm@localhost ~]$ podman info</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>子用户使用的subuid初始值应该超出现有被使用的范围，之前找到的最大值是400001528。所以这里我们从410000000开始，最后一位是计数器设置要大于容器内用户的UID/GID，这里设置500000000。</p>\n</blockquote>\n<p><strong>3.4我们再来看下官方文档的说明：</strong><br>Upgrade to rootless containers<br>If you have upgraded from RHEL 7, you must configure subuid and subgid values manually for any existing user you want to be able to use rootless podman.</p>\n<p>Using an existing user name and group name (for example, jill), set the range of accessible user and group IDs that can be used for their containers. Here are a couple of warnings:</p>\n<p>Don’t include the rootless user’s UID and GID in these ranges<br>If you set multiple rootless container users, use unique ranges for each user<br>We recommend 65536 UIDs and GIDs for maximum compatibility with existing container images, but the number can be reduced<br>Never use UIDs or GIDs under 1000 or reuse UIDs or GIDs from existing user accounts (which, by default, start at 1000)</p>\n<p>Here is an example:</p>\n<p><code># echo &quot;jill:165537:65536&quot; &gt;&gt; /etc/subuid</code><br><code># echo &quot;jill:165537:65536&quot; &gt;&gt; /etc/subgid</code><br>The user/group jill is now allocated 65535 user and group IDs, ranging from 165537-231072. That user should be able to begin running commands to work with containers now.</p>\n<p><strong>3.5容器启动后验证uidmap</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ podman unshare cat /proc/self/uid_map</span><br><span class=\"line\">         0  300005526          1</span><br><span class=\"line\">         1  410000000  500000000</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>容器中的用户uid 1对应宿主机的410000000，uid 2对应宿主机410000000-1+2，容器中的应用应用uid 300005526，对应宿主机410000000-1+300005526。以此类推。容器中最大用户ID不能超过500000000，符合我们的预期，验证通过。</p>\n</blockquote>\n<p><strong>参考资料</strong><br>From Docker To Podman <a href=\"http://www.ranta.ch/posts/FromDockerToPodman/\" target=\"_blank\" rel=\"noopener\">link</a><br>Why can’t rootless Podman pull my image <a href=\"https://www.redhat.com/sysadmin/rootless-podman\" target=\"_blank\" rel=\"noopener\">link</a><br>there might not be enough IDs available in the namespace (system migrate doesn’t work1)  <a href=\"https://github.com/containers/libpod/issues/4921\" target=\"_blank\" rel=\"noopener\">link</a><br>Rootless Podman on CentOS <a href=\"http://blog.zencoffee.org/2020/02/rootless-podman-on-centos/\" target=\"_blank\" rel=\"noopener\">link</a><br>Running rootless Podman as a non-root user <a href=\"https://www.redhat.com/sysadmin/rootless-podman-makes-sense\" target=\"_blank\" rel=\"noopener\">link</a><br>start to use podman <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/building_running_and_managing_containers/starting-with-containers_building-running-and-managing-containers\" target=\"_blank\" rel=\"noopener\">link</a></p>\n","site":{"data":{}},"excerpt":"<p>podman 遇到there might not be enough IDs available in the namespace。<br>","more":"</p>\n<h1 id=\"1-podman-遇到there-might-not-be-enough-IDs-available-in-the-namespace\"><a href=\"#1-podman-遇到there-might-not-be-enough-IDs-available-in-the-namespace\" class=\"headerlink\" title=\"1.podman 遇到there might not be enough IDs available in the namespace\"></a>1.podman 遇到there might not be enough IDs available in the namespace</h1><h2 id=\"1-1发现错误：\"><a href=\"#1-1发现错误：\" class=\"headerlink\" title=\"1.1发现错误：\"></a>1.1发现错误：</h2><p>使用rootless用户pull ubuntu镜像，竟然报这种错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">ERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user &quot;javadm&quot; in /etc/subuid</span><br><span class=\"line\">ERRO[0000] cannot find mappings for user javadm: No subuid ranges found for user &quot;javadm&quot; in /etc/subuid</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2解决问题：\"><a href=\"#1-2解决问题：\" class=\"headerlink\" title=\"1.2解决问题：\"></a>1.2解决问题：</h2><p><strong>1./etc/subuid和/etc/subgid 增加子用户映射</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# echo javadm:200000:300006666 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[root@instance-2 ~]# echo javadm:300000:400006666 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[root@instance-2 ~]# cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\">[root@instance-2 ~]# cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:300000:400006666</span><br></pre></td></tr></table></figure></p>\n<p>验证发现还报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# su - javadm</span><br><span class=\"line\">Last login: Fri Apr 24 13:15:11 UTC 2020 on pts/0</span><br><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.再次修改/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\"></span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:400000000:400006666</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>3.修改user.max_user_namespaces并且大于最大的UID</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">121  cd /etc/sysctl.d/</span><br><span class=\"line\">122  ll</span><br><span class=\"line\">123  touch podman.conf</span><br><span class=\"line\">124  echo user.max_user_namespaces = 900000000 &gt;&gt;podman.conf</span><br><span class=\"line\">125  cat podman.conf</span><br><span class=\"line\">126  reboot</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">  Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br><span class=\"line\">Error: error pulling image &quot;ubuntu&quot;: unable to pull ubuntu: 4 errors occurred:</span><br><span class=\"line\">        * Error initializing source docker://registry.access.redhat.com/ubuntu:latest: Error reading manifest latest in registry.access.redhat.com/ubuntu: name unknown: Repo not found</span><br><span class=\"line\">        * Error initializing source docker://registry.fedoraproject.org/ubuntu:latest: Error reading manifest latest in registry.fedoraproject.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error initializing source docker://registry.centos.org/ubuntu:latest: Error reading manifest latest in registry.centos.org/ubuntu: manifest unknown: manifest unknown</span><br><span class=\"line\">        * Error committing the finished image: error adding layer with blob &quot;sha256:d51af753c3d3a984351448ec0f85ddafc580680fd6dfce9f4b09fdb367ee1e3e&quot;: Error processing tar file(exit status 1): there might not be enough IDs available in the namespace (requested 0:42 for /etc/gshadow): lchown /etc/gshadow: invalid argument</span><br></pre></td></tr></table></figure></p>\n<p><strong>4.再想办法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ getcap /usr/bin/newuidmap</span><br><span class=\"line\">/usr/bin/newuidmap = cap_setuid+ep</span><br><span class=\"line\">podman system migrate</span><br></pre></td></tr></table></figure></p>\n<p><strong>5.关闭selinux再试</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-2 ~]# setenforce 0</span><br><span class=\"line\">[root@instance-2 ~]# su - javadm</span><br><span class=\"line\">Last login: Fri Apr 24 14:21:15 UTC 2020 on pts/0</span><br><span class=\"line\">[javadm@instance-2 ~]$ getenforce</span><br><span class=\"line\">Permissive</span><br></pre></td></tr></table></figure></p>\n<p><strong>6.回退subuid和subgid的修改</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:200000:300006666</span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:400000000:400006666</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>7.做一些更改，最重要的</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo user.max_user_namespaces=900000000  &gt;&gt; /etc/sysctl.d/userns.conf</span><br><span class=\"line\"></span><br><span class=\"line\">**[javadm@instance-2 ~]$ cat /etc/subuid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:165536:65536</span><br><span class=\"line\">[javadm@instance-2 ~]$ cat /etc/subgid</span><br><span class=\"line\">robin:100000:65536</span><br><span class=\"line\">javadm:165536:65536**</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">podman system migrate</span><br></pre></td></tr></table></figure></p>\n<p>错误依旧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@instance-2 ~]$ docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob 6154df8ff988 done</span><br><span class=\"line\">Copying blob d51af753c3d3 done</span><br><span class=\"line\">Copying blob fc878cd0a91c done</span><br><span class=\"line\">Copying blob fee5db0ff82f done</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01</span><br><span class=\"line\">[javadm@instance-2 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>8.最终解决</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[javadm@localhost ~]$ podman system migrate</span><br><span class=\"line\">[javadm@localhost ~]$ podman info</span><br><span class=\"line\">host:</span><br><span class=\"line\">  BuildahVersion: 1.12.0-dev</span><br><span class=\"line\">  CgroupVersion: v1</span><br><span class=\"line\">  Conmon:</span><br><span class=\"line\">    package: conmon-2.0.6-1.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    path: /usr/bin/conmon</span><br><span class=\"line\">    version: &apos;conmon version 2.0.6, commit: 2721f230f94894671f141762bd0d1af2fb263239&apos;</span><br><span class=\"line\">  Distribution:</span><br><span class=\"line\">    distribution: &apos;&quot;centos&quot;&apos;</span><br><span class=\"line\">    version: &quot;8&quot;</span><br><span class=\"line\">  IDMappings:</span><br><span class=\"line\">    gidmap:</span><br><span class=\"line\">    - container_id: 0</span><br><span class=\"line\">      host_id: 400001528</span><br><span class=\"line\">      size: 1</span><br><span class=\"line\">    - container_id: 1</span><br><span class=\"line\">      host_id: 410000000</span><br><span class=\"line\">      size: 500000000</span><br><span class=\"line\">    uidmap:</span><br><span class=\"line\">    - container_id: 0</span><br><span class=\"line\">      host_id: 300005526</span><br><span class=\"line\">      size: 1</span><br><span class=\"line\">    - container_id: 1</span><br><span class=\"line\">      host_id: 410000000</span><br><span class=\"line\">      size: 500000000</span><br><span class=\"line\">  MemFree: 61030400</span><br><span class=\"line\">  MemTotal: 500600832</span><br><span class=\"line\">  OCIRuntime:</span><br><span class=\"line\">    name: runc</span><br><span class=\"line\">    package: runc-1.0.0-64.rc9.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    path: /usr/bin/runc</span><br><span class=\"line\">    version: &apos;runc version spec: 1.0.1-dev&apos;</span><br><span class=\"line\">  SwapFree: 2124136448</span><br><span class=\"line\">  SwapTotal: 2147479552</span><br><span class=\"line\">  arch: amd64</span><br><span class=\"line\">  cpus: 1</span><br><span class=\"line\">  eventlogger: file</span><br><span class=\"line\">  hostname: localhost.localdomain</span><br><span class=\"line\">  kernel: 4.18.0-80.el8.x86_64</span><br><span class=\"line\">  os: linux</span><br><span class=\"line\">  rootless: true</span><br><span class=\"line\">  slirp4netns:</span><br><span class=\"line\">    Executable: /usr/bin/slirp4netns</span><br><span class=\"line\">    Package: slirp4netns-0.4.2-3.git21fdece.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">    Version: |-</span><br><span class=\"line\">      slirp4netns version 0.4.2+dev</span><br><span class=\"line\">      commit: 21fdece2737dc24ffa3f01a341b8a6854f8b13b4</span><br><span class=\"line\">  uptime: 16m 24.88s</span><br><span class=\"line\">registries:</span><br><span class=\"line\">  blocked: null</span><br><span class=\"line\">  insecure: null</span><br><span class=\"line\">  search:</span><br><span class=\"line\">  - registry.access.redhat.com</span><br><span class=\"line\">  - registry.fedoraproject.org</span><br><span class=\"line\">  - registry.centos.org</span><br><span class=\"line\">  - docker.io</span><br><span class=\"line\">store:</span><br><span class=\"line\">  ConfigFile: /home/javadm/.config/containers/storage.conf</span><br><span class=\"line\">  ContainerStore:</span><br><span class=\"line\">    number: 0</span><br><span class=\"line\">  GraphDriverName: overlay</span><br><span class=\"line\">  GraphOptions:</span><br><span class=\"line\">    overlay.mount_program:</span><br><span class=\"line\">      Executable: /usr/bin/fuse-overlayfs</span><br><span class=\"line\">      Package: fuse-overlayfs-0.7.2-5.module_el8.1.0+298+41f9343a.x86_64</span><br><span class=\"line\">      Version: |-</span><br><span class=\"line\">        fuse-overlayfs: version 0.7.2</span><br><span class=\"line\">        FUSE library version 3.2.1</span><br><span class=\"line\">        using FUSE kernel interface version 7.26</span><br><span class=\"line\">  GraphRoot: /home/javadm/.local/share/containers/storage</span><br><span class=\"line\">  GraphStatus:</span><br><span class=\"line\">    Backing Filesystem: xfs</span><br><span class=\"line\">    Native Overlay Diff: &quot;false&quot;</span><br><span class=\"line\">    Supports d_type: &quot;true&quot;</span><br><span class=\"line\">    Using metacopy: &quot;false&quot;</span><br><span class=\"line\">  ImageStore:</span><br><span class=\"line\">    number: 0</span><br><span class=\"line\">  RunRoot: /tmp/run-300005526</span><br><span class=\"line\">  VolumePath: /home/javadm/.local/share/containers/storage/volumes</span><br><span class=\"line\">  </span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$  docker pull ubuntu</span><br><span class=\"line\">Trying to pull registry.access.redhat.com/ubuntu...</span><br><span class=\"line\">  name unknown: Repo not found</span><br><span class=\"line\">Trying to pull registry.fedoraproject.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull registry.centos.org/ubuntu...</span><br><span class=\"line\">  manifest unknown: manifest unknown</span><br><span class=\"line\">Trying to pull docker.io/library/ubuntu...</span><br><span class=\"line\">Getting image source signatures</span><br><span class=\"line\">Copying blob fee5db0ff82f skipped: already exists</span><br><span class=\"line\">Copying blob fc878cd0a91c skipped: already exists</span><br><span class=\"line\">Copying blob 6154df8ff988 skipped: already exists</span><br><span class=\"line\">Copying blob d51af753c3d3 skipped: already exists</span><br><span class=\"line\">Copying config 1d622ef86b done</span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">1d622ef86b138c7e96d4f797bf5e4baca3249f030c575b9337638594f2b63f01</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ docker image list</span><br><span class=\"line\">REPOSITORY                   TAG      IMAGE ID       CREATED        SIZE</span><br><span class=\"line\">docker.io/library/ubuntu     latest   1d622ef86b13   33 hours ago   76.3 MB</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-总结问题\"><a href=\"#3-总结问题\" class=\"headerlink\" title=\"3.总结问题\"></a>3.总结问题</h2><p>经过重复测试后，发现解决这种问题还是要先解决namespace分配的问题，正确的步骤应该这样。</p>\n<p><strong>3.1检查现有用户的UID和GID，并且找出最大的ID。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/passwd|awk -F &apos;:&apos; &apos;&#123;print $3,$4&#125;&apos;|sort</span><br><span class=\"line\">0 0</span><br><span class=\"line\">1 1</span><br><span class=\"line\">11 0</span><br><span class=\"line\">12 100</span><br><span class=\"line\">14 50</span><br><span class=\"line\">193 193</span><br><span class=\"line\">2 2</span><br><span class=\"line\">28 28</span><br><span class=\"line\">300005526 400001528</span><br><span class=\"line\">3 4</span><br><span class=\"line\">4 7</span><br><span class=\"line\">5 0</span><br><span class=\"line\">59 59</span><br><span class=\"line\">6 0</span><br><span class=\"line\">65534 65534</span><br><span class=\"line\">7 0</span><br><span class=\"line\">72 72</span><br><span class=\"line\">74 74</span><br><span class=\"line\">8 12</span><br><span class=\"line\">81 81</span><br><span class=\"line\">93 93</span><br><span class=\"line\">992 988</span><br><span class=\"line\">993 989</span><br><span class=\"line\">994 990</span><br><span class=\"line\">995 992</span><br><span class=\"line\">996 993</span><br><span class=\"line\">997 994</span><br><span class=\"line\">998 996</span><br><span class=\"line\">999 997</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ cat /etc/group|awk -F &apos;:&apos; &apos;&#123;print $3&#125;&apos;|sort</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">10</span><br><span class=\"line\">100</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">15</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">190</span><br><span class=\"line\">193</span><br><span class=\"line\">2</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">28</span><br><span class=\"line\">3</span><br><span class=\"line\">33</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">39</span><br><span class=\"line\">4</span><br><span class=\"line\">400001528</span><br><span class=\"line\">5</span><br><span class=\"line\">50</span><br><span class=\"line\">54</span><br><span class=\"line\">59</span><br><span class=\"line\">6</span><br><span class=\"line\">63</span><br><span class=\"line\">65534</span><br><span class=\"line\">7</span><br><span class=\"line\">72</span><br><span class=\"line\">74</span><br><span class=\"line\">8</span><br><span class=\"line\">81</span><br><span class=\"line\">9</span><br><span class=\"line\">93</span><br><span class=\"line\">988</span><br><span class=\"line\">989</span><br><span class=\"line\">990</span><br><span class=\"line\">991</span><br><span class=\"line\">992</span><br><span class=\"line\">993</span><br><span class=\"line\">994</span><br><span class=\"line\">995</span><br><span class=\"line\">996</span><br><span class=\"line\">997</span><br><span class=\"line\">998</span><br><span class=\"line\">999</span><br><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>用户和组配置文件中最大的ID是400001528</p>\n</blockquote>\n<p><strong>3.2检查现有的/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[vagrant@localhost ~]$ cat /etc/subuid</span><br><span class=\"line\">vagrant:100000:65536</span><br><span class=\"line\">[vagrant@localhost ~]$ cat /etc/subgid</span><br><span class=\"line\">vagrant:100000:65536</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>最大的ID是100000+65536=165536</p>\n</blockquote>\n<p><strong>3.3为javadm用户配置/etc/subuid和/etc/subgid</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subuid</span><br><span class=\"line\">[javadm@localhost ~]$ echo javadm:410000000:500000000 &gt;&gt; /etc/subgid</span><br><span class=\"line\">[javadm@localhost ~]$ podman system migrate</span><br><span class=\"line\">[javadm@localhost ~]$ podman info</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>子用户使用的subuid初始值应该超出现有被使用的范围，之前找到的最大值是400001528。所以这里我们从410000000开始，最后一位是计数器设置要大于容器内用户的UID/GID，这里设置500000000。</p>\n</blockquote>\n<p><strong>3.4我们再来看下官方文档的说明：</strong><br>Upgrade to rootless containers<br>If you have upgraded from RHEL 7, you must configure subuid and subgid values manually for any existing user you want to be able to use rootless podman.</p>\n<p>Using an existing user name and group name (for example, jill), set the range of accessible user and group IDs that can be used for their containers. Here are a couple of warnings:</p>\n<p>Don’t include the rootless user’s UID and GID in these ranges<br>If you set multiple rootless container users, use unique ranges for each user<br>We recommend 65536 UIDs and GIDs for maximum compatibility with existing container images, but the number can be reduced<br>Never use UIDs or GIDs under 1000 or reuse UIDs or GIDs from existing user accounts (which, by default, start at 1000)</p>\n<p>Here is an example:</p>\n<p><code># echo &quot;jill:165537:65536&quot; &gt;&gt; /etc/subuid</code><br><code># echo &quot;jill:165537:65536&quot; &gt;&gt; /etc/subgid</code><br>The user/group jill is now allocated 65535 user and group IDs, ranging from 165537-231072. That user should be able to begin running commands to work with containers now.</p>\n<p><strong>3.5容器启动后验证uidmap</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[javadm@iZj6cdyw9ivwn9a3j8q0nzZ ~]$ podman unshare cat /proc/self/uid_map</span><br><span class=\"line\">         0  300005526          1</span><br><span class=\"line\">         1  410000000  500000000</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>容器中的用户uid 1对应宿主机的410000000，uid 2对应宿主机410000000-1+2，容器中的应用应用uid 300005526，对应宿主机410000000-1+300005526。以此类推。容器中最大用户ID不能超过500000000，符合我们的预期，验证通过。</p>\n</blockquote>\n<p><strong>参考资料</strong><br>From Docker To Podman <a href=\"http://www.ranta.ch/posts/FromDockerToPodman/\" target=\"_blank\" rel=\"noopener\">link</a><br>Why can’t rootless Podman pull my image <a href=\"https://www.redhat.com/sysadmin/rootless-podman\" target=\"_blank\" rel=\"noopener\">link</a><br>there might not be enough IDs available in the namespace (system migrate doesn’t work1)  <a href=\"https://github.com/containers/libpod/issues/4921\" target=\"_blank\" rel=\"noopener\">link</a><br>Rootless Podman on CentOS <a href=\"http://blog.zencoffee.org/2020/02/rootless-podman-on-centos/\" target=\"_blank\" rel=\"noopener\">link</a><br>Running rootless Podman as a non-root user <a href=\"https://www.redhat.com/sysadmin/rootless-podman-makes-sense\" target=\"_blank\" rel=\"noopener\">link</a><br>start to use podman <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/building_running_and_managing_containers/starting-with-containers_building-running-and-managing-containers\" target=\"_blank\" rel=\"noopener\">link</a></p>"},{"title":"jenkins之-pipeline基础知识","date":"2020-04-05T22:55:08.000Z","_content":"\n在讲过了jenkins的简单使用后，我们今天来讲讲jenkins是如何支持pipeline即代码的。\n<!--more-->\n\n# 1.pipeline的两种类型\n我们在jenkins编辑流水线pipeline时，有两种不同的语法样式，脚本式语法（scripts syntax )和申明式语法（declarative syntax)。\n## 1.1脚本式流水线\n这是Jenkins最开始实现的流水线即代码方式，类似于编程的方式实现，它依赖于groovy语言和结构，特别是对于错误检查和异常处理来说。\n```\nnode(\"cm-linux\") {\n    properties([pipelineTriggers([cron('H/10 * * * *')])])\n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n        '''\n    }\n    stage('Test'){\n      echo 'I am doing the Test'\n    }\n    stage('Deploy'){\n       try{\n         //执行部署任务\n         echo 'I am try to do the code deployment'\n       }\n       catch(error){\n         //捕捉错误并通知用户\n       }\n    }\n}\n```\n***node用于引用jenkins的节点，stage是jenkins任务的基本单位，可以包括各种jenkins指令。***\n\n## 1.2声明式流水线\n这是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，条例很清楚，很容里理解。\n```\npipeline{\n    agent { label 'cm-linux-003' }\n    stages{\n        stage('Build'){\n          steps{\n            echo 'start to do Build'\n            sh 'pwd'\n            sh 'whoami'\n          }\n        }\n        stage('Test'){\n              steps{\n                echo 'start to do Test'\n                sh 'pwd'\n                sh 'whoami'\n              }\n        }\n        stage('Deploy'){\n              steps{\n                echo 'start to do Deploy'\n                sh 'pwd'\n                sh 'whoami'\n              }\n        }\n    }\n}\n```\n***stages是一个集合，可以存储多个stage，每个stage内部有一个steps，每个steps里有好多步骤。***\n\n# 2.理解pipeline步骤语法\npipeline每个步骤，会执行一个命令。Jenkins中的步骤总是希望每个参数对应一个名称。每个命令如果不用太多的参数，可以使用简化版，如果有较多参数则需要使用完整版。\n例如，这是一个简化版的步骤。\n```\nsh 'whoami\ngit 'https://github.com/byygyy/ansible-examples.git''\n```\n例如，这个是一个完整版示例。\n```\nsh([script:'whoami'])\ngit([branch:'master',url:'https://github.com/byygyy/ansible-examples.git'])\n```\n\n# 3.理解pipeline参数\n## 3.1使用parameters指令\n脚本式：\n```\nnode(\"cm-linux\") {\n    properties([pipelineTriggers([cron('H/10 * * * *')])])\n    \n    parameters{\n      string(name: 'USERID', defaultValue:'',description: 'input or select your userid')\n    }\n    \n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n          ls -alh\n          pwd\n          whoami\n        '''\n        git 'https://github.com/byygyy/ansible-examples.git'\n    }\n}\n```\n声明式：\n```\npipeline{\n    agent { label 'cm-linux-003' }\n\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n    }\n    \n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n        stage('Test'){\n              steps{\n                echo 'start to do Test'\n                sh 'whoami'\n                git([branch:'master',url:'https://github.com/byygyy/ansible-examples.git'])\n              }\n        }\n    }\n}\n```\n\n## 3.2使用properties定义参数\n脚本式：\n```\nnode(\"cm-linux\") {    \n    properties([\n      parameters([\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n        string(name:'USERNAME', defaultValue:'', description:'input or select your username'),\n      ])\n    ])\n\n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n          ls -alh\n          pwd\n          whoami\n        '''\n        git 'https://github.com/byygyy/ansible-examples.git'\n    }\n}\n```\n\n# 4.pipeline执行流程\n## 4.1 pipeline触发任务\n### 4.1.1 脚本式pipeline触发任务\n如果是脚本式pipeline，可以在脚本中指定一个properties代码块（通常在流水线开始前）来定义触发条件，这里设置的内容将和web界面合并处理，并且web页面优先级高，例如：\n```\nnode(\"cm-linux\") {\n    properties([\n      pipelineTriggers([cron('H/10 * * * *')])\n      ])\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n如果还有其他的properties代码块，应该合并到一起写，例如：\n```\nnode(\"cm-linux\") {\n    properties([\n      pipelineTriggers([cron('H/10 * * * *')]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name'),\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n        string(name:'USERNAME', defaultValue:'', description:'input or select your username'),\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n### 4.1.2 声明式pipeline触发任务\n如果式声明式流水线，可以使用triggers指令定义一个流水线的触发任务。\n```\npipeline{\n    agent { label 'cm-linux' }\n    triggers{ cron('H/10 * * * *') }\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n      string(name: 'USENAME2', defaultValue:'',description: 'input or select your username')\n    }\n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n    }\n}\n```\n***声明式pipline，同一个指定内部每条命令是独立的一样，不用加什么分隔符。***\n\n## 4.2 githu钩子触发器触发jenkins GitSCM轮询\n仅支持脚本式pipeline，当piepine配置的github代码发生push提交后，会触发这个pipeline的build操作。\n```\nnode(\"cm-linux\") {\n      properties([\n        pipelineTriggers([\n            githubPush(),\n        ]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name'),\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n## 4.3 SCM轮询\n这个是标准的功能，pipeline会周期性地扫描源码版本控制系统的变更，当发现任何更新，任务就会处理这些变化。\n\nSCM轮询使用与“周期性构建”相同的jenkins core语法指令，脚本式语法如下：\n```\nnode(\"cm-linux\") {\n      properties([\n        pipelineTriggers([\n            pollSCM('*/11 * * * *'),\n        ]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name')\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n声明式语法如下：\n```\npipeline{\n    agent { label 'cm-linux' }\n    triggers{ \n      pollSCM('*/11 * * * *')\n    }\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n      string(name: 'USENAME2', defaultValue:'',description: 'input or select your username')\n    }\n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n    }\n}\n```\n\n## 4.4 远程调用构建任务\n详见: [https://blog.csdn.net/byygyy/article/details/105259356](https://blog.csdn.net/byygyy/article/details/105259356).\n\n\n","source":"_posts/jenkins/jenkins_base.md","raw":"---\ntitle: jenkins之-pipeline基础知识\ndate: 2020-04-05 22:55:08\ntags: pipeline\ncategories: jenkins\n---\n\n在讲过了jenkins的简单使用后，我们今天来讲讲jenkins是如何支持pipeline即代码的。\n<!--more-->\n\n# 1.pipeline的两种类型\n我们在jenkins编辑流水线pipeline时，有两种不同的语法样式，脚本式语法（scripts syntax )和申明式语法（declarative syntax)。\n## 1.1脚本式流水线\n这是Jenkins最开始实现的流水线即代码方式，类似于编程的方式实现，它依赖于groovy语言和结构，特别是对于错误检查和异常处理来说。\n```\nnode(\"cm-linux\") {\n    properties([pipelineTriggers([cron('H/10 * * * *')])])\n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n        '''\n    }\n    stage('Test'){\n      echo 'I am doing the Test'\n    }\n    stage('Deploy'){\n       try{\n         //执行部署任务\n         echo 'I am try to do the code deployment'\n       }\n       catch(error){\n         //捕捉错误并通知用户\n       }\n    }\n}\n```\n***node用于引用jenkins的节点，stage是jenkins任务的基本单位，可以包括各种jenkins指令。***\n\n## 1.2声明式流水线\n这是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，条例很清楚，很容里理解。\n```\npipeline{\n    agent { label 'cm-linux-003' }\n    stages{\n        stage('Build'){\n          steps{\n            echo 'start to do Build'\n            sh 'pwd'\n            sh 'whoami'\n          }\n        }\n        stage('Test'){\n              steps{\n                echo 'start to do Test'\n                sh 'pwd'\n                sh 'whoami'\n              }\n        }\n        stage('Deploy'){\n              steps{\n                echo 'start to do Deploy'\n                sh 'pwd'\n                sh 'whoami'\n              }\n        }\n    }\n}\n```\n***stages是一个集合，可以存储多个stage，每个stage内部有一个steps，每个steps里有好多步骤。***\n\n# 2.理解pipeline步骤语法\npipeline每个步骤，会执行一个命令。Jenkins中的步骤总是希望每个参数对应一个名称。每个命令如果不用太多的参数，可以使用简化版，如果有较多参数则需要使用完整版。\n例如，这是一个简化版的步骤。\n```\nsh 'whoami\ngit 'https://github.com/byygyy/ansible-examples.git''\n```\n例如，这个是一个完整版示例。\n```\nsh([script:'whoami'])\ngit([branch:'master',url:'https://github.com/byygyy/ansible-examples.git'])\n```\n\n# 3.理解pipeline参数\n## 3.1使用parameters指令\n脚本式：\n```\nnode(\"cm-linux\") {\n    properties([pipelineTriggers([cron('H/10 * * * *')])])\n    \n    parameters{\n      string(name: 'USERID', defaultValue:'',description: 'input or select your userid')\n    }\n    \n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n          ls -alh\n          pwd\n          whoami\n        '''\n        git 'https://github.com/byygyy/ansible-examples.git'\n    }\n}\n```\n声明式：\n```\npipeline{\n    agent { label 'cm-linux-003' }\n\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n    }\n    \n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n        stage('Test'){\n              steps{\n                echo 'start to do Test'\n                sh 'whoami'\n                git([branch:'master',url:'https://github.com/byygyy/ansible-examples.git'])\n              }\n        }\n    }\n}\n```\n\n## 3.2使用properties定义参数\n脚本式：\n```\nnode(\"cm-linux\") {    \n    properties([\n      parameters([\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n        string(name:'USERNAME', defaultValue:'', description:'input or select your username'),\n      ])\n    ])\n\n    stage('Build'){\n        echo 'I am doing the build' \n        sh 'echo \"hello world\"'\n        sh '''\n          echo \"multiline shell step works too\"\n          ls -alh\n          pwd\n          whoami\n        '''\n        git 'https://github.com/byygyy/ansible-examples.git'\n    }\n}\n```\n\n# 4.pipeline执行流程\n## 4.1 pipeline触发任务\n### 4.1.1 脚本式pipeline触发任务\n如果是脚本式pipeline，可以在脚本中指定一个properties代码块（通常在流水线开始前）来定义触发条件，这里设置的内容将和web界面合并处理，并且web页面优先级高，例如：\n```\nnode(\"cm-linux\") {\n    properties([\n      pipelineTriggers([cron('H/10 * * * *')])\n      ])\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n如果还有其他的properties代码块，应该合并到一起写，例如：\n```\nnode(\"cm-linux\") {\n    properties([\n      pipelineTriggers([cron('H/10 * * * *')]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name'),\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n        string(name:'USERNAME', defaultValue:'', description:'input or select your username'),\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n### 4.1.2 声明式pipeline触发任务\n如果式声明式流水线，可以使用triggers指令定义一个流水线的触发任务。\n```\npipeline{\n    agent { label 'cm-linux' }\n    triggers{ cron('H/10 * * * *') }\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n      string(name: 'USENAME2', defaultValue:'',description: 'input or select your username')\n    }\n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n    }\n}\n```\n***声明式pipline，同一个指定内部每条命令是独立的一样，不用加什么分隔符。***\n\n## 4.2 githu钩子触发器触发jenkins GitSCM轮询\n仅支持脚本式pipeline，当piepine配置的github代码发生push提交后，会触发这个pipeline的build操作。\n```\nnode(\"cm-linux\") {\n      properties([\n        pipelineTriggers([\n            githubPush(),\n        ]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name'),\n        string(name:'USERID', defaultValue:'', description:'input or select your userid'),\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n## 4.3 SCM轮询\n这个是标准的功能，pipeline会周期性地扫描源码版本控制系统的变更，当发现任何更新，任务就会处理这些变化。\n\nSCM轮询使用与“周期性构建”相同的jenkins core语法指令，脚本式语法如下：\n```\nnode(\"cm-linux\") {\n      properties([\n        pipelineTriggers([\n            pollSCM('*/11 * * * *'),\n        ]),\n      parameters([\n        string(name:'NODENAME', defaultValue:'cm-linux', description:'input the node name')\n      ])\n    ])\n\n    stage('Build'){\n      echo 'I am doing the Test'\n    }\n}\n```\n\n声明式语法如下：\n```\npipeline{\n    agent { label 'cm-linux' }\n    triggers{ \n      pollSCM('*/11 * * * *')\n    }\n    parameters{\n      string(name: 'USERID2', defaultValue:'',description: 'input or select your userid')\n      string(name: 'USENAME2', defaultValue:'',description: 'input or select your username')\n    }\n    stages{\n        stage('Build'){\n            steps{\n              echo 'start to do Build'\n              sh 'whoami'\n              git 'https://github.com/byygyy/ansible-examples.git'\n            }\n        }\n    }\n}\n```\n\n## 4.4 远程调用构建任务\n详见: [https://blog.csdn.net/byygyy/article/details/105259356](https://blog.csdn.net/byygyy/article/details/105259356).\n\n\n","slug":"jenkins/jenkins_base","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxderm00290en7vwdpdjl9","content":"<p>在讲过了jenkins的简单使用后，我们今天来讲讲jenkins是如何支持pipeline即代码的。<br><a id=\"more\"></a></p>\n<h1 id=\"1-pipeline的两种类型\"><a href=\"#1-pipeline的两种类型\" class=\"headerlink\" title=\"1.pipeline的两种类型\"></a>1.pipeline的两种类型</h1><p>我们在jenkins编辑流水线pipeline时，有两种不同的语法样式，脚本式语法（scripts syntax )和申明式语法（declarative syntax)。</p>\n<h2 id=\"1-1脚本式流水线\"><a href=\"#1-1脚本式流水线\" class=\"headerlink\" title=\"1.1脚本式流水线\"></a>1.1脚本式流水线</h2><p>这是Jenkins最开始实现的流水线即代码方式，类似于编程的方式实现，它依赖于groovy语言和结构，特别是对于错误检查和异常处理来说。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])])</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">       try&#123;</span><br><span class=\"line\">         //执行部署任务</span><br><span class=\"line\">         echo &apos;I am try to do the code deployment&apos;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       catch(error)&#123;</span><br><span class=\"line\">         //捕捉错误并通知用户</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>node用于引用jenkins的节点，stage是jenkins任务的基本单位，可以包括各种jenkins指令。</em></strong></p>\n<h2 id=\"1-2声明式流水线\"><a href=\"#1-2声明式流水线\" class=\"headerlink\" title=\"1.2声明式流水线\"></a>1.2声明式流水线</h2><p>这是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，条例很清楚，很容里理解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux-003&apos; &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">          steps&#123;</span><br><span class=\"line\">            echo &apos;start to do Build&apos;</span><br><span class=\"line\">            sh &apos;pwd&apos;</span><br><span class=\"line\">            sh &apos;whoami&apos;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Test&apos;</span><br><span class=\"line\">                sh &apos;pwd&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Deploy&apos;</span><br><span class=\"line\">                sh &apos;pwd&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>stages是一个集合，可以存储多个stage，每个stage内部有一个steps，每个steps里有好多步骤。</em></strong></p>\n<h1 id=\"2-理解pipeline步骤语法\"><a href=\"#2-理解pipeline步骤语法\" class=\"headerlink\" title=\"2.理解pipeline步骤语法\"></a>2.理解pipeline步骤语法</h1><p>pipeline每个步骤，会执行一个命令。Jenkins中的步骤总是希望每个参数对应一个名称。每个命令如果不用太多的参数，可以使用简化版，如果有较多参数则需要使用完整版。<br>例如，这是一个简化版的步骤。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh &apos;whoami</span><br><span class=\"line\">git &apos;https://github.com/byygyy/ansible-examples.git&apos;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>例如，这个是一个完整版示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh([script:&apos;whoami&apos;])</span><br><span class=\"line\">git([branch:&apos;master&apos;,url:&apos;https://github.com/byygyy/ansible-examples.git&apos;])</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-理解pipeline参数\"><a href=\"#3-理解pipeline参数\" class=\"headerlink\" title=\"3.理解pipeline参数\"></a>3.理解pipeline参数</h1><h2 id=\"3-1使用parameters指令\"><a href=\"#3-1使用parameters指令\" class=\"headerlink\" title=\"3.1使用parameters指令\"></a>3.1使用parameters指令</h2><p>脚本式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])])</span><br><span class=\"line\">    </span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">          ls -alh</span><br><span class=\"line\">          pwd</span><br><span class=\"line\">          whoami</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux-003&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Test&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">                git([branch:&apos;master&apos;,url:&apos;https://github.com/byygyy/ansible-examples.git&apos;])</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2使用properties定义参数\"><a href=\"#3-2使用properties定义参数\" class=\"headerlink\" title=\"3.2使用properties定义参数\"></a>3.2使用properties定义参数</h2><p>脚本式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;    </span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">        string(name:&apos;USERNAME&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your username&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">          ls -alh</span><br><span class=\"line\">          pwd</span><br><span class=\"line\">          whoami</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-pipeline执行流程\"><a href=\"#4-pipeline执行流程\" class=\"headerlink\" title=\"4.pipeline执行流程\"></a>4.pipeline执行流程</h1><h2 id=\"4-1-pipeline触发任务\"><a href=\"#4-1-pipeline触发任务\" class=\"headerlink\" title=\"4.1 pipeline触发任务\"></a>4.1 pipeline触发任务</h2><h3 id=\"4-1-1-脚本式pipeline触发任务\"><a href=\"#4-1-1-脚本式pipeline触发任务\" class=\"headerlink\" title=\"4.1.1 脚本式pipeline触发任务\"></a>4.1.1 脚本式pipeline触发任务</h3><p>如果是脚本式pipeline，可以在脚本中指定一个properties代码块（通常在流水线开始前）来定义触发条件，这里设置的内容将和web界面合并处理，并且web页面优先级高，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果还有其他的properties代码块，应该合并到一起写，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      pipelineTriggers([cron(&apos;H/10 * * * *&apos;)]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;),</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">        string(name:&apos;USERNAME&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your username&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-1-2-声明式pipeline触发任务\"><a href=\"#4-1-2-声明式pipeline触发任务\" class=\"headerlink\" title=\"4.1.2 声明式pipeline触发任务\"></a>4.1.2 声明式pipeline触发任务</h3><p>如果式声明式流水线，可以使用triggers指令定义一个流水线的触发任务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux&apos; &#125;</span><br><span class=\"line\">    triggers&#123; cron(&apos;H/10 * * * *&apos;) &#125;</span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">      string(name: &apos;USENAME2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your username&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>声明式pipline，同一个指定内部每条命令是独立的一样，不用加什么分隔符。</em></strong></p>\n<h2 id=\"4-2-githu钩子触发器触发jenkins-GitSCM轮询\"><a href=\"#4-2-githu钩子触发器触发jenkins-GitSCM轮询\" class=\"headerlink\" title=\"4.2 githu钩子触发器触发jenkins GitSCM轮询\"></a>4.2 githu钩子触发器触发jenkins GitSCM轮询</h2><p>仅支持脚本式pipeline，当piepine配置的github代码发生push提交后，会触发这个pipeline的build操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">      properties([</span><br><span class=\"line\">        pipelineTriggers([</span><br><span class=\"line\">            githubPush(),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;),</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-SCM轮询\"><a href=\"#4-3-SCM轮询\" class=\"headerlink\" title=\"4.3 SCM轮询\"></a>4.3 SCM轮询</h2><p>这个是标准的功能，pipeline会周期性地扫描源码版本控制系统的变更，当发现任何更新，任务就会处理这些变化。</p>\n<p>SCM轮询使用与“周期性构建”相同的jenkins core语法指令，脚本式语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">      properties([</span><br><span class=\"line\">        pipelineTriggers([</span><br><span class=\"line\">            pollSCM(&apos;*/11 * * * *&apos;),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明式语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux&apos; &#125;</span><br><span class=\"line\">    triggers&#123; </span><br><span class=\"line\">      pollSCM(&apos;*/11 * * * *&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">      string(name: &apos;USENAME2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your username&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-4-远程调用构建任务\"><a href=\"#4-4-远程调用构建任务\" class=\"headerlink\" title=\"4.4 远程调用构建任务\"></a>4.4 远程调用构建任务</h2><p>详见: <a href=\"https://blog.csdn.net/byygyy/article/details/105259356\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/byygyy/article/details/105259356</a>.</p>\n","site":{"data":{}},"excerpt":"<p>在讲过了jenkins的简单使用后，我们今天来讲讲jenkins是如何支持pipeline即代码的。<br>","more":"</p>\n<h1 id=\"1-pipeline的两种类型\"><a href=\"#1-pipeline的两种类型\" class=\"headerlink\" title=\"1.pipeline的两种类型\"></a>1.pipeline的两种类型</h1><p>我们在jenkins编辑流水线pipeline时，有两种不同的语法样式，脚本式语法（scripts syntax )和申明式语法（declarative syntax)。</p>\n<h2 id=\"1-1脚本式流水线\"><a href=\"#1-1脚本式流水线\" class=\"headerlink\" title=\"1.1脚本式流水线\"></a>1.1脚本式流水线</h2><p>这是Jenkins最开始实现的流水线即代码方式，类似于编程的方式实现，它依赖于groovy语言和结构，特别是对于错误检查和异常处理来说。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])])</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">       try&#123;</span><br><span class=\"line\">         //执行部署任务</span><br><span class=\"line\">         echo &apos;I am try to do the code deployment&apos;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       catch(error)&#123;</span><br><span class=\"line\">         //捕捉错误并通知用户</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>node用于引用jenkins的节点，stage是jenkins任务的基本单位，可以包括各种jenkins指令。</em></strong></p>\n<h2 id=\"1-2声明式流水线\"><a href=\"#1-2声明式流水线\" class=\"headerlink\" title=\"1.2声明式流水线\"></a>1.2声明式流水线</h2><p>这是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，条例很清楚，很容里理解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux-003&apos; &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">          steps&#123;</span><br><span class=\"line\">            echo &apos;start to do Build&apos;</span><br><span class=\"line\">            sh &apos;pwd&apos;</span><br><span class=\"line\">            sh &apos;whoami&apos;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Test&apos;</span><br><span class=\"line\">                sh &apos;pwd&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Deploy&apos;</span><br><span class=\"line\">                sh &apos;pwd&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>stages是一个集合，可以存储多个stage，每个stage内部有一个steps，每个steps里有好多步骤。</em></strong></p>\n<h1 id=\"2-理解pipeline步骤语法\"><a href=\"#2-理解pipeline步骤语法\" class=\"headerlink\" title=\"2.理解pipeline步骤语法\"></a>2.理解pipeline步骤语法</h1><p>pipeline每个步骤，会执行一个命令。Jenkins中的步骤总是希望每个参数对应一个名称。每个命令如果不用太多的参数，可以使用简化版，如果有较多参数则需要使用完整版。<br>例如，这是一个简化版的步骤。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh &apos;whoami</span><br><span class=\"line\">git &apos;https://github.com/byygyy/ansible-examples.git&apos;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>例如，这个是一个完整版示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh([script:&apos;whoami&apos;])</span><br><span class=\"line\">git([branch:&apos;master&apos;,url:&apos;https://github.com/byygyy/ansible-examples.git&apos;])</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-理解pipeline参数\"><a href=\"#3-理解pipeline参数\" class=\"headerlink\" title=\"3.理解pipeline参数\"></a>3.理解pipeline参数</h1><h2 id=\"3-1使用parameters指令\"><a href=\"#3-1使用parameters指令\" class=\"headerlink\" title=\"3.1使用parameters指令\"></a>3.1使用parameters指令</h2><p>脚本式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])])</span><br><span class=\"line\">    </span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">          ls -alh</span><br><span class=\"line\">          pwd</span><br><span class=\"line\">          whoami</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux-003&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">              steps&#123;</span><br><span class=\"line\">                echo &apos;start to do Test&apos;</span><br><span class=\"line\">                sh &apos;whoami&apos;</span><br><span class=\"line\">                git([branch:&apos;master&apos;,url:&apos;https://github.com/byygyy/ansible-examples.git&apos;])</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-2使用properties定义参数\"><a href=\"#3-2使用properties定义参数\" class=\"headerlink\" title=\"3.2使用properties定义参数\"></a>3.2使用properties定义参数</h2><p>脚本式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;    </span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">        string(name:&apos;USERNAME&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your username&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">        echo &apos;I am doing the build&apos; </span><br><span class=\"line\">        sh &apos;echo &quot;hello world&quot;&apos;</span><br><span class=\"line\">        sh &apos;&apos;&apos;</span><br><span class=\"line\">          echo &quot;multiline shell step works too&quot;</span><br><span class=\"line\">          ls -alh</span><br><span class=\"line\">          pwd</span><br><span class=\"line\">          whoami</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-pipeline执行流程\"><a href=\"#4-pipeline执行流程\" class=\"headerlink\" title=\"4.pipeline执行流程\"></a>4.pipeline执行流程</h1><h2 id=\"4-1-pipeline触发任务\"><a href=\"#4-1-pipeline触发任务\" class=\"headerlink\" title=\"4.1 pipeline触发任务\"></a>4.1 pipeline触发任务</h2><h3 id=\"4-1-1-脚本式pipeline触发任务\"><a href=\"#4-1-1-脚本式pipeline触发任务\" class=\"headerlink\" title=\"4.1.1 脚本式pipeline触发任务\"></a>4.1.1 脚本式pipeline触发任务</h3><p>如果是脚本式pipeline，可以在脚本中指定一个properties代码块（通常在流水线开始前）来定义触发条件，这里设置的内容将和web界面合并处理，并且web页面优先级高，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      pipelineTriggers([cron(&apos;H/10 * * * *&apos;)])</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果还有其他的properties代码块，应该合并到一起写，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">    properties([</span><br><span class=\"line\">      pipelineTriggers([cron(&apos;H/10 * * * *&apos;)]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;),</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">        string(name:&apos;USERNAME&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your username&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-1-2-声明式pipeline触发任务\"><a href=\"#4-1-2-声明式pipeline触发任务\" class=\"headerlink\" title=\"4.1.2 声明式pipeline触发任务\"></a>4.1.2 声明式pipeline触发任务</h3><p>如果式声明式流水线，可以使用triggers指令定义一个流水线的触发任务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux&apos; &#125;</span><br><span class=\"line\">    triggers&#123; cron(&apos;H/10 * * * *&apos;) &#125;</span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">      string(name: &apos;USENAME2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your username&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>声明式pipline，同一个指定内部每条命令是独立的一样，不用加什么分隔符。</em></strong></p>\n<h2 id=\"4-2-githu钩子触发器触发jenkins-GitSCM轮询\"><a href=\"#4-2-githu钩子触发器触发jenkins-GitSCM轮询\" class=\"headerlink\" title=\"4.2 githu钩子触发器触发jenkins GitSCM轮询\"></a>4.2 githu钩子触发器触发jenkins GitSCM轮询</h2><p>仅支持脚本式pipeline，当piepine配置的github代码发生push提交后，会触发这个pipeline的build操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">      properties([</span><br><span class=\"line\">        pipelineTriggers([</span><br><span class=\"line\">            githubPush(),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;),</span><br><span class=\"line\">        string(name:&apos;USERID&apos;, defaultValue:&apos;&apos;, description:&apos;input or select your userid&apos;),</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-SCM轮询\"><a href=\"#4-3-SCM轮询\" class=\"headerlink\" title=\"4.3 SCM轮询\"></a>4.3 SCM轮询</h2><p>这个是标准的功能，pipeline会周期性地扫描源码版本控制系统的变更，当发现任何更新，任务就会处理这些变化。</p>\n<p>SCM轮询使用与“周期性构建”相同的jenkins core语法指令，脚本式语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node(&quot;cm-linux&quot;) &#123;</span><br><span class=\"line\">      properties([</span><br><span class=\"line\">        pipelineTriggers([</span><br><span class=\"line\">            pollSCM(&apos;*/11 * * * *&apos;),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      parameters([</span><br><span class=\"line\">        string(name:&apos;NODENAME&apos;, defaultValue:&apos;cm-linux&apos;, description:&apos;input the node name&apos;)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">    ])</span><br><span class=\"line\"></span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明式语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent &#123; label &apos;cm-linux&apos; &#125;</span><br><span class=\"line\">    triggers&#123; </span><br><span class=\"line\">      pollSCM(&apos;*/11 * * * *&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parameters&#123;</span><br><span class=\"line\">      string(name: &apos;USERID2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your userid&apos;)</span><br><span class=\"line\">      string(name: &apos;USENAME2&apos;, defaultValue:&apos;&apos;,description: &apos;input or select your username&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">            steps&#123;</span><br><span class=\"line\">              echo &apos;start to do Build&apos;</span><br><span class=\"line\">              sh &apos;whoami&apos;</span><br><span class=\"line\">              git &apos;https://github.com/byygyy/ansible-examples.git&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-4-远程调用构建任务\"><a href=\"#4-4-远程调用构建任务\" class=\"headerlink\" title=\"4.4 远程调用构建任务\"></a>4.4 远程调用构建任务</h2><p>详见: <a href=\"https://blog.csdn.net/byygyy/article/details/105259356\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/byygyy/article/details/105259356</a>.</p>"},{"title":"Linux文本处理命令-awk","date":"2020-03-03T23:08:08.000Z","_content":"\n**awk**其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。在比较复杂的shell脚本中经常用到，awk grep sed三个合起来，被俗称为shell三剑客。它是linux系统很强大的文本处理命令，并且方便生成各种报表，语法借鉴了C语言。awk同样支持处理文件和标准输入的内容。\n<!--more-->\n\n**example1** 分列显示文本文件内容, $0所有列，$1第一列，$2第二列\n```\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $0 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $1 }' awk.sh\nhello\nnihao\nbyby\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $2 }' awk.sh\nrobin\nhuanhuan\njoe\n```\n\n**example2** 分列显示标准输入文本\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk '{ print $0 }'\nroot       803     1  0 Feb28 ?        00:00:43 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot      6820  6216  0 23:21 pts/0    00:00:00 grep --color=auto python\nroot     19785     1  0 Feb29 ?        00:00:50 python proxyserver.py 11081\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk '{ print $2 }'\n803\n6828\n19785\n```\n\n**example3**  使用自定义分隔符分列显示文本，-F '='\n```\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $0 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\nname1=robin\nname2=joe\nage1=22\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $1 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\nname1\nname2\nage1\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $2 }' awk.sh\n\n\n\nrobin\njoe\n22\n```\n\n**example4** 分列后显示前N行,NR<=3\n```\n[root@aliyun-hk1 linux-shell-test]# awk  'NR<=3 { print $2 }' awk.sh\nrobin\nhuanhuan\njoe\n```\n\n**example5** 读取shell中变量，用于awk命令参数\n```\n[root@aliyun-hk1 linux-shell-test]# awk -v var=$split_char -F '=' 'NR<=6 { print $1 var }' awk.sh\nhello robin=\nnihao huanhuan=\nbyby joe=\nname1=\nname2=\nage1=\n```\n\n**example6** 拆分标准输入或者文件内容，并重新格式化\n```\n[root@aliyun-hk1 linux-shell-test]# echo -e 'line1=hello\\nline2=world'|awk -F '=' '{ print $1\": \"$2 }'\nline1: hello\nline2: world\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' 'NR>3 { print $1\": \"$2 }' awk.sh\nname1: robin\nname2: joe\nage1: 22\n```\n\n**example7** awk也算是一个编程语言，我们先把简单的、最常用的使用方式搞清除了，再来尝试高级的使用。\n```\n请打开后自行学习 https://awk.readthedocs.io/en/latest/index.html\n```\n\n","source":"_posts/linux/linux-awk.md","raw":"---\ntitle: Linux文本处理命令-awk\ndate: 2020-03-03 23:08:08\ntags: shell\ncategories: linux\n---\n\n**awk**其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。在比较复杂的shell脚本中经常用到，awk grep sed三个合起来，被俗称为shell三剑客。它是linux系统很强大的文本处理命令，并且方便生成各种报表，语法借鉴了C语言。awk同样支持处理文件和标准输入的内容。\n<!--more-->\n\n**example1** 分列显示文本文件内容, $0所有列，$1第一列，$2第二列\n```\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $0 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $1 }' awk.sh\nhello\nnihao\nbyby\n[root@aliyun-hk1 linux-shell-test]# awk '{ print $2 }' awk.sh\nrobin\nhuanhuan\njoe\n```\n\n**example2** 分列显示标准输入文本\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk '{ print $0 }'\nroot       803     1  0 Feb28 ?        00:00:43 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot      6820  6216  0 23:21 pts/0    00:00:00 grep --color=auto python\nroot     19785     1  0 Feb29 ?        00:00:50 python proxyserver.py 11081\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk '{ print $2 }'\n803\n6828\n19785\n```\n\n**example3**  使用自定义分隔符分列显示文本，-F '='\n```\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $0 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\nname1=robin\nname2=joe\nage1=22\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $1 }' awk.sh\nhello robin\nnihao huanhuan\nbyby joe\nname1\nname2\nage1\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' '{print $2 }' awk.sh\n\n\n\nrobin\njoe\n22\n```\n\n**example4** 分列后显示前N行,NR<=3\n```\n[root@aliyun-hk1 linux-shell-test]# awk  'NR<=3 { print $2 }' awk.sh\nrobin\nhuanhuan\njoe\n```\n\n**example5** 读取shell中变量，用于awk命令参数\n```\n[root@aliyun-hk1 linux-shell-test]# awk -v var=$split_char -F '=' 'NR<=6 { print $1 var }' awk.sh\nhello robin=\nnihao huanhuan=\nbyby joe=\nname1=\nname2=\nage1=\n```\n\n**example6** 拆分标准输入或者文件内容，并重新格式化\n```\n[root@aliyun-hk1 linux-shell-test]# echo -e 'line1=hello\\nline2=world'|awk -F '=' '{ print $1\": \"$2 }'\nline1: hello\nline2: world\n[root@aliyun-hk1 linux-shell-test]# awk -F '=' 'NR>3 { print $1\": \"$2 }' awk.sh\nname1: robin\nname2: joe\nage1: 22\n```\n\n**example7** awk也算是一个编程语言，我们先把简单的、最常用的使用方式搞清除了，再来尝试高级的使用。\n```\n请打开后自行学习 https://awk.readthedocs.io/en/latest/index.html\n```\n\n","slug":"linux/linux-awk","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxderq002d0en73yvmciz0","content":"<p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。在比较复杂的shell脚本中经常用到，awk grep sed三个合起来，被俗称为shell三剑客。它是linux系统很强大的文本处理命令，并且方便生成各种报表，语法借鉴了C语言。awk同样支持处理文件和标准输入的内容。<br><a id=\"more\"></a></p>\n<p><strong>example1</strong> 分列显示文本文件内容, $0所有列，$1第一列，$2第二列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $0 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $1 &#125;&apos; awk.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">nihao</span><br><span class=\"line\">byby</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $2 &#125;&apos; awk.sh</span><br><span class=\"line\">robin</span><br><span class=\"line\">huanhuan</span><br><span class=\"line\">joe</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2</strong> 分列显示标准输入文本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk &apos;&#123; print $0 &#125;&apos;</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:43 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root      6820  6216  0 23:21 pts/0    00:00:00 grep --color=auto python</span><br><span class=\"line\">root     19785     1  0 Feb29 ?        00:00:50 python proxyserver.py 11081</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk &apos;&#123; print $2 &#125;&apos;</span><br><span class=\"line\">803</span><br><span class=\"line\">6828</span><br><span class=\"line\">19785</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3</strong>  使用自定义分隔符分列显示文本，-F ‘=’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $0 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">name1=robin</span><br><span class=\"line\">name2=joe</span><br><span class=\"line\">age1=22</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $1 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">name1</span><br><span class=\"line\">name2</span><br><span class=\"line\">age1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $2 &#125;&apos; awk.sh</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">robin</span><br><span class=\"line\">joe</span><br><span class=\"line\">22</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4</strong> 分列后显示前N行,NR&lt;=3<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk  &apos;NR&lt;=3 &#123; print $2 &#125;&apos; awk.sh</span><br><span class=\"line\">robin</span><br><span class=\"line\">huanhuan</span><br><span class=\"line\">joe</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5</strong> 读取shell中变量，用于awk命令参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -v var=$split_char -F &apos;=&apos; &apos;NR&lt;=6 &#123; print $1 var &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin=</span><br><span class=\"line\">nihao huanhuan=</span><br><span class=\"line\">byby joe=</span><br><span class=\"line\">name1=</span><br><span class=\"line\">name2=</span><br><span class=\"line\">age1=</span><br></pre></td></tr></table></figure></p>\n<p><strong>example6</strong> 拆分标准输入或者文件内容，并重新格式化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;line1=hello\\nline2=world&apos;|awk -F &apos;=&apos; &apos;&#123; print $1&quot;: &quot;$2 &#125;&apos;</span><br><span class=\"line\">line1: hello</span><br><span class=\"line\">line2: world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;NR&gt;3 &#123; print $1&quot;: &quot;$2 &#125;&apos; awk.sh</span><br><span class=\"line\">name1: robin</span><br><span class=\"line\">name2: joe</span><br><span class=\"line\">age1: 22</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7</strong> awk也算是一个编程语言，我们先把简单的、最常用的使用方式搞清除了，再来尝试高级的使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请打开后自行学习 https://awk.readthedocs.io/en/latest/index.html</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。在比较复杂的shell脚本中经常用到，awk grep sed三个合起来，被俗称为shell三剑客。它是linux系统很强大的文本处理命令，并且方便生成各种报表，语法借鉴了C语言。awk同样支持处理文件和标准输入的内容。<br>","more":"</p>\n<p><strong>example1</strong> 分列显示文本文件内容, $0所有列，$1第一列，$2第二列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $0 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $1 &#125;&apos; awk.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">nihao</span><br><span class=\"line\">byby</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk &apos;&#123; print $2 &#125;&apos; awk.sh</span><br><span class=\"line\">robin</span><br><span class=\"line\">huanhuan</span><br><span class=\"line\">joe</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2</strong> 分列显示标准输入文本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk &apos;&#123; print $0 &#125;&apos;</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:43 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root      6820  6216  0 23:21 pts/0    00:00:00 grep --color=auto python</span><br><span class=\"line\">root     19785     1  0 Feb29 ?        00:00:50 python proxyserver.py 11081</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python|awk &apos;&#123; print $2 &#125;&apos;</span><br><span class=\"line\">803</span><br><span class=\"line\">6828</span><br><span class=\"line\">19785</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3</strong>  使用自定义分隔符分列显示文本，-F ‘=’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $0 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">name1=robin</span><br><span class=\"line\">name2=joe</span><br><span class=\"line\">age1=22</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $1 &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin</span><br><span class=\"line\">nihao huanhuan</span><br><span class=\"line\">byby joe</span><br><span class=\"line\">name1</span><br><span class=\"line\">name2</span><br><span class=\"line\">age1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;&#123;print $2 &#125;&apos; awk.sh</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">robin</span><br><span class=\"line\">joe</span><br><span class=\"line\">22</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4</strong> 分列后显示前N行,NR&lt;=3<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk  &apos;NR&lt;=3 &#123; print $2 &#125;&apos; awk.sh</span><br><span class=\"line\">robin</span><br><span class=\"line\">huanhuan</span><br><span class=\"line\">joe</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5</strong> 读取shell中变量，用于awk命令参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -v var=$split_char -F &apos;=&apos; &apos;NR&lt;=6 &#123; print $1 var &#125;&apos; awk.sh</span><br><span class=\"line\">hello robin=</span><br><span class=\"line\">nihao huanhuan=</span><br><span class=\"line\">byby joe=</span><br><span class=\"line\">name1=</span><br><span class=\"line\">name2=</span><br><span class=\"line\">age1=</span><br></pre></td></tr></table></figure></p>\n<p><strong>example6</strong> 拆分标准输入或者文件内容，并重新格式化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;line1=hello\\nline2=world&apos;|awk -F &apos;=&apos; &apos;&#123; print $1&quot;: &quot;$2 &#125;&apos;</span><br><span class=\"line\">line1: hello</span><br><span class=\"line\">line2: world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# awk -F &apos;=&apos; &apos;NR&gt;3 &#123; print $1&quot;: &quot;$2 &#125;&apos; awk.sh</span><br><span class=\"line\">name1: robin</span><br><span class=\"line\">name2: joe</span><br><span class=\"line\">age1: 22</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7</strong> awk也算是一个编程语言，我们先把简单的、最常用的使用方式搞清除了，再来尝试高级的使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请打开后自行学习 https://awk.readthedocs.io/en/latest/index.html</span><br></pre></td></tr></table></figure></p>"},{"title":"jenkins之-创建第一个pipeline","date":"2020-04-01T08:08:08.000Z","_content":"\n从今天开始，我们来整体学习下jenkins相关内容。jenkins是一款用java开发的开源持续集成和持续交付工具，他也是实现Dev OPS的基础工具。\n<!--more-->\n\n# 1.什么是pipeline\n部署流水线（deployment pipeline）是指软件从原始code到用户这一过程的自动化表现形式，我们经常简称pipeline。jenkins2.x 开始已经支持了pipeline as code的模式，也就是说我们可以像写代码一样，去定义部署流水线的各种工作。\n\n# 2.在jenkins中使用pipeline\n## 2.1 pipeline支持的语法\n既然jenkins2.x已经支持了pipeline as code，那我们首先要简单了解下pipeline支持的语法。jenkins一开始考虑实现jenkins pipeline的时候，就考虑使用简单易用的groovy脚本语言去实现pipeline。在写脚本式的pipeline时，很像实在写groovy代码。\n```\nnode {\n    stage('Build'){\n      echo 'I am doing the build!'\n    }\n    stage('Test'){\n      echo 'I am doing the Test'\n    }\n    stage('Deploy'){\n       try{\n         //执行部署任务\n         echo 'I am try to do the code deployment'\n       }\n       catch(error){\n         //捕捉错误并通知用户\n       }\n    }\n}\n```\n\njenkins pipelien 还支持另外一种语法，申明式语法。\n```\npipeline{\n    agent any\n    stages{\n        stage('Build'){\n          steps{\n            echo 'hello world!'\n          }\n        }\n    }\n}\n```\n\n## 2.2 创建第一个pipeline\n要创建pipeline，首先需要jenkins已经安装了pipeline插件，笔者安装的jenkins默认已经安装了pipeline。\n```mermaid\nflowchat\nst=>start: 新建任务\ne=>end: 结束\nop=>operation: 流水线\ncond=>condition: 确认\nst->op->cond\ncond(yes)->e\n```\n\n默认情况下，流水线定义的默认值为pipeline scripts，我们输入示例。\n```\nnode {\n   echo 'Hello World'\n}\n```\n点击确认后，就到了pipeline的主页面，点击左侧的立即构建，就可以看到结果了。\n```\n控制台输出\nStarted by user robinhhli\nRunning in Durability level: MAX_SURVIVABILITY\n[Pipeline] Start of Pipeline\n[Pipeline] node\nRunning on Jenkins in /var/lib/jenkins/workspace/my fist pipeline\n[Pipeline] {\n[Pipeline] echo\nHello World\n[Pipeline] }\n[Pipeline] // node\n[Pipeline] End of Pipeline\nFinished: SUCCESS\n```\n\n## 2.3 从github拉取pipeline\n明日再续。","source":"_posts/jenkins/jenkins_hello_world.md","raw":"---\ntitle: jenkins之-创建第一个pipeline\ndate: 2020-04-01 08:08:08\ntags: jenkins\ncategories: jenkins\n---\n\n从今天开始，我们来整体学习下jenkins相关内容。jenkins是一款用java开发的开源持续集成和持续交付工具，他也是实现Dev OPS的基础工具。\n<!--more-->\n\n# 1.什么是pipeline\n部署流水线（deployment pipeline）是指软件从原始code到用户这一过程的自动化表现形式，我们经常简称pipeline。jenkins2.x 开始已经支持了pipeline as code的模式，也就是说我们可以像写代码一样，去定义部署流水线的各种工作。\n\n# 2.在jenkins中使用pipeline\n## 2.1 pipeline支持的语法\n既然jenkins2.x已经支持了pipeline as code，那我们首先要简单了解下pipeline支持的语法。jenkins一开始考虑实现jenkins pipeline的时候，就考虑使用简单易用的groovy脚本语言去实现pipeline。在写脚本式的pipeline时，很像实在写groovy代码。\n```\nnode {\n    stage('Build'){\n      echo 'I am doing the build!'\n    }\n    stage('Test'){\n      echo 'I am doing the Test'\n    }\n    stage('Deploy'){\n       try{\n         //执行部署任务\n         echo 'I am try to do the code deployment'\n       }\n       catch(error){\n         //捕捉错误并通知用户\n       }\n    }\n}\n```\n\njenkins pipelien 还支持另外一种语法，申明式语法。\n```\npipeline{\n    agent any\n    stages{\n        stage('Build'){\n          steps{\n            echo 'hello world!'\n          }\n        }\n    }\n}\n```\n\n## 2.2 创建第一个pipeline\n要创建pipeline，首先需要jenkins已经安装了pipeline插件，笔者安装的jenkins默认已经安装了pipeline。\n```mermaid\nflowchat\nst=>start: 新建任务\ne=>end: 结束\nop=>operation: 流水线\ncond=>condition: 确认\nst->op->cond\ncond(yes)->e\n```\n\n默认情况下，流水线定义的默认值为pipeline scripts，我们输入示例。\n```\nnode {\n   echo 'Hello World'\n}\n```\n点击确认后，就到了pipeline的主页面，点击左侧的立即构建，就可以看到结果了。\n```\n控制台输出\nStarted by user robinhhli\nRunning in Durability level: MAX_SURVIVABILITY\n[Pipeline] Start of Pipeline\n[Pipeline] node\nRunning on Jenkins in /var/lib/jenkins/workspace/my fist pipeline\n[Pipeline] {\n[Pipeline] echo\nHello World\n[Pipeline] }\n[Pipeline] // node\n[Pipeline] End of Pipeline\nFinished: SUCCESS\n```\n\n## 2.3 从github拉取pipeline\n明日再续。","slug":"jenkins/jenkins_hello_world","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxders002g0en73abl4g6w","content":"<p>从今天开始，我们来整体学习下jenkins相关内容。jenkins是一款用java开发的开源持续集成和持续交付工具，他也是实现Dev OPS的基础工具。<br><a id=\"more\"></a></p>\n<h1 id=\"1-什么是pipeline\"><a href=\"#1-什么是pipeline\" class=\"headerlink\" title=\"1.什么是pipeline\"></a>1.什么是pipeline</h1><p>部署流水线（deployment pipeline）是指软件从原始code到用户这一过程的自动化表现形式，我们经常简称pipeline。jenkins2.x 开始已经支持了pipeline as code的模式，也就是说我们可以像写代码一样，去定义部署流水线的各种工作。</p>\n<h1 id=\"2-在jenkins中使用pipeline\"><a href=\"#2-在jenkins中使用pipeline\" class=\"headerlink\" title=\"2.在jenkins中使用pipeline\"></a>2.在jenkins中使用pipeline</h1><h2 id=\"2-1-pipeline支持的语法\"><a href=\"#2-1-pipeline支持的语法\" class=\"headerlink\" title=\"2.1 pipeline支持的语法\"></a>2.1 pipeline支持的语法</h2><p>既然jenkins2.x已经支持了pipeline as code，那我们首先要简单了解下pipeline支持的语法。jenkins一开始考虑实现jenkins pipeline的时候，就考虑使用简单易用的groovy脚本语言去实现pipeline。在写脚本式的pipeline时，很像实在写groovy代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node &#123;</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the build!&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">       try&#123;</span><br><span class=\"line\">         //执行部署任务</span><br><span class=\"line\">         echo &apos;I am try to do the code deployment&apos;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       catch(error)&#123;</span><br><span class=\"line\">         //捕捉错误并通知用户</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jenkins pipelien 还支持另外一种语法，申明式语法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent any</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">          steps&#123;</span><br><span class=\"line\">            echo &apos;hello world!&apos;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-创建第一个pipeline\"><a href=\"#2-2-创建第一个pipeline\" class=\"headerlink\" title=\"2.2 创建第一个pipeline\"></a>2.2 创建第一个pipeline</h2><p>要创建pipeline，首先需要jenkins已经安装了pipeline插件，笔者安装的jenkins默认已经安装了pipeline。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchat</span><br><span class=\"line\">st=&gt;start: 新建任务</span><br><span class=\"line\">e=&gt;end: 结束</span><br><span class=\"line\">op=&gt;operation: 流水线</span><br><span class=\"line\">cond=&gt;condition: 确认</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，流水线定义的默认值为pipeline scripts，我们输入示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node &#123;</span><br><span class=\"line\">   echo &apos;Hello World&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>点击确认后，就到了pipeline的主页面，点击左侧的立即构建，就可以看到结果了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台输出</span><br><span class=\"line\">Started by user robinhhli</span><br><span class=\"line\">Running in Durability level: MAX_SURVIVABILITY</span><br><span class=\"line\">[Pipeline] Start of Pipeline</span><br><span class=\"line\">[Pipeline] node</span><br><span class=\"line\">Running on Jenkins in /var/lib/jenkins/workspace/my fist pipeline</span><br><span class=\"line\">[Pipeline] &#123;</span><br><span class=\"line\">[Pipeline] echo</span><br><span class=\"line\">Hello World</span><br><span class=\"line\">[Pipeline] &#125;</span><br><span class=\"line\">[Pipeline] // node</span><br><span class=\"line\">[Pipeline] End of Pipeline</span><br><span class=\"line\">Finished: SUCCESS</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-从github拉取pipeline\"><a href=\"#2-3-从github拉取pipeline\" class=\"headerlink\" title=\"2.3 从github拉取pipeline\"></a>2.3 从github拉取pipeline</h2><p>明日再续。</p>\n","site":{"data":{}},"excerpt":"<p>从今天开始，我们来整体学习下jenkins相关内容。jenkins是一款用java开发的开源持续集成和持续交付工具，他也是实现Dev OPS的基础工具。<br>","more":"</p>\n<h1 id=\"1-什么是pipeline\"><a href=\"#1-什么是pipeline\" class=\"headerlink\" title=\"1.什么是pipeline\"></a>1.什么是pipeline</h1><p>部署流水线（deployment pipeline）是指软件从原始code到用户这一过程的自动化表现形式，我们经常简称pipeline。jenkins2.x 开始已经支持了pipeline as code的模式，也就是说我们可以像写代码一样，去定义部署流水线的各种工作。</p>\n<h1 id=\"2-在jenkins中使用pipeline\"><a href=\"#2-在jenkins中使用pipeline\" class=\"headerlink\" title=\"2.在jenkins中使用pipeline\"></a>2.在jenkins中使用pipeline</h1><h2 id=\"2-1-pipeline支持的语法\"><a href=\"#2-1-pipeline支持的语法\" class=\"headerlink\" title=\"2.1 pipeline支持的语法\"></a>2.1 pipeline支持的语法</h2><p>既然jenkins2.x已经支持了pipeline as code，那我们首先要简单了解下pipeline支持的语法。jenkins一开始考虑实现jenkins pipeline的时候，就考虑使用简单易用的groovy脚本语言去实现pipeline。在写脚本式的pipeline时，很像实在写groovy代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node &#123;</span><br><span class=\"line\">    stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the build!&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Test&apos;)&#123;</span><br><span class=\"line\">      echo &apos;I am doing the Test&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stage(&apos;Deploy&apos;)&#123;</span><br><span class=\"line\">       try&#123;</span><br><span class=\"line\">         //执行部署任务</span><br><span class=\"line\">         echo &apos;I am try to do the code deployment&apos;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       catch(error)&#123;</span><br><span class=\"line\">         //捕捉错误并通知用户</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>jenkins pipelien 还支持另外一种语法，申明式语法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pipeline&#123;</span><br><span class=\"line\">    agent any</span><br><span class=\"line\">    stages&#123;</span><br><span class=\"line\">        stage(&apos;Build&apos;)&#123;</span><br><span class=\"line\">          steps&#123;</span><br><span class=\"line\">            echo &apos;hello world!&apos;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-创建第一个pipeline\"><a href=\"#2-2-创建第一个pipeline\" class=\"headerlink\" title=\"2.2 创建第一个pipeline\"></a>2.2 创建第一个pipeline</h2><p>要创建pipeline，首先需要jenkins已经安装了pipeline插件，笔者安装的jenkins默认已经安装了pipeline。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flowchat</span><br><span class=\"line\">st=&gt;start: 新建任务</span><br><span class=\"line\">e=&gt;end: 结束</span><br><span class=\"line\">op=&gt;operation: 流水线</span><br><span class=\"line\">cond=&gt;condition: 确认</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，流水线定义的默认值为pipeline scripts，我们输入示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node &#123;</span><br><span class=\"line\">   echo &apos;Hello World&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>点击确认后，就到了pipeline的主页面，点击左侧的立即构建，就可以看到结果了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">控制台输出</span><br><span class=\"line\">Started by user robinhhli</span><br><span class=\"line\">Running in Durability level: MAX_SURVIVABILITY</span><br><span class=\"line\">[Pipeline] Start of Pipeline</span><br><span class=\"line\">[Pipeline] node</span><br><span class=\"line\">Running on Jenkins in /var/lib/jenkins/workspace/my fist pipeline</span><br><span class=\"line\">[Pipeline] &#123;</span><br><span class=\"line\">[Pipeline] echo</span><br><span class=\"line\">Hello World</span><br><span class=\"line\">[Pipeline] &#125;</span><br><span class=\"line\">[Pipeline] // node</span><br><span class=\"line\">[Pipeline] End of Pipeline</span><br><span class=\"line\">Finished: SUCCESS</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-从github拉取pipeline\"><a href=\"#2-3-从github拉取pipeline\" class=\"headerlink\" title=\"2.3 从github拉取pipeline\"></a>2.3 从github拉取pipeline</h2><p>明日再续。</p>"},{"title":"Linux文本输出命令-echo","date":"2020-03-01T22:50:50.000Z","_content":"\n**echo** 在linux帮助文档的描述是显示一行文本，类似于python和java等编程语言中的print语句，实际上它的作用不仅仅如此。可以使用man echo查看详细的参数说明。\n<!--more-->\n\n**example1:** 显示一行文本，任何特殊字符都不会被转义\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\\nworld\nhellonworld\n[root@aliyun-hk1 linux-shell-test]# echo 'hello\\nworld'\nhello\\nworld\n[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example2:** 显示一行文本，不要输出末尾的换行符\n```\n[root@aliyun-hk1 linux-shell-test]# echo -n hello world\nhello world[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n```\n\n**example3:** 显示一行文本，启用反斜杠后面的转义字符\n```\n[root@aliyun-hk1 linux-shell-test]# echo -e 'hello\\nworld'\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# echo -e 'hello\\tworld'\nhello   world\n```\n\n**example4:** 显示一行文本，禁用反斜杠后面的转义字符，echo默认参数\n```\n[root@aliyun-hk1 linux-shell-test]# echo -E 'hello\\nworld'\nhello\\nworld\n[root@aliyun-hk1 linux-shell-test]# echo -E 'hello\\tworld'\nhello\\tworld\n```\n\n**example5:** echo与cat的差异对比，echo只用于输出文本，cat用于输出文件内容或者从标准输入中输出\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\nhello\n[root@aliyun-hk1 linux-shell-test]# cat hello\ncat: hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# echo /etc/hostname\n/etc/hostname\n[root@aliyun-hk1 linux-shell-test]# cat /etc/hostname\naliyun-hk1\n[root@aliyun-hk1 linux-shell-test]# echo hello|cat\nhello\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**examle6:** echo在自动化构建中的作用，例如我们可以将DB中返回的数据格式化成ansible需要的数据，通过with_lines 传入某个task并循环使用。在某些情况下，从网络、DB等方式获取的标准输出，可以通过echo结合awk和grep等实现结果的格式化或数据清洗，然后用到后续的​脚本中。\n```\n[root@aliyun-hk1 linux-shell-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'\nname phone addr\nrobin 13712345678 CN\ntom 13812345678 HK\n[root@aliyun-hk1 linux-shell-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}'\nrobin\ntom\n- name: show the items from DB\n      debug:\n        msg: \"{{ item }}\"\n      with_lines: \"echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}'\n​\nTASK [show the items from DB] ****************************************************************************************************************************************************************************************************************ok: [localhost] => (item=robin) => {\n    \"msg\": \"robin\"\n}\nok: [localhost] => (item=tom) => {\n    \"msg\": \"tom\"\n}\n```\n\n**example7:**  echo还可以将获取到并格式化好的数据写入到一个文件，等待后续使用​。\n```\n[root@aliyun-hk1 ansible-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}' > DataFromDB1.txt\n[root@aliyun-hk1 ansible-test]# cat DataFromDB1.txt\nrobin\ntom\n[root@aliyun-hk1 ansible-test]#\n```","source":"_posts/linux/linux-echo.md","raw":"---\ntitle: Linux文本输出命令-echo\ndate: 2020-03-01 22:50:50\ntags: shell\ncategories: linux\n---\n\n**echo** 在linux帮助文档的描述是显示一行文本，类似于python和java等编程语言中的print语句，实际上它的作用不仅仅如此。可以使用man echo查看详细的参数说明。\n<!--more-->\n\n**example1:** 显示一行文本，任何特殊字符都不会被转义\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\\nworld\nhellonworld\n[root@aliyun-hk1 linux-shell-test]# echo 'hello\\nworld'\nhello\\nworld\n[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example2:** 显示一行文本，不要输出末尾的换行符\n```\n[root@aliyun-hk1 linux-shell-test]# echo -n hello world\nhello world[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n```\n\n**example3:** 显示一行文本，启用反斜杠后面的转义字符\n```\n[root@aliyun-hk1 linux-shell-test]# echo -e 'hello\\nworld'\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# echo -e 'hello\\tworld'\nhello   world\n```\n\n**example4:** 显示一行文本，禁用反斜杠后面的转义字符，echo默认参数\n```\n[root@aliyun-hk1 linux-shell-test]# echo -E 'hello\\nworld'\nhello\\nworld\n[root@aliyun-hk1 linux-shell-test]# echo -E 'hello\\tworld'\nhello\\tworld\n```\n\n**example5:** echo与cat的差异对比，echo只用于输出文本，cat用于输出文件内容或者从标准输入中输出\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\nhello\n[root@aliyun-hk1 linux-shell-test]# cat hello\ncat: hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# echo /etc/hostname\n/etc/hostname\n[root@aliyun-hk1 linux-shell-test]# cat /etc/hostname\naliyun-hk1\n[root@aliyun-hk1 linux-shell-test]# echo hello|cat\nhello\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**examle6:** echo在自动化构建中的作用，例如我们可以将DB中返回的数据格式化成ansible需要的数据，通过with_lines 传入某个task并循环使用。在某些情况下，从网络、DB等方式获取的标准输出，可以通过echo结合awk和grep等实现结果的格式化或数据清洗，然后用到后续的​脚本中。\n```\n[root@aliyun-hk1 linux-shell-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'\nname phone addr\nrobin 13712345678 CN\ntom 13812345678 HK\n[root@aliyun-hk1 linux-shell-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}'\nrobin\ntom\n- name: show the items from DB\n      debug:\n        msg: \"{{ item }}\"\n      with_lines: \"echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}'\n​\nTASK [show the items from DB] ****************************************************************************************************************************************************************************************************************ok: [localhost] => (item=robin) => {\n    \"msg\": \"robin\"\n}\nok: [localhost] => (item=tom) => {\n    \"msg\": \"tom\"\n}\n```\n\n**example7:**  echo还可以将获取到并格式化好的数据写入到一个文件，等待后续使用​。\n```\n[root@aliyun-hk1 ansible-test]# echo -en 'name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n'|awk  'NR>1 {print $1}' > DataFromDB1.txt\n[root@aliyun-hk1 ansible-test]# cat DataFromDB1.txt\nrobin\ntom\n[root@aliyun-hk1 ansible-test]#\n```","slug":"linux/linux-echo","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxderu002j0en705xlu27y","content":"<p><strong>echo</strong> 在linux帮助文档的描述是显示一行文本，类似于python和java等编程语言中的print语句，实际上它的作用不仅仅如此。可以使用man echo查看详细的参数说明。<br><a id=\"more\"></a></p>\n<p><strong>example1:</strong> 显示一行文本，任何特殊字符都不会被转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello\\nworld</span><br><span class=\"line\">hellonworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello\\nworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2:</strong> 显示一行文本，不要输出末尾的换行符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -n hello world</span><br><span class=\"line\">hello world[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3:</strong> 显示一行文本，启用反斜杠后面的转义字符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;hello\\tworld&apos;</span><br><span class=\"line\">hello   world</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4:</strong> 显示一行文本，禁用反斜杠后面的转义字符，echo默认参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -E &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello\\nworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -E &apos;hello\\tworld&apos;</span><br><span class=\"line\">hello\\tworld</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5:</strong> echo与cat的差异对比，echo只用于输出文本，cat用于输出文件内容或者从标准输入中输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello</span><br><span class=\"line\">cat: hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo /etc/hostname</span><br><span class=\"line\">/etc/hostname</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /etc/hostname</span><br><span class=\"line\">aliyun-hk1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello|cat</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>examle6:</strong> echo在自动化构建中的作用，例如我们可以将DB中返回的数据格式化成ansible需要的数据，通过with_lines 传入某个task并循环使用。在某些情况下，从网络、DB等方式获取的标准输出，可以通过echo结合awk和grep等实现结果的格式化或数据清洗，然后用到后续的​脚本中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;</span><br><span class=\"line\">name phone addr</span><br><span class=\"line\">robin 13712345678 CN</span><br><span class=\"line\">tom 13812345678 HK</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos;</span><br><span class=\"line\">robin</span><br><span class=\"line\">tom</span><br><span class=\"line\">- name: show the items from DB</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">      with_lines: &quot;echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos;</span><br><span class=\"line\">​</span><br><span class=\"line\">TASK [show the items from DB] ****************************************************************************************************************************************************************************************************************ok: [localhost] =&gt; (item=robin) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;robin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [localhost] =&gt; (item=tom) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;tom&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7:</strong>  echo还可以将获取到并格式化好的数据写入到一个文件，等待后续使用​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ansible-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos; &gt; DataFromDB1.txt</span><br><span class=\"line\">[root@aliyun-hk1 ansible-test]# cat DataFromDB1.txt</span><br><span class=\"line\">robin</span><br><span class=\"line\">tom</span><br><span class=\"line\">[root@aliyun-hk1 ansible-test]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>echo</strong> 在linux帮助文档的描述是显示一行文本，类似于python和java等编程语言中的print语句，实际上它的作用不仅仅如此。可以使用man echo查看详细的参数说明。<br>","more":"</p>\n<p><strong>example1:</strong> 显示一行文本，任何特殊字符都不会被转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello\\nworld</span><br><span class=\"line\">hellonworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello\\nworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2:</strong> 显示一行文本，不要输出末尾的换行符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -n hello world</span><br><span class=\"line\">hello world[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3:</strong> 显示一行文本，启用反斜杠后面的转义字符<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -e &apos;hello\\tworld&apos;</span><br><span class=\"line\">hello   world</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4:</strong> 显示一行文本，禁用反斜杠后面的转义字符，echo默认参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -E &apos;hello\\nworld&apos;</span><br><span class=\"line\">hello\\nworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -E &apos;hello\\tworld&apos;</span><br><span class=\"line\">hello\\tworld</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5:</strong> echo与cat的差异对比，echo只用于输出文本，cat用于输出文件内容或者从标准输入中输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello</span><br><span class=\"line\">cat: hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo /etc/hostname</span><br><span class=\"line\">/etc/hostname</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /etc/hostname</span><br><span class=\"line\">aliyun-hk1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello|cat</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>examle6:</strong> echo在自动化构建中的作用，例如我们可以将DB中返回的数据格式化成ansible需要的数据，通过with_lines 传入某个task并循环使用。在某些情况下，从网络、DB等方式获取的标准输出，可以通过echo结合awk和grep等实现结果的格式化或数据清洗，然后用到后续的​脚本中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;</span><br><span class=\"line\">name phone addr</span><br><span class=\"line\">robin 13712345678 CN</span><br><span class=\"line\">tom 13812345678 HK</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos;</span><br><span class=\"line\">robin</span><br><span class=\"line\">tom</span><br><span class=\"line\">- name: show the items from DB</span><br><span class=\"line\">      debug:</span><br><span class=\"line\">        msg: &quot;&#123;&#123; item &#125;&#125;&quot;</span><br><span class=\"line\">      with_lines: &quot;echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos;</span><br><span class=\"line\">​</span><br><span class=\"line\">TASK [show the items from DB] ****************************************************************************************************************************************************************************************************************ok: [localhost] =&gt; (item=robin) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;robin&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ok: [localhost] =&gt; (item=tom) =&gt; &#123;</span><br><span class=\"line\">    &quot;msg&quot;: &quot;tom&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7:</strong>  echo还可以将获取到并格式化好的数据写入到一个文件，等待后续使用​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ansible-test]# echo -en &apos;name phone addr\\nrobin 13712345678 CN\\ntom 13812345678 HK\\n&apos;|awk  &apos;NR&gt;1 &#123;print $1&#125;&apos; &gt; DataFromDB1.txt</span><br><span class=\"line\">[root@aliyun-hk1 ansible-test]# cat DataFromDB1.txt</span><br><span class=\"line\">robin</span><br><span class=\"line\">tom</span><br><span class=\"line\">[root@aliyun-hk1 ansible-test]#</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux文本查找命令-grep","date":"2020-03-02T22:23:23.000Z","_content":"\n**grep**搜索命名的输入文件（如果没有命名文件，则搜索标准输入）以查找包含与给定PATTERN匹配的行。默认情况下，grep打印匹配的整行。\n<!--more-->\n\n**example1**： 搜索一个文件，最普通模式\n```\n[root@aliyun-hk1 linux-shell-test]# grep hello grep1.sh\nhello\n```\n\n**example2**：递归搜索一个目录下的所有文件\n```\n[root@aliyun-hk1 linux-shell-test]# grep python2 /etc/\ngrep: /etc/: Is a directory\n[root@aliyun-hk1 linux-shell-test]# grep -r python2 /etc/\n/etc/rpm/macros.python:  CFLAGS=\"%{optflags}\" %{__python} %{py_setup} %{?py_setup_args} build --executable=\"%{__python2} %{py_shbang_opts}\" %{?*}\n/etc/rpm/macros.python:  if (string.starts(package, \"python2-\")) then\n/etc/rpm/macros.python:    print(\"Provides: python2-\"\n```\n\n**example3**：从一个标准输入搜索关键字，从管道搜索\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25027 24873  0 21:34 pts/0    00:00:00 grep --color=auto python\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example4**:  搜索时忽略大小写，使用-i\n```\n[root@aliyun-hk1 linux-shell-test]# grep Hello grep1.sh\n[root@aliyun-hk1 linux-shell-test]# grep -i Hello grep1.sh\nhello\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25054 24873  0 21:40 pts/0    00:00:00 grep --color=auto -i Python\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example5**: 搜索时排除某些关键字，使用-v\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25063 24873  0 21:42 pts/0    00:00:00 grep --color=auto -i Python\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python|grep -v grep\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example6**:  搜索时使用正则表达式，-e\n```\ngrep –e \"正则表达式\" 文件名\n```\n\n**example7**: 搜索结果只返回匹配的文件名，-l\n```\n[root@aliyun-hk1 linux-shell-test]# grep -il Hello grep1.sh\ngrep1.sh\n```\n\n**example8**: 搜索结果只返回不匹配的文件名，-L\n```\n[root@aliyun-hk1 linux-shell-test]# grep -irL python grep1.sh\ngrep1.sh\n[root@aliyun-hk1 linux-shell-test]# grep -irL Hello grep1.sh\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example9**: 结合find命令搜索log或者config文件\n```\n[root@aliyun-hk1 linux-shell-test]# find / -name *.log|xargs grep -il error\n/var/log/yum.log\n/var/log/cloud-init.log\n/var/log/nginx/access.log\n/var/log/nginx/error.log\n/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_update.log\n/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_main.log\n/usr/share/doc/libjpeg-turbo-1.2.90/change.log\n```\n\n**example10**: 搜索gz或tar.gz文件，使用zgrep​\n```\n[root@aliyun-hk1 linux-shell-test]# zgrep -ai hello grep1.tar.gz                              \necho1.sh                                                                                      \nustar   root                            root                                                  \nhello                                                                                         \nhello                                                                                         \n                                                                                              \ngrep1.sh                                                                                      \nustar   root                            root                                                  \nhello world                                                                                   \nhEllo word                                                                                    \nHEllo world                                                                                   \nhellO sir                                                                                     \n[root@aliyun-hk1 linux-shell-test]# zgrep -i hello grep1.sh.gz                                \nhello world                                                                                   \nhEllo word                                                                                    \nHEllo world                                                                                   \nhellO sir                                                                                     \n[root@aliyun-hk1 linux-shell-test]#                                                           \n```\n\n**example11**: 更多参数请查看文档，man grep","source":"_posts/linux/linux-grep.md","raw":"---\ntitle: Linux文本查找命令-grep\ndate: 2020-03-02 22:23:23\ntags: shell\ncategories: linux\n---\n\n**grep**搜索命名的输入文件（如果没有命名文件，则搜索标准输入）以查找包含与给定PATTERN匹配的行。默认情况下，grep打印匹配的整行。\n<!--more-->\n\n**example1**： 搜索一个文件，最普通模式\n```\n[root@aliyun-hk1 linux-shell-test]# grep hello grep1.sh\nhello\n```\n\n**example2**：递归搜索一个目录下的所有文件\n```\n[root@aliyun-hk1 linux-shell-test]# grep python2 /etc/\ngrep: /etc/: Is a directory\n[root@aliyun-hk1 linux-shell-test]# grep -r python2 /etc/\n/etc/rpm/macros.python:  CFLAGS=\"%{optflags}\" %{__python} %{py_setup} %{?py_setup_args} build --executable=\"%{__python2} %{py_shbang_opts}\" %{?*}\n/etc/rpm/macros.python:  if (string.starts(package, \"python2-\")) then\n/etc/rpm/macros.python:    print(\"Provides: python2-\"\n```\n\n**example3**：从一个标准输入搜索关键字，从管道搜索\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25027 24873  0 21:34 pts/0    00:00:00 grep --color=auto python\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example4**:  搜索时忽略大小写，使用-i\n```\n[root@aliyun-hk1 linux-shell-test]# grep Hello grep1.sh\n[root@aliyun-hk1 linux-shell-test]# grep -i Hello grep1.sh\nhello\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25054 24873  0 21:40 pts/0    00:00:00 grep --color=auto -i Python\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example5**: 搜索时排除某些关键字，使用-v\n```\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\nroot     25063 24873  0 21:42 pts/0    00:00:00 grep --color=auto -i Python\n[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python|grep -v grep\nroot       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example6**:  搜索时使用正则表达式，-e\n```\ngrep –e \"正则表达式\" 文件名\n```\n\n**example7**: 搜索结果只返回匹配的文件名，-l\n```\n[root@aliyun-hk1 linux-shell-test]# grep -il Hello grep1.sh\ngrep1.sh\n```\n\n**example8**: 搜索结果只返回不匹配的文件名，-L\n```\n[root@aliyun-hk1 linux-shell-test]# grep -irL python grep1.sh\ngrep1.sh\n[root@aliyun-hk1 linux-shell-test]# grep -irL Hello grep1.sh\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**example9**: 结合find命令搜索log或者config文件\n```\n[root@aliyun-hk1 linux-shell-test]# find / -name *.log|xargs grep -il error\n/var/log/yum.log\n/var/log/cloud-init.log\n/var/log/nginx/access.log\n/var/log/nginx/error.log\n/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_update.log\n/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_main.log\n/usr/share/doc/libjpeg-turbo-1.2.90/change.log\n```\n\n**example10**: 搜索gz或tar.gz文件，使用zgrep​\n```\n[root@aliyun-hk1 linux-shell-test]# zgrep -ai hello grep1.tar.gz                              \necho1.sh                                                                                      \nustar   root                            root                                                  \nhello                                                                                         \nhello                                                                                         \n                                                                                              \ngrep1.sh                                                                                      \nustar   root                            root                                                  \nhello world                                                                                   \nhEllo word                                                                                    \nHEllo world                                                                                   \nhellO sir                                                                                     \n[root@aliyun-hk1 linux-shell-test]# zgrep -i hello grep1.sh.gz                                \nhello world                                                                                   \nhEllo word                                                                                    \nHEllo world                                                                                   \nhellO sir                                                                                     \n[root@aliyun-hk1 linux-shell-test]#                                                           \n```\n\n**example11**: 更多参数请查看文档，man grep","slug":"linux/linux-grep","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdery002l0en74szu9goq","content":"<p><strong>grep</strong>搜索命名的输入文件（如果没有命名文件，则搜索标准输入）以查找包含与给定PATTERN匹配的行。默认情况下，grep打印匹配的整行。<br><a id=\"more\"></a></p>\n<p><strong>example1</strong>： 搜索一个文件，最普通模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep hello grep1.sh</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2</strong>：递归搜索一个目录下的所有文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep python2 /etc/</span><br><span class=\"line\">grep: /etc/: Is a directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -r python2 /etc/</span><br><span class=\"line\">/etc/rpm/macros.python:  CFLAGS=&quot;%&#123;optflags&#125;&quot; %&#123;__python&#125; %&#123;py_setup&#125; %&#123;?py_setup_args&#125; build --executable=&quot;%&#123;__python2&#125; %&#123;py_shbang_opts&#125;&quot; %&#123;?*&#125;</span><br><span class=\"line\">/etc/rpm/macros.python:  if (string.starts(package, &quot;python2-&quot;)) then</span><br><span class=\"line\">/etc/rpm/macros.python:    print(&quot;Provides: python2-&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3</strong>：从一个标准输入搜索关键字，从管道搜索<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25027 24873  0 21:34 pts/0    00:00:00 grep --color=auto python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4</strong>:  搜索时忽略大小写，使用-i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep Hello grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -i Hello grep1.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25054 24873  0 21:40 pts/0    00:00:00 grep --color=auto -i Python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5</strong>: 搜索时排除某些关键字，使用-v<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25063 24873  0 21:42 pts/0    00:00:00 grep --color=auto -i Python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python|grep -v grep</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example6</strong>:  搜索时使用正则表达式，-e<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep –e &quot;正则表达式&quot; 文件名</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7</strong>: 搜索结果只返回匹配的文件名，-l<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -il Hello grep1.sh</span><br><span class=\"line\">grep1.sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>example8</strong>: 搜索结果只返回不匹配的文件名，-L<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -irL python grep1.sh</span><br><span class=\"line\">grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -irL Hello grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example9</strong>: 结合find命令搜索log或者config文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# find / -name *.log|xargs grep -il error</span><br><span class=\"line\">/var/log/yum.log</span><br><span class=\"line\">/var/log/cloud-init.log</span><br><span class=\"line\">/var/log/nginx/access.log</span><br><span class=\"line\">/var/log/nginx/error.log</span><br><span class=\"line\">/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_update.log</span><br><span class=\"line\">/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_main.log</span><br><span class=\"line\">/usr/share/doc/libjpeg-turbo-1.2.90/change.log</span><br></pre></td></tr></table></figure></p>\n<p><strong>example10</strong>: 搜索gz或tar.gz文件，使用zgrep​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# zgrep -ai hello grep1.tar.gz                              </span><br><span class=\"line\">echo1.sh                                                                                      </span><br><span class=\"line\">ustar   root                            root                                                  </span><br><span class=\"line\">hello                                                                                         </span><br><span class=\"line\">hello                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">grep1.sh                                                                                      </span><br><span class=\"line\">ustar   root                            root                                                  </span><br><span class=\"line\">hello world                                                                                   </span><br><span class=\"line\">hEllo word                                                                                    </span><br><span class=\"line\">HEllo world                                                                                   </span><br><span class=\"line\">hellO sir                                                                                     </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# zgrep -i hello grep1.sh.gz                                </span><br><span class=\"line\">hello world                                                                                   </span><br><span class=\"line\">hEllo word                                                                                    </span><br><span class=\"line\">HEllo world                                                                                   </span><br><span class=\"line\">hellO sir                                                                                     </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example11</strong>: 更多参数请查看文档，man grep</p>\n","site":{"data":{}},"excerpt":"<p><strong>grep</strong>搜索命名的输入文件（如果没有命名文件，则搜索标准输入）以查找包含与给定PATTERN匹配的行。默认情况下，grep打印匹配的整行。<br>","more":"</p>\n<p><strong>example1</strong>： 搜索一个文件，最普通模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep hello grep1.sh</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<p><strong>example2</strong>：递归搜索一个目录下的所有文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep python2 /etc/</span><br><span class=\"line\">grep: /etc/: Is a directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -r python2 /etc/</span><br><span class=\"line\">/etc/rpm/macros.python:  CFLAGS=&quot;%&#123;optflags&#125;&quot; %&#123;__python&#125; %&#123;py_setup&#125; %&#123;?py_setup_args&#125; build --executable=&quot;%&#123;__python2&#125; %&#123;py_shbang_opts&#125;&quot; %&#123;?*&#125;</span><br><span class=\"line\">/etc/rpm/macros.python:  if (string.starts(package, &quot;python2-&quot;)) then</span><br><span class=\"line\">/etc/rpm/macros.python:    print(&quot;Provides: python2-&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>example3</strong>：从一个标准输入搜索关键字，从管道搜索<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25027 24873  0 21:34 pts/0    00:00:00 grep --color=auto python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example4</strong>:  搜索时忽略大小写，使用-i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep Hello grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -i Hello grep1.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25054 24873  0 21:40 pts/0    00:00:00 grep --color=auto -i Python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example5</strong>: 搜索时排除某些关键字，使用-v<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">root     25063 24873  0 21:42 pts/0    00:00:00 grep --color=auto -i Python</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ps -ef|grep -i Python|grep -v grep</span><br><span class=\"line\">root       803     1  0 Feb28 ?        00:00:34 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example6</strong>:  搜索时使用正则表达式，-e<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep –e &quot;正则表达式&quot; 文件名</span><br></pre></td></tr></table></figure></p>\n<p><strong>example7</strong>: 搜索结果只返回匹配的文件名，-l<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -il Hello grep1.sh</span><br><span class=\"line\">grep1.sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>example8</strong>: 搜索结果只返回不匹配的文件名，-L<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -irL python grep1.sh</span><br><span class=\"line\">grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# grep -irL Hello grep1.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example9</strong>: 结合find命令搜索log或者config文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# find / -name *.log|xargs grep -il error</span><br><span class=\"line\">/var/log/yum.log</span><br><span class=\"line\">/var/log/cloud-init.log</span><br><span class=\"line\">/var/log/nginx/access.log</span><br><span class=\"line\">/var/log/nginx/error.log</span><br><span class=\"line\">/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_update.log</span><br><span class=\"line\">/usr/local/share/aliyun-assist/1.0.1.259/log/aliyun_assist_main.log</span><br><span class=\"line\">/usr/share/doc/libjpeg-turbo-1.2.90/change.log</span><br></pre></td></tr></table></figure></p>\n<p><strong>example10</strong>: 搜索gz或tar.gz文件，使用zgrep​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# zgrep -ai hello grep1.tar.gz                              </span><br><span class=\"line\">echo1.sh                                                                                      </span><br><span class=\"line\">ustar   root                            root                                                  </span><br><span class=\"line\">hello                                                                                         </span><br><span class=\"line\">hello                                                                                         </span><br><span class=\"line\">                                                                                              </span><br><span class=\"line\">grep1.sh                                                                                      </span><br><span class=\"line\">ustar   root                            root                                                  </span><br><span class=\"line\">hello world                                                                                   </span><br><span class=\"line\">hEllo word                                                                                    </span><br><span class=\"line\">HEllo world                                                                                   </span><br><span class=\"line\">hellO sir                                                                                     </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# zgrep -i hello grep1.sh.gz                                </span><br><span class=\"line\">hello world                                                                                   </span><br><span class=\"line\">hEllo word                                                                                    </span><br><span class=\"line\">HEllo world                                                                                   </span><br><span class=\"line\">hellO sir                                                                                     </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>example11</strong>: 更多参数请查看文档，man grep</p>"},{"title":"Linux文本编辑命令-sed","date":"2020-03-04T23:08:08.000Z","_content":"\n**sed**用于过滤和转换文本的流编辑器。Sed是流编辑器。流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。尽管在某种程度上类似于允许脚本编辑（例如ed）的编辑器，但sed通过仅对输入进行一次传递来工作，因此效率更高。但是sed能够过滤管道中的文本，这使其与其他类型的编辑器特别有区别。grep,sed,awk合起来俗称linux shell三剑客。\n<!--more-->\n\nexample1: 打印行，sed -n 'n1,n2 p'  file_name\n```\n[root@aliyun-hk1 linux-shell-test]# sed -n '1 p' sed.sh\nhello world 2020#\n[root@aliyun-hk1 linux-shell-test]# sed -n '1,3 p' sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\nexample2: 删除行并且内容不变，sed -n 'n1,n2 d'  file_name\n```\n[root@aliyun-hk1 linux-shell-test]# sed -n '1 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n '1,3 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample3: 插入行并且内容不变，sed  'ni top' file_name\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh          \nhello world 2020#                                       \nhello china 2021#                                       \nhello xian 2022#                                                                                                \n[root@aliyun-hk1 linux-shell-test]# sed '2i top' sed.sh \nhello world 2020#                                       \ntop                                                     \nhello china 2021#                                       \nhello xian 2022#                                                                                             \n[root@aliyun-hk1 linux-shell-test]# sed '2a top' sed.sh \nhello world 2020#                                       \nhello china 2021#                                       \ntop                                                     \nhello xian 2022#\n```\n\nexample4: 替换行且内容不变， sed 'nc newline' file_name\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed '2c newline' sed.sh\nhello world 2020#\nnewline\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample5: 替换每行第一个字符并且内容不变，-n ‘s/old/new/p’\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n 's/hello/hallo/p' sed.sh\nhallo world 2020#\nhallo china 2021#\nhallo xian 2022#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample6: 替换文件中的所有字符且内容不变，-n ‘s/old/new/pg\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n 's/20/88/pg' sed.sh\nhello world 8888#\nhello china 8821#\nhello xian 8822#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample7: 直接对源文件内容进行操作，删除第n行，sed -i\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 9999#\nhello china 9921#\nhello xian 9922#\n[root@aliyun-hk1 linux-shell-test]# sed -i '1 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello china 9921#\nhello xian 9922#\n```\n\nexample8: 直接对文件内容操作，第n行前插入一行,sed -i​\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello china 9921#\nhello xian 9922#\n[root@aliyun-hk1 linux-shell-test]# sed -i '1 i top' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\ntop\nhello china 9921#\nhello xian 9922#\n```\n\nexample9: 直接对源文件内容进行操作，替换字符，sed -i\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 8888#\nhello china 8821#\nhello xian 8822#\n[root@aliyun-hk1 linux-shell-test]# sed -i 's/8/9/g' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 9999#\nhello china 9921#\nhello xian 9922#\n```\n\nexample10: 更多命令请参考，man sed\n```\n或参阅 https://man.linuxde.net/sed\n```","source":"_posts/linux/linux-sed.md","raw":"---\ntitle: Linux文本编辑命令-sed\ndate: 2020-03-04 23:08:08\ntags: shell\ncategories: linux\n---\n\n**sed**用于过滤和转换文本的流编辑器。Sed是流编辑器。流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。尽管在某种程度上类似于允许脚本编辑（例如ed）的编辑器，但sed通过仅对输入进行一次传递来工作，因此效率更高。但是sed能够过滤管道中的文本，这使其与其他类型的编辑器特别有区别。grep,sed,awk合起来俗称linux shell三剑客。\n<!--more-->\n\nexample1: 打印行，sed -n 'n1,n2 p'  file_name\n```\n[root@aliyun-hk1 linux-shell-test]# sed -n '1 p' sed.sh\nhello world 2020#\n[root@aliyun-hk1 linux-shell-test]# sed -n '1,3 p' sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\nexample2: 删除行并且内容不变，sed -n 'n1,n2 d'  file_name\n```\n[root@aliyun-hk1 linux-shell-test]# sed -n '1 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n '1,3 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample3: 插入行并且内容不变，sed  'ni top' file_name\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh          \nhello world 2020#                                       \nhello china 2021#                                       \nhello xian 2022#                                                                                                \n[root@aliyun-hk1 linux-shell-test]# sed '2i top' sed.sh \nhello world 2020#                                       \ntop                                                     \nhello china 2021#                                       \nhello xian 2022#                                                                                             \n[root@aliyun-hk1 linux-shell-test]# sed '2a top' sed.sh \nhello world 2020#                                       \nhello china 2021#                                       \ntop                                                     \nhello xian 2022#\n```\n\nexample4: 替换行且内容不变， sed 'nc newline' file_name\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed '2c newline' sed.sh\nhello world 2020#\nnewline\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample5: 替换每行第一个字符并且内容不变，-n ‘s/old/new/p’\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n 's/hello/hallo/p' sed.sh\nhallo world 2020#\nhallo china 2021#\nhallo xian 2022#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample6: 替换文件中的所有字符且内容不变，-n ‘s/old/new/pg\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n[root@aliyun-hk1 linux-shell-test]# sed -n 's/20/88/pg' sed.sh\nhello world 8888#\nhello china 8821#\nhello xian 8822#\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 2020#\nhello china 2021#\nhello xian 2022#\n```\n\nexample7: 直接对源文件内容进行操作，删除第n行，sed -i\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 9999#\nhello china 9921#\nhello xian 9922#\n[root@aliyun-hk1 linux-shell-test]# sed -i '1 d' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello china 9921#\nhello xian 9922#\n```\n\nexample8: 直接对文件内容操作，第n行前插入一行,sed -i​\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello china 9921#\nhello xian 9922#\n[root@aliyun-hk1 linux-shell-test]# sed -i '1 i top' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\ntop\nhello china 9921#\nhello xian 9922#\n```\n\nexample9: 直接对源文件内容进行操作，替换字符，sed -i\n```\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 8888#\nhello china 8821#\nhello xian 8822#\n[root@aliyun-hk1 linux-shell-test]# sed -i 's/8/9/g' sed.sh\n[root@aliyun-hk1 linux-shell-test]# cat sed.sh\nhello world 9999#\nhello china 9921#\nhello xian 9922#\n```\n\nexample10: 更多命令请参考，man sed\n```\n或参阅 https://man.linuxde.net/sed\n```","slug":"linux/linux-sed","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdes1002p0en7hslrkx96","content":"<p><strong>sed</strong>用于过滤和转换文本的流编辑器。Sed是流编辑器。流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。尽管在某种程度上类似于允许脚本编辑（例如ed）的编辑器，但sed通过仅对输入进行一次传递来工作，因此效率更高。但是sed能够过滤管道中的文本，这使其与其他类型的编辑器特别有区别。grep,sed,awk合起来俗称linux shell三剑客。<br><a id=\"more\"></a></p>\n<p>example1: 打印行，sed -n ‘n1,n2 p’  file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1 p&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1,3 p&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example2: 删除行并且内容不变，sed -n ‘n1,n2 d’  file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1,3 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example3: 插入行并且内容不变，sed  ‘ni top’ file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh          </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">hello xian 2022#                                                                                                </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2i top&apos; sed.sh </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">top                                                     </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">hello xian 2022#                                                                                             </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2a top&apos; sed.sh </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">top                                                     </span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example4: 替换行且内容不变， sed ‘nc newline’ file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2c newline&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">newline</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example5: 替换每行第一个字符并且内容不变，-n ‘s/old/new/p’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;s/hello/hallo/p&apos; sed.sh</span><br><span class=\"line\">hallo world 2020#</span><br><span class=\"line\">hallo china 2021#</span><br><span class=\"line\">hallo xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example6: 替换文件中的所有字符且内容不变，-n ‘s/old/new/pg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;s/20/88/pg&apos; sed.sh</span><br><span class=\"line\">hello world 8888#</span><br><span class=\"line\">hello china 8821#</span><br><span class=\"line\">hello xian 8822#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example7: 直接对源文件内容进行操作，删除第n行，sed -i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 9999#</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;1 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example8: 直接对文件内容操作，第n行前插入一行,sed -i​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;1 i top&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">top</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example9: 直接对源文件内容进行操作，替换字符，sed -i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 8888#</span><br><span class=\"line\">hello china 8821#</span><br><span class=\"line\">hello xian 8822#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;s/8/9/g&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 9999#</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example10: 更多命令请参考，man sed<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">或参阅 https://man.linuxde.net/sed</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>sed</strong>用于过滤和转换文本的流编辑器。Sed是流编辑器。流编辑器用于对输入流（文件或来自管道的输入）执行基本的文本转换。尽管在某种程度上类似于允许脚本编辑（例如ed）的编辑器，但sed通过仅对输入进行一次传递来工作，因此效率更高。但是sed能够过滤管道中的文本，这使其与其他类型的编辑器特别有区别。grep,sed,awk合起来俗称linux shell三剑客。<br>","more":"</p>\n<p>example1: 打印行，sed -n ‘n1,n2 p’  file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1 p&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1,3 p&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example2: 删除行并且内容不变，sed -n ‘n1,n2 d’  file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;1,3 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example3: 插入行并且内容不变，sed  ‘ni top’ file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh          </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">hello xian 2022#                                                                                                </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2i top&apos; sed.sh </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">top                                                     </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">hello xian 2022#                                                                                             </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2a top&apos; sed.sh </span><br><span class=\"line\">hello world 2020#                                       </span><br><span class=\"line\">hello china 2021#                                       </span><br><span class=\"line\">top                                                     </span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example4: 替换行且内容不变， sed ‘nc newline’ file_name<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed &apos;2c newline&apos; sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">newline</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example5: 替换每行第一个字符并且内容不变，-n ‘s/old/new/p’<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;s/hello/hallo/p&apos; sed.sh</span><br><span class=\"line\">hallo world 2020#</span><br><span class=\"line\">hallo china 2021#</span><br><span class=\"line\">hallo xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example6: 替换文件中的所有字符且内容不变，-n ‘s/old/new/pg<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -n &apos;s/20/88/pg&apos; sed.sh</span><br><span class=\"line\">hello world 8888#</span><br><span class=\"line\">hello china 8821#</span><br><span class=\"line\">hello xian 8822#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 2020#</span><br><span class=\"line\">hello china 2021#</span><br><span class=\"line\">hello xian 2022#</span><br></pre></td></tr></table></figure></p>\n<p>example7: 直接对源文件内容进行操作，删除第n行，sed -i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 9999#</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;1 d&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example8: 直接对文件内容操作，第n行前插入一行,sed -i​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;1 i top&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">top</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example9: 直接对源文件内容进行操作，替换字符，sed -i<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 8888#</span><br><span class=\"line\">hello china 8821#</span><br><span class=\"line\">hello xian 8822#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# sed -i &apos;s/8/9/g&apos; sed.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat sed.sh</span><br><span class=\"line\">hello world 9999#</span><br><span class=\"line\">hello china 9921#</span><br><span class=\"line\">hello xian 9922#</span><br></pre></td></tr></table></figure></p>\n<p>example10: 更多命令请参考，man sed<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">或参阅 https://man.linuxde.net/sed</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之为什么还要学习它","date":"2020-03-05T23:08:08.000Z","_content":"\n最近每天都会发一篇Linux原创文章，其实可能有些网友会不太喜欢纯技术的文章，或者太基础的文章​。我今天就想讲讲，为什么自动化运维工具和技术很多了，还要​学好Linux。\n<!--more-->\n\n回想201x年，我们还在前线做一线和二线运维，每天水深火热的日子回想起来还挺充实的。​某一天，我们收到版本发布公告，应用系统准备从windows迁移到Linux，当时我和小伙伴的心情一下子都不好了。​我就心里想，java程序嘛，在哪个操作系统运行都可以，为什么要用大家都不太熟悉的操作系统。本来我就不喜欢死记硬背，想到linux的各种命令就头疼。​项目组技术总监给大家都发了一个Linux 学习教程pdf版。​大家就抽空开始学习，其实我是最不喜欢看那个pdf的。​接着，我们很快就收到了10台左右的linux系统账号和密码，着手准备系统的迁移，按照统一下发的手册，逐个安装java并对操作系统进行一些配置的修改，让他跑起来就可以了。​我们当时基本还是把linux当windows用的，用FTP把文件传到服务器目录，在FTP上修改文件权限，修改文件内容，然后就直接提交上去了。​现在想想，当时的玩法太low了，Linux作者知道我们这样玩，估计要气死了，哈哈！​现在看来，当时的那些迁移一个ansible roles，弄几个task就搞定了。​至于每次的部署，jenkins+ansible tower/ansible core, 很快就搞定，只是第一次编写脚本需要麻烦点，编写、修改、调优估计花的时间已经够手动部署好几次了。\n\n\n也许会有人问，你这个自动化用的是ansible，关linux什么事​？ 首先，我们用ansible脚本，最终执行的目标是linux系统，如果不熟悉linux，ansible报个什么OS相关的错误，我们就蒙了；第二，ansible虽然自带了好多的模块，例如文件拷贝、文件下载、文件修改、服务启动等等，但是总会有一些ansible不支持，这个时候只能利用使用杀手锏，就是使用ansible的shell模块，相当于直接通过ansible调用linux系统的shell脚本，例如项目内部自己编写的微服务，​要不把它注册成OS的服务，要么就通过sh文件调用；第三，对于同一个场景，通过ansible实现就有多种方式，我们想选择最优的，就要熟悉被操作的对象Linux的好多特性，例如linux权限机制、安全机制、文件管理​机制等。\n\n\n对于我们运维人员来说，可能已经接触到了容器技术Docker，他就是在OS上在虚拟出一个轻量级的OS，他跟宿主系统共享同一套硬件资源，在某些情况下可能需要跟宿主机做磁盘映射等操作，甚至Doker内部好多命令的玩法跟Linux很像。Docker要占用宿主Linux系统的资源，想对docker资源占用熟悉，也要熟悉Linux系统CPU、​内存、IO的运行原理。我们想驾驭好容器，就要先学好Linux。听过大数据的伙伴也知道，大数据的解决方案几乎清一色都是基于Linux系统的。\n\n\n学习过Linux的同学们都知道，Linux shell是一个比python、java语法​复杂好多的一种脚本语言，直接跟操作系统通信。他复杂但是也很强大，任何的Linux系统的配置修改，​通过他都可以实现自动化。还有，linux的好多shell脚本玩法，跟C很像，​精通Linux也会帮助我们精通C语言。如果玩好Linux的grep、awk、sed、ps等shel命令，结合ansible你会实现更多的自动化​功能，例如进程管理​、资源管理、快速的故障定位等等。其实，Linux也是一个很完美的开源产品，他的设计哲学也会提升我们对软件设计​、开发和测试的一些理念。例如，多进程技术、多线程技术、锁和并发的​概念等。\n\n\n虽然本人在现在的工作中，尽量避免复杂的linxu命令，但是时不时要快速完成一个任务，但又不想为鸡毛蒜皮并且一次性的事情编写ansible脚本，​直接几条shell命令搞定。可以省点时间去听音乐​看美女也挺好的，真俗! 你如果学好了linux，​估计会有更多的感触。​\n\n","source":"_posts/linux/linux-why-learn.md","raw":"---\ntitle: Linux之为什么还要学习它\ndate: 2020-03-05 23:08:08\ntags: shell\ncategories: linux\n---\n\n最近每天都会发一篇Linux原创文章，其实可能有些网友会不太喜欢纯技术的文章，或者太基础的文章​。我今天就想讲讲，为什么自动化运维工具和技术很多了，还要​学好Linux。\n<!--more-->\n\n回想201x年，我们还在前线做一线和二线运维，每天水深火热的日子回想起来还挺充实的。​某一天，我们收到版本发布公告，应用系统准备从windows迁移到Linux，当时我和小伙伴的心情一下子都不好了。​我就心里想，java程序嘛，在哪个操作系统运行都可以，为什么要用大家都不太熟悉的操作系统。本来我就不喜欢死记硬背，想到linux的各种命令就头疼。​项目组技术总监给大家都发了一个Linux 学习教程pdf版。​大家就抽空开始学习，其实我是最不喜欢看那个pdf的。​接着，我们很快就收到了10台左右的linux系统账号和密码，着手准备系统的迁移，按照统一下发的手册，逐个安装java并对操作系统进行一些配置的修改，让他跑起来就可以了。​我们当时基本还是把linux当windows用的，用FTP把文件传到服务器目录，在FTP上修改文件权限，修改文件内容，然后就直接提交上去了。​现在想想，当时的玩法太low了，Linux作者知道我们这样玩，估计要气死了，哈哈！​现在看来，当时的那些迁移一个ansible roles，弄几个task就搞定了。​至于每次的部署，jenkins+ansible tower/ansible core, 很快就搞定，只是第一次编写脚本需要麻烦点，编写、修改、调优估计花的时间已经够手动部署好几次了。\n\n\n也许会有人问，你这个自动化用的是ansible，关linux什么事​？ 首先，我们用ansible脚本，最终执行的目标是linux系统，如果不熟悉linux，ansible报个什么OS相关的错误，我们就蒙了；第二，ansible虽然自带了好多的模块，例如文件拷贝、文件下载、文件修改、服务启动等等，但是总会有一些ansible不支持，这个时候只能利用使用杀手锏，就是使用ansible的shell模块，相当于直接通过ansible调用linux系统的shell脚本，例如项目内部自己编写的微服务，​要不把它注册成OS的服务，要么就通过sh文件调用；第三，对于同一个场景，通过ansible实现就有多种方式，我们想选择最优的，就要熟悉被操作的对象Linux的好多特性，例如linux权限机制、安全机制、文件管理​机制等。\n\n\n对于我们运维人员来说，可能已经接触到了容器技术Docker，他就是在OS上在虚拟出一个轻量级的OS，他跟宿主系统共享同一套硬件资源，在某些情况下可能需要跟宿主机做磁盘映射等操作，甚至Doker内部好多命令的玩法跟Linux很像。Docker要占用宿主Linux系统的资源，想对docker资源占用熟悉，也要熟悉Linux系统CPU、​内存、IO的运行原理。我们想驾驭好容器，就要先学好Linux。听过大数据的伙伴也知道，大数据的解决方案几乎清一色都是基于Linux系统的。\n\n\n学习过Linux的同学们都知道，Linux shell是一个比python、java语法​复杂好多的一种脚本语言，直接跟操作系统通信。他复杂但是也很强大，任何的Linux系统的配置修改，​通过他都可以实现自动化。还有，linux的好多shell脚本玩法，跟C很像，​精通Linux也会帮助我们精通C语言。如果玩好Linux的grep、awk、sed、ps等shel命令，结合ansible你会实现更多的自动化​功能，例如进程管理​、资源管理、快速的故障定位等等。其实，Linux也是一个很完美的开源产品，他的设计哲学也会提升我们对软件设计​、开发和测试的一些理念。例如，多进程技术、多线程技术、锁和并发的​概念等。\n\n\n虽然本人在现在的工作中，尽量避免复杂的linxu命令，但是时不时要快速完成一个任务，但又不想为鸡毛蒜皮并且一次性的事情编写ansible脚本，​直接几条shell命令搞定。可以省点时间去听音乐​看美女也挺好的，真俗! 你如果学好了linux，​估计会有更多的感触。​\n\n","slug":"linux/linux-why-learn","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdes5002s0en7c12yxsac","content":"<p>最近每天都会发一篇Linux原创文章，其实可能有些网友会不太喜欢纯技术的文章，或者太基础的文章​。我今天就想讲讲，为什么自动化运维工具和技术很多了，还要​学好Linux。<br><a id=\"more\"></a></p>\n<p>回想201x年，我们还在前线做一线和二线运维，每天水深火热的日子回想起来还挺充实的。​某一天，我们收到版本发布公告，应用系统准备从windows迁移到Linux，当时我和小伙伴的心情一下子都不好了。​我就心里想，java程序嘛，在哪个操作系统运行都可以，为什么要用大家都不太熟悉的操作系统。本来我就不喜欢死记硬背，想到linux的各种命令就头疼。​项目组技术总监给大家都发了一个Linux 学习教程pdf版。​大家就抽空开始学习，其实我是最不喜欢看那个pdf的。​接着，我们很快就收到了10台左右的linux系统账号和密码，着手准备系统的迁移，按照统一下发的手册，逐个安装java并对操作系统进行一些配置的修改，让他跑起来就可以了。​我们当时基本还是把linux当windows用的，用FTP把文件传到服务器目录，在FTP上修改文件权限，修改文件内容，然后就直接提交上去了。​现在想想，当时的玩法太low了，Linux作者知道我们这样玩，估计要气死了，哈哈！​现在看来，当时的那些迁移一个ansible roles，弄几个task就搞定了。​至于每次的部署，jenkins+ansible tower/ansible core, 很快就搞定，只是第一次编写脚本需要麻烦点，编写、修改、调优估计花的时间已经够手动部署好几次了。</p>\n<p>也许会有人问，你这个自动化用的是ansible，关linux什么事​？ 首先，我们用ansible脚本，最终执行的目标是linux系统，如果不熟悉linux，ansible报个什么OS相关的错误，我们就蒙了；第二，ansible虽然自带了好多的模块，例如文件拷贝、文件下载、文件修改、服务启动等等，但是总会有一些ansible不支持，这个时候只能利用使用杀手锏，就是使用ansible的shell模块，相当于直接通过ansible调用linux系统的shell脚本，例如项目内部自己编写的微服务，​要不把它注册成OS的服务，要么就通过sh文件调用；第三，对于同一个场景，通过ansible实现就有多种方式，我们想选择最优的，就要熟悉被操作的对象Linux的好多特性，例如linux权限机制、安全机制、文件管理​机制等。</p>\n<p>对于我们运维人员来说，可能已经接触到了容器技术Docker，他就是在OS上在虚拟出一个轻量级的OS，他跟宿主系统共享同一套硬件资源，在某些情况下可能需要跟宿主机做磁盘映射等操作，甚至Doker内部好多命令的玩法跟Linux很像。Docker要占用宿主Linux系统的资源，想对docker资源占用熟悉，也要熟悉Linux系统CPU、​内存、IO的运行原理。我们想驾驭好容器，就要先学好Linux。听过大数据的伙伴也知道，大数据的解决方案几乎清一色都是基于Linux系统的。</p>\n<p>学习过Linux的同学们都知道，Linux shell是一个比python、java语法​复杂好多的一种脚本语言，直接跟操作系统通信。他复杂但是也很强大，任何的Linux系统的配置修改，​通过他都可以实现自动化。还有，linux的好多shell脚本玩法，跟C很像，​精通Linux也会帮助我们精通C语言。如果玩好Linux的grep、awk、sed、ps等shel命令，结合ansible你会实现更多的自动化​功能，例如进程管理​、资源管理、快速的故障定位等等。其实，Linux也是一个很完美的开源产品，他的设计哲学也会提升我们对软件设计​、开发和测试的一些理念。例如，多进程技术、多线程技术、锁和并发的​概念等。</p>\n<p>虽然本人在现在的工作中，尽量避免复杂的linxu命令，但是时不时要快速完成一个任务，但又不想为鸡毛蒜皮并且一次性的事情编写ansible脚本，​直接几条shell命令搞定。可以省点时间去听音乐​看美女也挺好的，真俗! 你如果学好了linux，​估计会有更多的感触。​</p>\n","site":{"data":{}},"excerpt":"<p>最近每天都会发一篇Linux原创文章，其实可能有些网友会不太喜欢纯技术的文章，或者太基础的文章​。我今天就想讲讲，为什么自动化运维工具和技术很多了，还要​学好Linux。<br>","more":"</p>\n<p>回想201x年，我们还在前线做一线和二线运维，每天水深火热的日子回想起来还挺充实的。​某一天，我们收到版本发布公告，应用系统准备从windows迁移到Linux，当时我和小伙伴的心情一下子都不好了。​我就心里想，java程序嘛，在哪个操作系统运行都可以，为什么要用大家都不太熟悉的操作系统。本来我就不喜欢死记硬背，想到linux的各种命令就头疼。​项目组技术总监给大家都发了一个Linux 学习教程pdf版。​大家就抽空开始学习，其实我是最不喜欢看那个pdf的。​接着，我们很快就收到了10台左右的linux系统账号和密码，着手准备系统的迁移，按照统一下发的手册，逐个安装java并对操作系统进行一些配置的修改，让他跑起来就可以了。​我们当时基本还是把linux当windows用的，用FTP把文件传到服务器目录，在FTP上修改文件权限，修改文件内容，然后就直接提交上去了。​现在想想，当时的玩法太low了，Linux作者知道我们这样玩，估计要气死了，哈哈！​现在看来，当时的那些迁移一个ansible roles，弄几个task就搞定了。​至于每次的部署，jenkins+ansible tower/ansible core, 很快就搞定，只是第一次编写脚本需要麻烦点，编写、修改、调优估计花的时间已经够手动部署好几次了。</p>\n<p>也许会有人问，你这个自动化用的是ansible，关linux什么事​？ 首先，我们用ansible脚本，最终执行的目标是linux系统，如果不熟悉linux，ansible报个什么OS相关的错误，我们就蒙了；第二，ansible虽然自带了好多的模块，例如文件拷贝、文件下载、文件修改、服务启动等等，但是总会有一些ansible不支持，这个时候只能利用使用杀手锏，就是使用ansible的shell模块，相当于直接通过ansible调用linux系统的shell脚本，例如项目内部自己编写的微服务，​要不把它注册成OS的服务，要么就通过sh文件调用；第三，对于同一个场景，通过ansible实现就有多种方式，我们想选择最优的，就要熟悉被操作的对象Linux的好多特性，例如linux权限机制、安全机制、文件管理​机制等。</p>\n<p>对于我们运维人员来说，可能已经接触到了容器技术Docker，他就是在OS上在虚拟出一个轻量级的OS，他跟宿主系统共享同一套硬件资源，在某些情况下可能需要跟宿主机做磁盘映射等操作，甚至Doker内部好多命令的玩法跟Linux很像。Docker要占用宿主Linux系统的资源，想对docker资源占用熟悉，也要熟悉Linux系统CPU、​内存、IO的运行原理。我们想驾驭好容器，就要先学好Linux。听过大数据的伙伴也知道，大数据的解决方案几乎清一色都是基于Linux系统的。</p>\n<p>学习过Linux的同学们都知道，Linux shell是一个比python、java语法​复杂好多的一种脚本语言，直接跟操作系统通信。他复杂但是也很强大，任何的Linux系统的配置修改，​通过他都可以实现自动化。还有，linux的好多shell脚本玩法，跟C很像，​精通Linux也会帮助我们精通C语言。如果玩好Linux的grep、awk、sed、ps等shel命令，结合ansible你会实现更多的自动化​功能，例如进程管理​、资源管理、快速的故障定位等等。其实，Linux也是一个很完美的开源产品，他的设计哲学也会提升我们对软件设计​、开发和测试的一些理念。例如，多进程技术、多线程技术、锁和并发的​概念等。</p>\n<p>虽然本人在现在的工作中，尽量避免复杂的linxu命令，但是时不时要快速完成一个任务，但又不想为鸡毛蒜皮并且一次性的事情编写ansible脚本，​直接几条shell命令搞定。可以省点时间去听音乐​看美女也挺好的，真俗! 你如果学好了linux，​估计会有更多的感触。​</p>"},{"title":"Linux之文件与目录管理","date":"2020-03-11T23:23:23.000Z","_content":"\n上一次我们讲了文件与目录的权限，今天来讲讲文件与目录的管理。\n<!--more-->\n\n绝对目录与相对目录的概念，绝对目录是指从linux根目录“/”开始，相对目录是从当前目录“.”开始。绝对目录任何时候都有效，相对目录的实际含义跟当前所在目录密切相关。\n```\n[root@aliyun-hk1 linux-shell-test]# cat /apps/linux-shell-test/sed.sh\nhello\n[root@aliyun-hk1 linux-shell-test]# cat ./sed.sh\nhello\n```\n\n目录的相关操作，cd可以配合绝对目录或相对目录，让用户直接跳转到某个位置，pwd可以查看当前的绝对目录，mkdir可以新建一个目录，rmdir可以删除一个非空目录。\n```\n[root@aliyun-hk1 linux-shell-test]# cd /apps/linux-shell-test/dir1/\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# mkdir subdir1\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# cd subdir1/\n[root@aliyun-hk1 subdir1]# pwd\n/apps/linux-shell-test/dir1/subdir1\n[root@aliyun-hk1 subdir1]# cd ../\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# ll\ntotal 8\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\ndrwxr-xr-x 2 root  root  4096 Mar 12 22:42 subdir1\n[root@aliyun-hk1 dir1]# rmdir subdir1/\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n```\n\n关于执行文件路径变量$PATH及用法，我们接触过linux的小伙伴，会觉得很神奇，输入一个命令后，马上会有一个返回。其实，你每次输入一个命令后，shell会自动去PATH定义的目录逐个查找正确的程序，查到后直接执行，如果有多个，则先查到的执行，后面的忽略。例如，下面的例子就是在/usr/bin/中找到了python2.7并且执行了。\n```\n[root@aliyun-hk1 dir1]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 dir1]# python\nPython 2.7.5 (default, Aug  7 2019, 00:51:29)\n[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n[2]+  Stopped                 python\n[root@aliyun-hk1 dir1]# whereis python\npython: /usr/bin/python2.7 /usr/bin/python /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz\n[root@aliyun-hk1 dir1]#\n```\n\n文件显示属性，可以使用ls，其实ll只是操作系统定义的一个别名，ll=ls -l，如果也要显示隐藏文件，使用ls -alt\n```\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n[root@aliyun-hk1 dir1]# ls\ndir1  file1  file2\n[root@aliyun-hk1 dir1]# alias\nalias cp='cp -i'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n```\n\n文件新建、复制、移动、删除\ntouch -a\ncp -a -prd -u \nmv -f -u\nrm -i -rf\n\n目录的新建、复制、移动、删除，请自行通过帮助文档学习。\nmkdir -p\nrmdir\ncp -r\ncat -A\n\n文件查看相关命令，请自行通过帮助文档学习。\nmore\nless\nhead -n\ntail -f\ncat\ntac\nod\n\n文件与目录默认权限与隐藏权限。\numask\nSUID\nSGID\nSBIT\n\n文件类型、位置和查找。\nfile\nwhich\nwhereis\nfind","source":"_posts/linux/linux_file_dir_manager.md","raw":"---\ntitle: Linux之文件与目录管理\ndate: 2020-03-11 23:23:23\ntags: file\ncategories: linux\n---\n\n上一次我们讲了文件与目录的权限，今天来讲讲文件与目录的管理。\n<!--more-->\n\n绝对目录与相对目录的概念，绝对目录是指从linux根目录“/”开始，相对目录是从当前目录“.”开始。绝对目录任何时候都有效，相对目录的实际含义跟当前所在目录密切相关。\n```\n[root@aliyun-hk1 linux-shell-test]# cat /apps/linux-shell-test/sed.sh\nhello\n[root@aliyun-hk1 linux-shell-test]# cat ./sed.sh\nhello\n```\n\n目录的相关操作，cd可以配合绝对目录或相对目录，让用户直接跳转到某个位置，pwd可以查看当前的绝对目录，mkdir可以新建一个目录，rmdir可以删除一个非空目录。\n```\n[root@aliyun-hk1 linux-shell-test]# cd /apps/linux-shell-test/dir1/\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# mkdir subdir1\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# cd subdir1/\n[root@aliyun-hk1 subdir1]# pwd\n/apps/linux-shell-test/dir1/subdir1\n[root@aliyun-hk1 subdir1]# cd ../\n[root@aliyun-hk1 dir1]# pwd\n/apps/linux-shell-test/dir1\n[root@aliyun-hk1 dir1]# ll\ntotal 8\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\ndrwxr-xr-x 2 root  root  4096 Mar 12 22:42 subdir1\n[root@aliyun-hk1 dir1]# rmdir subdir1/\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n```\n\n关于执行文件路径变量$PATH及用法，我们接触过linux的小伙伴，会觉得很神奇，输入一个命令后，马上会有一个返回。其实，你每次输入一个命令后，shell会自动去PATH定义的目录逐个查找正确的程序，查到后直接执行，如果有多个，则先查到的执行，后面的忽略。例如，下面的例子就是在/usr/bin/中找到了python2.7并且执行了。\n```\n[root@aliyun-hk1 dir1]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 dir1]# python\nPython 2.7.5 (default, Aug  7 2019, 00:51:29)\n[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n[2]+  Stopped                 python\n[root@aliyun-hk1 dir1]# whereis python\npython: /usr/bin/python2.7 /usr/bin/python /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz\n[root@aliyun-hk1 dir1]#\n```\n\n文件显示属性，可以使用ls，其实ll只是操作系统定义的一个别名，ll=ls -l，如果也要显示隐藏文件，使用ls -alt\n```\n[root@aliyun-hk1 dir1]# ll\ntotal 4\ndrw------- 2 robin root  4096 Mar 11 00:09 dir1\n-rw------- 1 robin root     0 Mar 11 00:09 file1\n-rw------- 1 robin robin    0 Mar 11 00:19 file2\n[root@aliyun-hk1 dir1]# ls\ndir1  file1  file2\n[root@aliyun-hk1 dir1]# alias\nalias cp='cp -i'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n```\n\n文件新建、复制、移动、删除\ntouch -a\ncp -a -prd -u \nmv -f -u\nrm -i -rf\n\n目录的新建、复制、移动、删除，请自行通过帮助文档学习。\nmkdir -p\nrmdir\ncp -r\ncat -A\n\n文件查看相关命令，请自行通过帮助文档学习。\nmore\nless\nhead -n\ntail -f\ncat\ntac\nod\n\n文件与目录默认权限与隐藏权限。\numask\nSUID\nSGID\nSBIT\n\n文件类型、位置和查找。\nfile\nwhich\nwhereis\nfind","slug":"linux/linux_file_dir_manager","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdes7002w0en7ppsrn379","content":"<p>上一次我们讲了文件与目录的权限，今天来讲讲文件与目录的管理。<br><a id=\"more\"></a></p>\n<p>绝对目录与相对目录的概念，绝对目录是指从linux根目录“/”开始，相对目录是从当前目录“.”开始。绝对目录任何时候都有效，相对目录的实际含义跟当前所在目录密切相关。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /apps/linux-shell-test/sed.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ./sed.sh</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<p>目录的相关操作，cd可以配合绝对目录或相对目录，让用户直接跳转到某个位置，pwd可以查看当前的绝对目录，mkdir可以新建一个目录，rmdir可以删除一个非空目录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cd /apps/linux-shell-test/dir1/</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# mkdir subdir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# cd subdir1/</span><br><span class=\"line\">[root@aliyun-hk1 subdir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1/subdir1</span><br><span class=\"line\">[root@aliyun-hk1 subdir1]# cd ../</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 8</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">drwxr-xr-x 2 root  root  4096 Mar 12 22:42 subdir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# rmdir subdir1/</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br></pre></td></tr></table></figure></p>\n<p>关于执行文件路径变量$PATH及用法，我们接触过linux的小伙伴，会觉得很神奇，输入一个命令后，马上会有一个返回。其实，你每次输入一个命令后，shell会自动去PATH定义的目录逐个查找正确的程序，查到后直接执行，如果有多个，则先查到的执行，后面的忽略。例如，下面的例子就是在/usr/bin/中找到了python2.7并且执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 dir1]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# python</span><br><span class=\"line\">Python 2.7.5 (default, Aug  7 2019, 00:51:29)</span><br><span class=\"line\">[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\">[2]+  Stopped                 python</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# whereis python</span><br><span class=\"line\">python: /usr/bin/python2.7 /usr/bin/python /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz</span><br><span class=\"line\">[root@aliyun-hk1 dir1]#</span><br></pre></td></tr></table></figure></p>\n<p>文件显示属性，可以使用ls，其实ll只是操作系统定义的一个别名，ll=ls -l，如果也要显示隐藏文件，使用ls -alt<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ls</span><br><span class=\"line\">dir1  file1  file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# alias</span><br><span class=\"line\">alias cp=&apos;cp -i&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias mv=&apos;mv -i&apos;</span><br><span class=\"line\">alias rm=&apos;rm -i&apos;</span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure></p>\n<p>文件新建、复制、移动、删除<br>touch -a<br>cp -a -prd -u<br>mv -f -u<br>rm -i -rf</p>\n<p>目录的新建、复制、移动、删除，请自行通过帮助文档学习。<br>mkdir -p<br>rmdir<br>cp -r<br>cat -A</p>\n<p>文件查看相关命令，请自行通过帮助文档学习。<br>more<br>less<br>head -n<br>tail -f<br>cat<br>tac<br>od</p>\n<p>文件与目录默认权限与隐藏权限。<br>umask<br>SUID<br>SGID<br>SBIT</p>\n<p>文件类型、位置和查找。<br>file<br>which<br>whereis<br>find</p>\n","site":{"data":{}},"excerpt":"<p>上一次我们讲了文件与目录的权限，今天来讲讲文件与目录的管理。<br>","more":"</p>\n<p>绝对目录与相对目录的概念，绝对目录是指从linux根目录“/”开始，相对目录是从当前目录“.”开始。绝对目录任何时候都有效，相对目录的实际含义跟当前所在目录密切相关。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /apps/linux-shell-test/sed.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ./sed.sh</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<p>目录的相关操作，cd可以配合绝对目录或相对目录，让用户直接跳转到某个位置，pwd可以查看当前的绝对目录，mkdir可以新建一个目录，rmdir可以删除一个非空目录。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cd /apps/linux-shell-test/dir1/</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# mkdir subdir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# cd subdir1/</span><br><span class=\"line\">[root@aliyun-hk1 subdir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1/subdir1</span><br><span class=\"line\">[root@aliyun-hk1 subdir1]# cd ../</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# pwd</span><br><span class=\"line\">/apps/linux-shell-test/dir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 8</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">drwxr-xr-x 2 root  root  4096 Mar 12 22:42 subdir1</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# rmdir subdir1/</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br></pre></td></tr></table></figure></p>\n<p>关于执行文件路径变量$PATH及用法，我们接触过linux的小伙伴，会觉得很神奇，输入一个命令后，马上会有一个返回。其实，你每次输入一个命令后，shell会自动去PATH定义的目录逐个查找正确的程序，查到后直接执行，如果有多个，则先查到的执行，后面的忽略。例如，下面的例子就是在/usr/bin/中找到了python2.7并且执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 dir1]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# python</span><br><span class=\"line\">Python 2.7.5 (default, Aug  7 2019, 00:51:29)</span><br><span class=\"line\">[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\">[2]+  Stopped                 python</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# whereis python</span><br><span class=\"line\">python: /usr/bin/python2.7 /usr/bin/python /usr/bin/python2.7-config /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz</span><br><span class=\"line\">[root@aliyun-hk1 dir1]#</span><br></pre></td></tr></table></figure></p>\n<p>文件显示属性，可以使用ls，其实ll只是操作系统定义的一个别名，ll=ls -l，如果也要显示隐藏文件，使用ls -alt<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 dir1]# ll</span><br><span class=\"line\">total 4</span><br><span class=\"line\">drw------- 2 robin root  4096 Mar 11 00:09 dir1</span><br><span class=\"line\">-rw------- 1 robin root     0 Mar 11 00:09 file1</span><br><span class=\"line\">-rw------- 1 robin robin    0 Mar 11 00:19 file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# ls</span><br><span class=\"line\">dir1  file1  file2</span><br><span class=\"line\">[root@aliyun-hk1 dir1]# alias</span><br><span class=\"line\">alias cp=&apos;cp -i&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias mv=&apos;mv -i&apos;</span><br><span class=\"line\">alias rm=&apos;rm -i&apos;</span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure></p>\n<p>文件新建、复制、移动、删除<br>touch -a<br>cp -a -prd -u<br>mv -f -u<br>rm -i -rf</p>\n<p>目录的新建、复制、移动、删除，请自行通过帮助文档学习。<br>mkdir -p<br>rmdir<br>cp -r<br>cat -A</p>\n<p>文件查看相关命令，请自行通过帮助文档学习。<br>more<br>less<br>head -n<br>tail -f<br>cat<br>tac<br>od</p>\n<p>文件与目录默认权限与隐藏权限。<br>umask<br>SUID<br>SGID<br>SBIT</p>\n<p>文件类型、位置和查找。<br>file<br>which<br>whereis<br>find</p>"},{"title":"Linux之环境变量","date":"2020-03-07T23:08:08.000Z","_content":"\n我们只要使用linux shell，就避免不了**环境变量**这个话题，大家最开始接触环境变量估计都从接触PATH环境变量开始。\n<!--more-->\n\n**环境变量**按照生效范围可以分为**全局环境变量**和**局部环境变量**。全局环境变量对于shell会话和所有生成的子shell都是可见的；局部环境变量只对当前shell有效。Linux系统在你开始bash会话时就会设置一些全局环境变量，而且变量名都是大写，以区别于普通的环境变量。\n\n使用printenv、env或export，可以查看这些默认的**全局环境变量**。\n```\n[root@aliyun-hk1 profile.d]# printenv\nXDG_SESSION_ID=1541\nHOSTNAME=aliyun-hk1\nTERM=cygwin\nSHELL=/bin/bash\nHISTSIZE=1000\nSSH_CLIENT=222.90.142.215 54197 22\nSSH_TTY=/dev/pts/0\n[root@aliyun-hk1 opstime.github.io]# env\nXDG_SESSION_ID=16\nHOSTNAME=aliyun-hk1\nTERM=cygwin\nSHELL=/bin/bash\nHISTSIZE=1000\nSSH_CLIENT=222.90.142.205 64344 22\nOLDPWD=/apps/ansible-test\nSSH_TTY=/dev/pts/1\n[root@aliyun-hk1 opstime.github.io]# export\ndeclare -x HISTCONTROL=\"ignoredups\"\ndeclare -x HISTSIZE=\"1000\"\ndeclare -x HOME=\"/root\"\ndeclare -x HOSTNAME=\"aliyun-hk1\"\ndeclare -x LANG=\"en_US.UTF-8\"\ndeclare -x LESSOPEN=\"||/usr/bin/lesspipe.sh %s\"\ndeclare -x LOGNAME=\"root\"\n```\n\n显示**单个全局变量的值**，例如：HOME、PATH\n```\n[root@aliyun-hk1 profile.d]# env|grep HOME\nHOME=/root\n[root@aliyun-hk1 profile.d]# env|grep PATH\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 profile.d]# echo $HOME\n/root\n[root@aliyun-hk1 profile.d]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 profile.d]#\n```\n\n**全局环境变量**一般在以下几处定义或配置, 从优先级的高低分为/etc/profile、/etc/bashrc、/etc/profile.d/\n```\n[root@aliyun-hk1 profile.d]# cat /etc/profile\n# /etc/profile\n​\n# System wide environment and startup programs, for login setup\n# Functions and aliases go in /etc/bashrc\n​\n# It's NOT a good idea to change this file unless you know what you\n# are doing. It's much better to create a custom.sh shell script in\n# /etc/profile.d/ to make custom changes to your environment, as this\n# will prevent the need for merging in future updates.\n​\npathmunge () {\n    case \":${PATH}:\" in\n        *:\"$1\":*)\n            ;;\n        *)\n            if [ \"$2\" = \"after\" ] ; then\n                PATH=$PATH:$1\n            else\n                PATH=$1:$PATH\n            fi\n    esac\n}\n\n[root@aliyun-hk1 profile.d]# cat /etc/bashrc\n# /etc/bashrc\n​\n# System wide functions and aliases\n# Environment stuff goes in /etc/profile\n​\n# It's NOT a good idea to change this file unless you know what you\n# are doing. It's much better to create a custom.sh shell script in\n# /etc/profile.d/ to make custom changes to your environment, as this\n# will prevent the need for merging in future updates.\n​\n[root@aliyun-hk1 profile.d]# cd /etc/profile.d/\n[root@aliyun-hk1 profile.d]# ll\ntotal 64\n-rw-r--r--  1 root root  771 Sep 27  2018 256term.csh\n-rw-r--r--  1 root root  841 Sep 27  2018 256term.sh\n-rw-r--r--. 1 root root  196 Mar 25  2017 colorgrep.csh\n-rw-r--r--. 1 root root  201 Mar 25  2017 colorgrep.sh\n-rw-r--r--. 1 root root 1741 Apr 11  2018 colorls.csh\n-rw-r--r--. 1 root root 1606 Apr 11  2018 colorls.sh\n-rw-r--r--. 1 root root   80 Apr 11  2018 csh.local\n-rw-r--r--  1 root root 1706 Sep 27  2018 lang.csh\n-rw-r--r--  1 root root 2703 Sep 27  2018 lang.sh\n-rw-r--r--. 1 root root  123 Jul 31  2015 less.csh\n-rw-r--r--. 1 root root  121 Jul 31  2015 less.sh\n-rw-r--r--. 1 root root   81 Apr 11  2018 sh.local\n-rw-r--r--  1 root root  105 Apr 11  2018 vim.csh\n-rw-r--r--  1 root root  269 Apr 11  2018 vim.sh\n-rw-r--r--. 1 root root  164 Jan 28  2014 which2.csh\n-rw-r--r--. 1 root root  169 Jan 28  2014 which2.sh\n```\n\n**局部环境变量**可以分为**用户级环境变量**和**进程级环境变量**。用户级环境变量在当前用户的任何shell都有效，进程级环境变量只在运行进程的shell中有效。\n\n\n**用户级环境变量**在​这个用户shell启动的时候会自动加载，按照顺序运行第一个被找到的文件，后面的直接忽略。这些文件都在当前用户的​家目录下以隐藏文件的形式存在，用户可以根据实际需要进行增删改​。如果修改配置文件后必须重新登陆该用户或者执行source filename 或者 . filename​才会生效。\n```\n~/.bash_profile 1​\n~/.bashrc\n~/.bash_login 2​\n~/.profile 3\n```\n\n**进程级环境变量**在运行这个进程时临时定义，只在当前进程的shell及子shell中有效，想在子shell有效，需要使用export 变量名。​每个进程的shell及子shell也会自动继承全局环境变量。\n```\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# name=robin\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# export name\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot      3142  3140  0 00:21 pts/0    00:00:00 -bash\nroot      3189  3142  0 00:22 pts/0    00:00:00 bash\nroot      3189  3142  0 00:22 pts/0    00:00:00 bash\nroot      3216  3189  0 00:22 pts/0    00:00:00 ps -f\n[root@aliyun-hk1 ~]# exit\nexit\n[root@aliyun-hk1 ~]# exit\nexit\n[root@aliyun-hk1 ~]# echo $name\n​\n[root@aliyun-hk1 ~]#\n```","source":"_posts/linux/linux_env_var.md","raw":"---\ntitle: Linux之环境变量\ndate: 2020-03-07 23:08:08\ntags: shell\ncategories: linux\n---\n\n我们只要使用linux shell，就避免不了**环境变量**这个话题，大家最开始接触环境变量估计都从接触PATH环境变量开始。\n<!--more-->\n\n**环境变量**按照生效范围可以分为**全局环境变量**和**局部环境变量**。全局环境变量对于shell会话和所有生成的子shell都是可见的；局部环境变量只对当前shell有效。Linux系统在你开始bash会话时就会设置一些全局环境变量，而且变量名都是大写，以区别于普通的环境变量。\n\n使用printenv、env或export，可以查看这些默认的**全局环境变量**。\n```\n[root@aliyun-hk1 profile.d]# printenv\nXDG_SESSION_ID=1541\nHOSTNAME=aliyun-hk1\nTERM=cygwin\nSHELL=/bin/bash\nHISTSIZE=1000\nSSH_CLIENT=222.90.142.215 54197 22\nSSH_TTY=/dev/pts/0\n[root@aliyun-hk1 opstime.github.io]# env\nXDG_SESSION_ID=16\nHOSTNAME=aliyun-hk1\nTERM=cygwin\nSHELL=/bin/bash\nHISTSIZE=1000\nSSH_CLIENT=222.90.142.205 64344 22\nOLDPWD=/apps/ansible-test\nSSH_TTY=/dev/pts/1\n[root@aliyun-hk1 opstime.github.io]# export\ndeclare -x HISTCONTROL=\"ignoredups\"\ndeclare -x HISTSIZE=\"1000\"\ndeclare -x HOME=\"/root\"\ndeclare -x HOSTNAME=\"aliyun-hk1\"\ndeclare -x LANG=\"en_US.UTF-8\"\ndeclare -x LESSOPEN=\"||/usr/bin/lesspipe.sh %s\"\ndeclare -x LOGNAME=\"root\"\n```\n\n显示**单个全局变量的值**，例如：HOME、PATH\n```\n[root@aliyun-hk1 profile.d]# env|grep HOME\nHOME=/root\n[root@aliyun-hk1 profile.d]# env|grep PATH\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 profile.d]# echo $HOME\n/root\n[root@aliyun-hk1 profile.d]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 profile.d]#\n```\n\n**全局环境变量**一般在以下几处定义或配置, 从优先级的高低分为/etc/profile、/etc/bashrc、/etc/profile.d/\n```\n[root@aliyun-hk1 profile.d]# cat /etc/profile\n# /etc/profile\n​\n# System wide environment and startup programs, for login setup\n# Functions and aliases go in /etc/bashrc\n​\n# It's NOT a good idea to change this file unless you know what you\n# are doing. It's much better to create a custom.sh shell script in\n# /etc/profile.d/ to make custom changes to your environment, as this\n# will prevent the need for merging in future updates.\n​\npathmunge () {\n    case \":${PATH}:\" in\n        *:\"$1\":*)\n            ;;\n        *)\n            if [ \"$2\" = \"after\" ] ; then\n                PATH=$PATH:$1\n            else\n                PATH=$1:$PATH\n            fi\n    esac\n}\n\n[root@aliyun-hk1 profile.d]# cat /etc/bashrc\n# /etc/bashrc\n​\n# System wide functions and aliases\n# Environment stuff goes in /etc/profile\n​\n# It's NOT a good idea to change this file unless you know what you\n# are doing. It's much better to create a custom.sh shell script in\n# /etc/profile.d/ to make custom changes to your environment, as this\n# will prevent the need for merging in future updates.\n​\n[root@aliyun-hk1 profile.d]# cd /etc/profile.d/\n[root@aliyun-hk1 profile.d]# ll\ntotal 64\n-rw-r--r--  1 root root  771 Sep 27  2018 256term.csh\n-rw-r--r--  1 root root  841 Sep 27  2018 256term.sh\n-rw-r--r--. 1 root root  196 Mar 25  2017 colorgrep.csh\n-rw-r--r--. 1 root root  201 Mar 25  2017 colorgrep.sh\n-rw-r--r--. 1 root root 1741 Apr 11  2018 colorls.csh\n-rw-r--r--. 1 root root 1606 Apr 11  2018 colorls.sh\n-rw-r--r--. 1 root root   80 Apr 11  2018 csh.local\n-rw-r--r--  1 root root 1706 Sep 27  2018 lang.csh\n-rw-r--r--  1 root root 2703 Sep 27  2018 lang.sh\n-rw-r--r--. 1 root root  123 Jul 31  2015 less.csh\n-rw-r--r--. 1 root root  121 Jul 31  2015 less.sh\n-rw-r--r--. 1 root root   81 Apr 11  2018 sh.local\n-rw-r--r--  1 root root  105 Apr 11  2018 vim.csh\n-rw-r--r--  1 root root  269 Apr 11  2018 vim.sh\n-rw-r--r--. 1 root root  164 Jan 28  2014 which2.csh\n-rw-r--r--. 1 root root  169 Jan 28  2014 which2.sh\n```\n\n**局部环境变量**可以分为**用户级环境变量**和**进程级环境变量**。用户级环境变量在当前用户的任何shell都有效，进程级环境变量只在运行进程的shell中有效。\n\n\n**用户级环境变量**在​这个用户shell启动的时候会自动加载，按照顺序运行第一个被找到的文件，后面的直接忽略。这些文件都在当前用户的​家目录下以隐藏文件的形式存在，用户可以根据实际需要进行增删改​。如果修改配置文件后必须重新登陆该用户或者执行source filename 或者 . filename​才会生效。\n```\n~/.bash_profile 1​\n~/.bashrc\n~/.bash_login 2​\n~/.profile 3\n```\n\n**进程级环境变量**在运行这个进程时临时定义，只在当前进程的shell及子shell中有效，想在子shell有效，需要使用export 变量名。​每个进程的shell及子shell也会自动继承全局环境变量。\n```\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# name=robin\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# export name\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot      3142  3140  0 00:21 pts/0    00:00:00 -bash\nroot      3189  3142  0 00:22 pts/0    00:00:00 bash\nroot      3189  3142  0 00:22 pts/0    00:00:00 bash\nroot      3216  3189  0 00:22 pts/0    00:00:00 ps -f\n[root@aliyun-hk1 ~]# exit\nexit\n[root@aliyun-hk1 ~]# exit\nexit\n[root@aliyun-hk1 ~]# echo $name\n​\n[root@aliyun-hk1 ~]#\n```","slug":"linux/linux_env_var","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdesa002z0en7etw6xstd","content":"<p>我们只要使用linux shell，就避免不了<strong>环境变量</strong>这个话题，大家最开始接触环境变量估计都从接触PATH环境变量开始。<br><a id=\"more\"></a></p>\n<p><strong>环境变量</strong>按照生效范围可以分为<strong>全局环境变量</strong>和<strong>局部环境变量</strong>。全局环境变量对于shell会话和所有生成的子shell都是可见的；局部环境变量只对当前shell有效。Linux系统在你开始bash会话时就会设置一些全局环境变量，而且变量名都是大写，以区别于普通的环境变量。</p>\n<p>使用printenv、env或export，可以查看这些默认的<strong>全局环境变量</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# printenv</span><br><span class=\"line\">XDG_SESSION_ID=1541</span><br><span class=\"line\">HOSTNAME=aliyun-hk1</span><br><span class=\"line\">TERM=cygwin</span><br><span class=\"line\">SHELL=/bin/bash</span><br><span class=\"line\">HISTSIZE=1000</span><br><span class=\"line\">SSH_CLIENT=222.90.142.215 54197 22</span><br><span class=\"line\">SSH_TTY=/dev/pts/0</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# env</span><br><span class=\"line\">XDG_SESSION_ID=16</span><br><span class=\"line\">HOSTNAME=aliyun-hk1</span><br><span class=\"line\">TERM=cygwin</span><br><span class=\"line\">SHELL=/bin/bash</span><br><span class=\"line\">HISTSIZE=1000</span><br><span class=\"line\">SSH_CLIENT=222.90.142.205 64344 22</span><br><span class=\"line\">OLDPWD=/apps/ansible-test</span><br><span class=\"line\">SSH_TTY=/dev/pts/1</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# export</span><br><span class=\"line\">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class=\"line\">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class=\"line\">declare -x HOME=&quot;/root&quot;</span><br><span class=\"line\">declare -x HOSTNAME=&quot;aliyun-hk1&quot;</span><br><span class=\"line\">declare -x LANG=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;</span><br><span class=\"line\">declare -x LOGNAME=&quot;root&quot;</span><br></pre></td></tr></table></figure></p>\n<p>显示<strong>单个全局变量的值</strong>，例如：HOME、PATH<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# env|grep HOME</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# env|grep PATH</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# echo $HOME</span><br><span class=\"line\">/root</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>全局环境变量</strong>一般在以下几处定义或配置, 从优先级的高低分为/etc/profile、/etc/bashrc、/etc/profile.d/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# cat /etc/profile</span><br><span class=\"line\"># /etc/profile</span><br><span class=\"line\">​</span><br><span class=\"line\"># System wide environment and startup programs, for login setup</span><br><span class=\"line\"># Functions and aliases go in /etc/bashrc</span><br><span class=\"line\">​</span><br><span class=\"line\"># It&apos;s NOT a good idea to change this file unless you know what you</span><br><span class=\"line\"># are doing. It&apos;s much better to create a custom.sh shell script in</span><br><span class=\"line\"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class=\"line\"># will prevent the need for merging in future updates.</span><br><span class=\"line\">​</span><br><span class=\"line\">pathmunge () &#123;</span><br><span class=\"line\">    case &quot;:$&#123;PATH&#125;:&quot; in</span><br><span class=\"line\">        *:&quot;$1&quot;:*)</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        *)</span><br><span class=\"line\">            if [ &quot;$2&quot; = &quot;after&quot; ] ; then</span><br><span class=\"line\">                PATH=$PATH:$1</span><br><span class=\"line\">            else</span><br><span class=\"line\">                PATH=$1:$PATH</span><br><span class=\"line\">            fi</span><br><span class=\"line\">    esac</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# cat /etc/bashrc</span><br><span class=\"line\"># /etc/bashrc</span><br><span class=\"line\">​</span><br><span class=\"line\"># System wide functions and aliases</span><br><span class=\"line\"># Environment stuff goes in /etc/profile</span><br><span class=\"line\">​</span><br><span class=\"line\"># It&apos;s NOT a good idea to change this file unless you know what you</span><br><span class=\"line\"># are doing. It&apos;s much better to create a custom.sh shell script in</span><br><span class=\"line\"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class=\"line\"># will prevent the need for merging in future updates.</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# cd /etc/profile.d/</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# ll</span><br><span class=\"line\">total 64</span><br><span class=\"line\">-rw-r--r--  1 root root  771 Sep 27  2018 256term.csh</span><br><span class=\"line\">-rw-r--r--  1 root root  841 Sep 27  2018 256term.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  196 Mar 25  2017 colorgrep.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  201 Mar 25  2017 colorgrep.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root 1741 Apr 11  2018 colorls.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root 1606 Apr 11  2018 colorls.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root   80 Apr 11  2018 csh.local</span><br><span class=\"line\">-rw-r--r--  1 root root 1706 Sep 27  2018 lang.csh</span><br><span class=\"line\">-rw-r--r--  1 root root 2703 Sep 27  2018 lang.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  123 Jul 31  2015 less.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  121 Jul 31  2015 less.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root   81 Apr 11  2018 sh.local</span><br><span class=\"line\">-rw-r--r--  1 root root  105 Apr 11  2018 vim.csh</span><br><span class=\"line\">-rw-r--r--  1 root root  269 Apr 11  2018 vim.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  164 Jan 28  2014 which2.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  169 Jan 28  2014 which2.sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>局部环境变量</strong>可以分为<strong>用户级环境变量</strong>和<strong>进程级环境变量</strong>。用户级环境变量在当前用户的任何shell都有效，进程级环境变量只在运行进程的shell中有效。</p>\n<p><strong>用户级环境变量</strong>在​这个用户shell启动的时候会自动加载，按照顺序运行第一个被找到的文件，后面的直接忽略。这些文件都在当前用户的​家目录下以隐藏文件的形式存在，用户可以根据实际需要进行增删改​。如果修改配置文件后必须重新登陆该用户或者执行source filename 或者 . filename​才会生效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile 1​</span><br><span class=\"line\">~/.bashrc</span><br><span class=\"line\">~/.bash_login 2​</span><br><span class=\"line\">~/.profile 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>进程级环境变量</strong>在运行这个进程时临时定义，只在当前进程的shell及子shell中有效，想在子shell有效，需要使用export 变量名。​每个进程的shell及子shell也会自动继承全局环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root      3142  3140  0 00:21 pts/0    00:00:00 -bash</span><br><span class=\"line\">root      3189  3142  0 00:22 pts/0    00:00:00 bash</span><br><span class=\"line\">root      3189  3142  0 00:22 pts/0    00:00:00 bash</span><br><span class=\"line\">root      3216  3189  0 00:22 pts/0    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@aliyun-hk1 ~]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>我们只要使用linux shell，就避免不了<strong>环境变量</strong>这个话题，大家最开始接触环境变量估计都从接触PATH环境变量开始。<br>","more":"</p>\n<p><strong>环境变量</strong>按照生效范围可以分为<strong>全局环境变量</strong>和<strong>局部环境变量</strong>。全局环境变量对于shell会话和所有生成的子shell都是可见的；局部环境变量只对当前shell有效。Linux系统在你开始bash会话时就会设置一些全局环境变量，而且变量名都是大写，以区别于普通的环境变量。</p>\n<p>使用printenv、env或export，可以查看这些默认的<strong>全局环境变量</strong>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# printenv</span><br><span class=\"line\">XDG_SESSION_ID=1541</span><br><span class=\"line\">HOSTNAME=aliyun-hk1</span><br><span class=\"line\">TERM=cygwin</span><br><span class=\"line\">SHELL=/bin/bash</span><br><span class=\"line\">HISTSIZE=1000</span><br><span class=\"line\">SSH_CLIENT=222.90.142.215 54197 22</span><br><span class=\"line\">SSH_TTY=/dev/pts/0</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# env</span><br><span class=\"line\">XDG_SESSION_ID=16</span><br><span class=\"line\">HOSTNAME=aliyun-hk1</span><br><span class=\"line\">TERM=cygwin</span><br><span class=\"line\">SHELL=/bin/bash</span><br><span class=\"line\">HISTSIZE=1000</span><br><span class=\"line\">SSH_CLIENT=222.90.142.205 64344 22</span><br><span class=\"line\">OLDPWD=/apps/ansible-test</span><br><span class=\"line\">SSH_TTY=/dev/pts/1</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# export</span><br><span class=\"line\">declare -x HISTCONTROL=&quot;ignoredups&quot;</span><br><span class=\"line\">declare -x HISTSIZE=&quot;1000&quot;</span><br><span class=\"line\">declare -x HOME=&quot;/root&quot;</span><br><span class=\"line\">declare -x HOSTNAME=&quot;aliyun-hk1&quot;</span><br><span class=\"line\">declare -x LANG=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;</span><br><span class=\"line\">declare -x LOGNAME=&quot;root&quot;</span><br></pre></td></tr></table></figure></p>\n<p>显示<strong>单个全局变量的值</strong>，例如：HOME、PATH<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# env|grep HOME</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# env|grep PATH</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# echo $HOME</span><br><span class=\"line\">/root</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>全局环境变量</strong>一般在以下几处定义或配置, 从优先级的高低分为/etc/profile、/etc/bashrc、/etc/profile.d/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 profile.d]# cat /etc/profile</span><br><span class=\"line\"># /etc/profile</span><br><span class=\"line\">​</span><br><span class=\"line\"># System wide environment and startup programs, for login setup</span><br><span class=\"line\"># Functions and aliases go in /etc/bashrc</span><br><span class=\"line\">​</span><br><span class=\"line\"># It&apos;s NOT a good idea to change this file unless you know what you</span><br><span class=\"line\"># are doing. It&apos;s much better to create a custom.sh shell script in</span><br><span class=\"line\"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class=\"line\"># will prevent the need for merging in future updates.</span><br><span class=\"line\">​</span><br><span class=\"line\">pathmunge () &#123;</span><br><span class=\"line\">    case &quot;:$&#123;PATH&#125;:&quot; in</span><br><span class=\"line\">        *:&quot;$1&quot;:*)</span><br><span class=\"line\">            ;;</span><br><span class=\"line\">        *)</span><br><span class=\"line\">            if [ &quot;$2&quot; = &quot;after&quot; ] ; then</span><br><span class=\"line\">                PATH=$PATH:$1</span><br><span class=\"line\">            else</span><br><span class=\"line\">                PATH=$1:$PATH</span><br><span class=\"line\">            fi</span><br><span class=\"line\">    esac</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# cat /etc/bashrc</span><br><span class=\"line\"># /etc/bashrc</span><br><span class=\"line\">​</span><br><span class=\"line\"># System wide functions and aliases</span><br><span class=\"line\"># Environment stuff goes in /etc/profile</span><br><span class=\"line\">​</span><br><span class=\"line\"># It&apos;s NOT a good idea to change this file unless you know what you</span><br><span class=\"line\"># are doing. It&apos;s much better to create a custom.sh shell script in</span><br><span class=\"line\"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class=\"line\"># will prevent the need for merging in future updates.</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# cd /etc/profile.d/</span><br><span class=\"line\">[root@aliyun-hk1 profile.d]# ll</span><br><span class=\"line\">total 64</span><br><span class=\"line\">-rw-r--r--  1 root root  771 Sep 27  2018 256term.csh</span><br><span class=\"line\">-rw-r--r--  1 root root  841 Sep 27  2018 256term.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  196 Mar 25  2017 colorgrep.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  201 Mar 25  2017 colorgrep.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root 1741 Apr 11  2018 colorls.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root 1606 Apr 11  2018 colorls.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root   80 Apr 11  2018 csh.local</span><br><span class=\"line\">-rw-r--r--  1 root root 1706 Sep 27  2018 lang.csh</span><br><span class=\"line\">-rw-r--r--  1 root root 2703 Sep 27  2018 lang.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  123 Jul 31  2015 less.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  121 Jul 31  2015 less.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root   81 Apr 11  2018 sh.local</span><br><span class=\"line\">-rw-r--r--  1 root root  105 Apr 11  2018 vim.csh</span><br><span class=\"line\">-rw-r--r--  1 root root  269 Apr 11  2018 vim.sh</span><br><span class=\"line\">-rw-r--r--. 1 root root  164 Jan 28  2014 which2.csh</span><br><span class=\"line\">-rw-r--r--. 1 root root  169 Jan 28  2014 which2.sh</span><br></pre></td></tr></table></figure></p>\n<p><strong>局部环境变量</strong>可以分为<strong>用户级环境变量</strong>和<strong>进程级环境变量</strong>。用户级环境变量在当前用户的任何shell都有效，进程级环境变量只在运行进程的shell中有效。</p>\n<p><strong>用户级环境变量</strong>在​这个用户shell启动的时候会自动加载，按照顺序运行第一个被找到的文件，后面的直接忽略。这些文件都在当前用户的​家目录下以隐藏文件的形式存在，用户可以根据实际需要进行增删改​。如果修改配置文件后必须重新登陆该用户或者执行source filename 或者 . filename​才会生效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile 1​</span><br><span class=\"line\">~/.bashrc</span><br><span class=\"line\">~/.bash_login 2​</span><br><span class=\"line\">~/.profile 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>进程级环境变量</strong>在运行这个进程时临时定义，只在当前进程的shell及子shell中有效，想在子shell有效，需要使用export 变量名。​每个进程的shell及子shell也会自动继承全局环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root      3142  3140  0 00:21 pts/0    00:00:00 -bash</span><br><span class=\"line\">root      3189  3142  0 00:22 pts/0    00:00:00 bash</span><br><span class=\"line\">root      3189  3142  0 00:22 pts/0    00:00:00 bash</span><br><span class=\"line\">root      3216  3189  0 00:22 pts/0    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@aliyun-hk1 ~]# exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">​</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>"},{"title":"Redhat7 开机启动服务","date":"2019-07-30T18:27:37.000Z","_content":"\nlinux 系统运行的好多zi定义的服务需要开机自动启动，一般有以下思路：\n#### 1.自定义os服务，将服务设置为开机启动。\n#### 2.chkconfig 增加项目，并且设定为开机启动。\n<!--more-->\n\n```\n#!/bin/sh\n### BEGIN INIT INFO\n \n# Provides: jboss\n \n# Required-Start: $local_fs $remote_fs $network $syslog\n \n# Required-Stop: $local_fs $remote_fs $network $syslog\n \n# Default-Start: 2 3 4 5\n \n# Default-Stop: 0 1 6\n \n# Short-Description: Management of JBoss AS v7.x\n \n### END INIT INFO\n \ncase \"$1\" in\n \nstart)\n \necho \"Starting JBoss\"\n \nsudo -u javau sh /apps/xxx/scripts/TPS/startJBoss --instanceName=xxxx\n \n;;\n \nstop)\n \necho \"Stopping JBoss\"\n \nsudo -u javau sh /apps/xxx/scripts/TPS/stopJBoss --instanceName=xxxxx\n \n;;\n \nlog)\n \necho \"Showing server.log...\"\n \ntail -1000f /apps/xxx/logs/jboss-eap/700/TPS/xxxxx/server.log\n \n;;\n \n*)\n \necho \"Usage: /etc/init.d/jboss {start|stop|log}\"\n \nexit 1\n \n;; esac\n \nexit 0\n```","source":"_posts/linux/linux_auto_start.md","raw":"---\ntitle: Redhat7 开机启动服务\ndate: 2019-07-30 18:27:37\ntags: linux\ncategories: linux\n---\n\nlinux 系统运行的好多zi定义的服务需要开机自动启动，一般有以下思路：\n#### 1.自定义os服务，将服务设置为开机启动。\n#### 2.chkconfig 增加项目，并且设定为开机启动。\n<!--more-->\n\n```\n#!/bin/sh\n### BEGIN INIT INFO\n \n# Provides: jboss\n \n# Required-Start: $local_fs $remote_fs $network $syslog\n \n# Required-Stop: $local_fs $remote_fs $network $syslog\n \n# Default-Start: 2 3 4 5\n \n# Default-Stop: 0 1 6\n \n# Short-Description: Management of JBoss AS v7.x\n \n### END INIT INFO\n \ncase \"$1\" in\n \nstart)\n \necho \"Starting JBoss\"\n \nsudo -u javau sh /apps/xxx/scripts/TPS/startJBoss --instanceName=xxxx\n \n;;\n \nstop)\n \necho \"Stopping JBoss\"\n \nsudo -u javau sh /apps/xxx/scripts/TPS/stopJBoss --instanceName=xxxxx\n \n;;\n \nlog)\n \necho \"Showing server.log...\"\n \ntail -1000f /apps/xxx/logs/jboss-eap/700/TPS/xxxxx/server.log\n \n;;\n \n*)\n \necho \"Usage: /etc/init.d/jboss {start|stop|log}\"\n \nexit 1\n \n;; esac\n \nexit 0\n```","slug":"linux/linux_auto_start","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdesc00330en720e5dwak","content":"<p>linux 系统运行的好多zi定义的服务需要开机自动启动，一般有以下思路：</p>\n<h4 id=\"1-自定义os服务，将服务设置为开机启动。\"><a href=\"#1-自定义os服务，将服务设置为开机启动。\" class=\"headerlink\" title=\"1.自定义os服务，将服务设置为开机启动。\"></a>1.自定义os服务，将服务设置为开机启动。</h4><h4 id=\"2-chkconfig-增加项目，并且设定为开机启动。\"><a href=\"#2-chkconfig-增加项目，并且设定为开机启动。\" class=\"headerlink\" title=\"2.chkconfig 增加项目，并且设定为开机启动。\"></a>2.chkconfig 增加项目，并且设定为开机启动。</h4><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">### BEGIN INIT INFO</span><br><span class=\"line\"> </span><br><span class=\"line\"># Provides: jboss</span><br><span class=\"line\"> </span><br><span class=\"line\"># Required-Start: $local_fs $remote_fs $network $syslog</span><br><span class=\"line\"> </span><br><span class=\"line\"># Required-Stop: $local_fs $remote_fs $network $syslog</span><br><span class=\"line\"> </span><br><span class=\"line\"># Default-Start: 2 3 4 5</span><br><span class=\"line\"> </span><br><span class=\"line\"># Default-Stop: 0 1 6</span><br><span class=\"line\"> </span><br><span class=\"line\"># Short-Description: Management of JBoss AS v7.x</span><br><span class=\"line\"> </span><br><span class=\"line\">### END INIT INFO</span><br><span class=\"line\"> </span><br><span class=\"line\">case &quot;$1&quot; in</span><br><span class=\"line\"> </span><br><span class=\"line\">start)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Starting JBoss&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">sudo -u javau sh /apps/xxx/scripts/TPS/startJBoss --instanceName=xxxx</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">stop)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Stopping JBoss&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">sudo -u javau sh /apps/xxx/scripts/TPS/stopJBoss --instanceName=xxxxx</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">log)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Showing server.log...&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">tail -1000f /apps/xxx/logs/jboss-eap/700/TPS/xxxxx/server.log</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">*)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Usage: /etc/init.d/jboss &#123;start|stop|log&#125;&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">exit 1</span><br><span class=\"line\"> </span><br><span class=\"line\">;; esac</span><br><span class=\"line\"> </span><br><span class=\"line\">exit 0</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>linux 系统运行的好多zi定义的服务需要开机自动启动，一般有以下思路：</p>\n<h4 id=\"1-自定义os服务，将服务设置为开机启动。\"><a href=\"#1-自定义os服务，将服务设置为开机启动。\" class=\"headerlink\" title=\"1.自定义os服务，将服务设置为开机启动。\"></a>1.自定义os服务，将服务设置为开机启动。</h4><h4 id=\"2-chkconfig-增加项目，并且设定为开机启动。\"><a href=\"#2-chkconfig-增加项目，并且设定为开机启动。\" class=\"headerlink\" title=\"2.chkconfig 增加项目，并且设定为开机启动。\"></a>2.chkconfig 增加项目，并且设定为开机启动。</h4>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">### BEGIN INIT INFO</span><br><span class=\"line\"> </span><br><span class=\"line\"># Provides: jboss</span><br><span class=\"line\"> </span><br><span class=\"line\"># Required-Start: $local_fs $remote_fs $network $syslog</span><br><span class=\"line\"> </span><br><span class=\"line\"># Required-Stop: $local_fs $remote_fs $network $syslog</span><br><span class=\"line\"> </span><br><span class=\"line\"># Default-Start: 2 3 4 5</span><br><span class=\"line\"> </span><br><span class=\"line\"># Default-Stop: 0 1 6</span><br><span class=\"line\"> </span><br><span class=\"line\"># Short-Description: Management of JBoss AS v7.x</span><br><span class=\"line\"> </span><br><span class=\"line\">### END INIT INFO</span><br><span class=\"line\"> </span><br><span class=\"line\">case &quot;$1&quot; in</span><br><span class=\"line\"> </span><br><span class=\"line\">start)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Starting JBoss&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">sudo -u javau sh /apps/xxx/scripts/TPS/startJBoss --instanceName=xxxx</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">stop)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Stopping JBoss&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">sudo -u javau sh /apps/xxx/scripts/TPS/stopJBoss --instanceName=xxxxx</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">log)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Showing server.log...&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">tail -1000f /apps/xxx/logs/jboss-eap/700/TPS/xxxxx/server.log</span><br><span class=\"line\"> </span><br><span class=\"line\">;;</span><br><span class=\"line\"> </span><br><span class=\"line\">*)</span><br><span class=\"line\"> </span><br><span class=\"line\">echo &quot;Usage: /etc/init.d/jboss &#123;start|stop|log&#125;&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">exit 1</span><br><span class=\"line\"> </span><br><span class=\"line\">;; esac</span><br><span class=\"line\"> </span><br><span class=\"line\">exit 0</span><br></pre></td></tr></table></figure>"},{"title":"Linux之shell命令别名","date":"2020-03-13T23:45:37.000Z","_content":"\n为什么每当你执行rm file_name的时候，会提示你确认并输入y后才会执行删除动作，而不忽略或直接删除？为什么每当你执行cp的时候，如果存在重名文件会提示你是否覆盖，而不忽略？ 为什么执行mv命令的时候，目标位置有重名文件会提示你是否覆盖？其实，是因为shell环境给这些命令定义了别名（alias name)。\n\n<!--more-->\n\n我们来查询下当前shell，定义了哪些别名，使用alias查询别名\n```\n[root@aliyun-hk1 linux-shell-test]# alias\nalias cp='cp -i'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n```\n\n当我们编写ansible脚本或者shell脚本的时候，为了防止目标服务器shell环境别名命令的差异导致的一系列问题，我们可以主动临时禁用别名，使用\\cmd或者unalias cmd\n```\n[root@aliyun-hk1 linux-shell-test]# touch 1\n[root@aliyun-hk1 linux-shell-test]# rm 1\nrm: remove regular empty file ‘1’? y\n[root@aliyun-hk1 linux-shell-test]# \\rm 3\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n在自动化运维时代，我是不推荐定义太多的shell命令别名，除非这个server 是你自己使用的。当然定义少量的命令别名也是有好处理的，将复杂命令定义成别名，方面我们手工运维时提高效率。自动化运维时代嘛，难免有时候还是要手工在server 排查一些问题的。如何定义别名，请参考man alias帮助手册。\n\n最后回答下最开始的提问，其实很简单，因为别名在发挥作用。​","source":"_posts/linux/linux_alias_use.md","raw":"---\ntitle: Linux之shell命令别名\ndate: 2020-03-13 23:45:37\ntags: shell\ncategories: linux\n---\n\n为什么每当你执行rm file_name的时候，会提示你确认并输入y后才会执行删除动作，而不忽略或直接删除？为什么每当你执行cp的时候，如果存在重名文件会提示你是否覆盖，而不忽略？ 为什么执行mv命令的时候，目标位置有重名文件会提示你是否覆盖？其实，是因为shell环境给这些命令定义了别名（alias name)。\n\n<!--more-->\n\n我们来查询下当前shell，定义了哪些别名，使用alias查询别名\n```\n[root@aliyun-hk1 linux-shell-test]# alias\nalias cp='cp -i'\nalias egrep='egrep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias grep='grep --color=auto'\nalias l.='ls -d .* --color=auto'\nalias ll='ls -l --color=auto'\nalias ls='ls --color=auto'\nalias mv='mv -i'\nalias rm='rm -i'\nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n```\n\n当我们编写ansible脚本或者shell脚本的时候，为了防止目标服务器shell环境别名命令的差异导致的一系列问题，我们可以主动临时禁用别名，使用\\cmd或者unalias cmd\n```\n[root@aliyun-hk1 linux-shell-test]# touch 1\n[root@aliyun-hk1 linux-shell-test]# rm 1\nrm: remove regular empty file ‘1’? y\n[root@aliyun-hk1 linux-shell-test]# \\rm 3\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n在自动化运维时代，我是不推荐定义太多的shell命令别名，除非这个server 是你自己使用的。当然定义少量的命令别名也是有好处理的，将复杂命令定义成别名，方面我们手工运维时提高效率。自动化运维时代嘛，难免有时候还是要手工在server 排查一些问题的。如何定义别名，请参考man alias帮助手册。\n\n最后回答下最开始的提问，其实很简单，因为别名在发挥作用。​","slug":"linux/linux_alias_use","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdese00350en7g33jv1xq","content":"<p>为什么每当你执行rm file_name的时候，会提示你确认并输入y后才会执行删除动作，而不忽略或直接删除？为什么每当你执行cp的时候，如果存在重名文件会提示你是否覆盖，而不忽略？ 为什么执行mv命令的时候，目标位置有重名文件会提示你是否覆盖？其实，是因为shell环境给这些命令定义了别名（alias name)。</p>\n<a id=\"more\"></a>\n<p>我们来查询下当前shell，定义了哪些别名，使用alias查询别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# alias</span><br><span class=\"line\">alias cp=&apos;cp -i&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias mv=&apos;mv -i&apos;</span><br><span class=\"line\">alias rm=&apos;rm -i&apos;</span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure></p>\n<p>当我们编写ansible脚本或者shell脚本的时候，为了防止目标服务器shell环境别名命令的差异导致的一系列问题，我们可以主动临时禁用别名，使用\\cmd或者unalias cmd<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# touch 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# rm 1</span><br><span class=\"line\">rm: remove regular empty file ‘1’? y</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# \\rm 3</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>在自动化运维时代，我是不推荐定义太多的shell命令别名，除非这个server 是你自己使用的。当然定义少量的命令别名也是有好处理的，将复杂命令定义成别名，方面我们手工运维时提高效率。自动化运维时代嘛，难免有时候还是要手工在server 排查一些问题的。如何定义别名，请参考man alias帮助手册。</p>\n<p>最后回答下最开始的提问，其实很简单，因为别名在发挥作用。​</p>\n","site":{"data":{}},"excerpt":"<p>为什么每当你执行rm file_name的时候，会提示你确认并输入y后才会执行删除动作，而不忽略或直接删除？为什么每当你执行cp的时候，如果存在重名文件会提示你是否覆盖，而不忽略？ 为什么执行mv命令的时候，目标位置有重名文件会提示你是否覆盖？其实，是因为shell环境给这些命令定义了别名（alias name)。</p>","more":"<p>我们来查询下当前shell，定义了哪些别名，使用alias查询别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# alias</span><br><span class=\"line\">alias cp=&apos;cp -i&apos;</span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;</span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;</span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;</span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;</span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;</span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;</span><br><span class=\"line\">alias mv=&apos;mv -i&apos;</span><br><span class=\"line\">alias rm=&apos;rm -i&apos;</span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br></pre></td></tr></table></figure></p>\n<p>当我们编写ansible脚本或者shell脚本的时候，为了防止目标服务器shell环境别名命令的差异导致的一系列问题，我们可以主动临时禁用别名，使用\\cmd或者unalias cmd<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# touch 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# rm 1</span><br><span class=\"line\">rm: remove regular empty file ‘1’? y</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# \\rm 3</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>在自动化运维时代，我是不推荐定义太多的shell命令别名，除非这个server 是你自己使用的。当然定义少量的命令别名也是有好处理的，将复杂命令定义成别名，方面我们手工运维时提高效率。自动化运维时代嘛，难免有时候还是要手工在server 排查一些问题的。如何定义别名，请参考man alias帮助手册。</p>\n<p>最后回答下最开始的提问，其实很简单，因为别名在发挥作用。​</p>"},{"title":"Linux之文件与目录权限","date":"2020-03-10T23:08:09.000Z","_content":"\nLinux最优秀的地方之一，就在于它的多用户、多任务环境。为了方便每个用户的使用和数据安全，Linux有严格而又强大的文件和目录管理机制。\n<!--more-->\n\nLinux系统文件和目录权限，**按照身份**可以分为，owner、group、others，例如这个文件夹里的文件，owner是root，group也是root，others是指其他人。\n```\n[root@aliyun-hk1 httpd]# ll\ntotal 12\ndrwxr-xr-x 2 root root 4096 Feb 27 01:06 conf\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d\nlrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -> ../../var/log/httpd\nlrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -> ../../usr/lib64/httpd/modules\nlrwxrwxrwx 1 root root   10 Feb 27 01:06 run -> /run/httpd\n```\n\nLinux系统文件和目录权限，**按照操作类型**可以分为，read、write、execute，例如文件夹conf的权限，从左往右看，d代表conf是一个目录，rwx代表ower的权限为读写执行，r-x代表组成员的权限为读执行权限，r-x代表其他人的权限也为读执行权限。例如log最左边是l代表它是一个软连接，如果最左边是-代表它是一个文件。\n```\n[root@aliyun-hk1 httpd]# ll\ntotal 12\ndrwxr-xr-x 2 root root 4096 Feb 27 01:06 conf\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d\nlrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -> ../../var/log/httpd\nlrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -> ../../usr/lib64/httpd/modules\nlrwxrwxrwx 1 root root   10 Feb 27 01:06 run -> /run/httpd\n```\n\nLinux系统，文件的读权限r代表用户可以查看文件里的内容，可以执行类似cat的命令；文件的写权限w代表用户可以修改文件内容，可以执行类似sed的命令，文件的执行权限x代表用户可以把文件内容当作shell脚本一样执行，可以执行bash file_name命令。这个比较好理解，就不用举例了。\n\n\nLinux系统，目录的权限一般都是r-x组合，用户可以查看目录内容或者进入到目录，rwx组合用户可以对目录进行任何操作。当目录具有单独的r、w、x权限时，没有实际的用途，例如r权限代表用户具有读取目录结构列表的权限，w权限代表用户有修改目录结构的权限，x权限代表用户能否进入该目录成为工作目录而已。\n\n\nLinux文件和目录权限修改，可以使用chown修改文件和目录ower和group的身份，使用chmod可以修改文件和目录的读写执行权限。\n```\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]# chmod 755 1\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rwxr-xr-x 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]# chown robin:robin 2\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root     0 Mar  3 23:32 0\n-rwxr-xr-x 1 root  root     0 Mar 11 00:36 1\ndrwxr-xr-x 2 robin robin 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]#\n```\n\nLinux系统，在每个shell环境都有一个默认权限概念，使用umask可以获取当前shell的默认权限。umask决定，你直接使用mkdir新建目录或者使用touch新建文件时的默认权限。例如root用户的默认umask为0022，则新建文件的默认权限为644，(-rw-rw-rw-)-(-----w--w-)=(-rw-r--r--)，新建目录的默认权限为755，(-rwxrwxrwx)-(-----w--w-)=(-rwxr-xr-x) 这种用字符计算的方式是我跟高手鸟哥学习的，保证有效。之前用数字相减的方法有漏洞，不要使用！\n```\n[root@aliyun-hk1 linux-shell-test]# umask\n0022\n[root@aliyun-hk1 linux-shell-test]# touch 1\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 40\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\n[root@aliyun-hk1 linux-shell-test]# mkdir 2\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n```","source":"_posts/linux/linux_file_dir_permission.md","raw":"---\ntitle: Linux之文件与目录权限\ndate: 2020-03-10 23:08:09\ntags: file\ncategories: linux\n---\n\nLinux最优秀的地方之一，就在于它的多用户、多任务环境。为了方便每个用户的使用和数据安全，Linux有严格而又强大的文件和目录管理机制。\n<!--more-->\n\nLinux系统文件和目录权限，**按照身份**可以分为，owner、group、others，例如这个文件夹里的文件，owner是root，group也是root，others是指其他人。\n```\n[root@aliyun-hk1 httpd]# ll\ntotal 12\ndrwxr-xr-x 2 root root 4096 Feb 27 01:06 conf\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d\nlrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -> ../../var/log/httpd\nlrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -> ../../usr/lib64/httpd/modules\nlrwxrwxrwx 1 root root   10 Feb 27 01:06 run -> /run/httpd\n```\n\nLinux系统文件和目录权限，**按照操作类型**可以分为，read、write、execute，例如文件夹conf的权限，从左往右看，d代表conf是一个目录，rwx代表ower的权限为读写执行，r-x代表组成员的权限为读执行权限，r-x代表其他人的权限也为读执行权限。例如log最左边是l代表它是一个软连接，如果最左边是-代表它是一个文件。\n```\n[root@aliyun-hk1 httpd]# ll\ntotal 12\ndrwxr-xr-x 2 root root 4096 Feb 27 01:06 conf\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d\ndrwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d\nlrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -> ../../var/log/httpd\nlrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -> ../../usr/lib64/httpd/modules\nlrwxrwxrwx 1 root root   10 Feb 27 01:06 run -> /run/httpd\n```\n\nLinux系统，文件的读权限r代表用户可以查看文件里的内容，可以执行类似cat的命令；文件的写权限w代表用户可以修改文件内容，可以执行类似sed的命令，文件的执行权限x代表用户可以把文件内容当作shell脚本一样执行，可以执行bash file_name命令。这个比较好理解，就不用举例了。\n\n\nLinux系统，目录的权限一般都是r-x组合，用户可以查看目录内容或者进入到目录，rwx组合用户可以对目录进行任何操作。当目录具有单独的r、w、x权限时，没有实际的用途，例如r权限代表用户具有读取目录结构列表的权限，w权限代表用户有修改目录结构的权限，x权限代表用户能否进入该目录成为工作目录而已。\n\n\nLinux文件和目录权限修改，可以使用chown修改文件和目录ower和group的身份，使用chmod可以修改文件和目录的读写执行权限。\n```\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]# chmod 755 1\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rwxr-xr-x 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]# chown robin:robin 2\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root     0 Mar  3 23:32 0\n-rwxr-xr-x 1 root  root     0 Mar 11 00:36 1\ndrwxr-xr-x 2 robin robin 4096 Mar 11 00:36 2\n[root@aliyun-hk1 linux-shell-test]#\n```\n\nLinux系统，在每个shell环境都有一个默认权限概念，使用umask可以获取当前shell的默认权限。umask决定，你直接使用mkdir新建目录或者使用touch新建文件时的默认权限。例如root用户的默认umask为0022，则新建文件的默认权限为644，(-rw-rw-rw-)-(-----w--w-)=(-rw-r--r--)，新建目录的默认权限为755，(-rwxrwxrwx)-(-----w--w-)=(-rwxr-xr-x) 这种用字符计算的方式是我跟高手鸟哥学习的，保证有效。之前用数字相减的方法有漏洞，不要使用！\n```\n[root@aliyun-hk1 linux-shell-test]# umask\n0022\n[root@aliyun-hk1 linux-shell-test]# touch 1\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 40\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\n[root@aliyun-hk1 linux-shell-test]# mkdir 2\n[root@aliyun-hk1 linux-shell-test]# ll\ntotal 44\n-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0\n-rw-r--r-- 1 root  root    0 Mar 11 00:36 1\ndrwxr-xr-x 2 root  root 4096 Mar 11 00:36 2\n```","slug":"linux/linux_file_dir_permission","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeso00390en7yazj4lzx","content":"<p>Linux最优秀的地方之一，就在于它的多用户、多任务环境。为了方便每个用户的使用和数据安全，Linux有严格而又强大的文件和目录管理机制。<br><a id=\"more\"></a></p>\n<p>Linux系统文件和目录权限，<strong>按照身份</strong>可以分为，owner、group、others，例如这个文件夹里的文件，owner是root，group也是root，others是指其他人。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 httpd]# ll</span><br><span class=\"line\">total 12</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Feb 27 01:06 conf</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d</span><br><span class=\"line\">lrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -&gt; ../../var/log/httpd</span><br><span class=\"line\">lrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -&gt; ../../usr/lib64/httpd/modules</span><br><span class=\"line\">lrwxrwxrwx 1 root root   10 Feb 27 01:06 run -&gt; /run/httpd</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统文件和目录权限，<strong>按照操作类型</strong>可以分为，read、write、execute，例如文件夹conf的权限，从左往右看，d代表conf是一个目录，rwx代表ower的权限为读写执行，r-x代表组成员的权限为读执行权限，r-x代表其他人的权限也为读执行权限。例如log最左边是l代表它是一个软连接，如果最左边是-代表它是一个文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 httpd]# ll</span><br><span class=\"line\">total 12</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Feb 27 01:06 conf</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d</span><br><span class=\"line\">lrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -&gt; ../../var/log/httpd</span><br><span class=\"line\">lrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -&gt; ../../usr/lib64/httpd/modules</span><br><span class=\"line\">lrwxrwxrwx 1 root root   10 Feb 27 01:06 run -&gt; /run/httpd</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，文件的读权限r代表用户可以查看文件里的内容，可以执行类似cat的命令；文件的写权限w代表用户可以修改文件内容，可以执行类似sed的命令，文件的执行权限x代表用户可以把文件内容当作shell脚本一样执行，可以执行bash file_name命令。这个比较好理解，就不用举例了。</p>\n<p>Linux系统，目录的权限一般都是r-x组合，用户可以查看目录内容或者进入到目录，rwx组合用户可以对目录进行任何操作。当目录具有单独的r、w、x权限时，没有实际的用途，例如r权限代表用户具有读取目录结构列表的权限，w权限代表用户有修改目录结构的权限，x权限代表用户能否进入该目录成为工作目录而已。</p>\n<p>Linux文件和目录权限修改，可以使用chown修改文件和目录ower和group的身份，使用chmod可以修改文件和目录的读写执行权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chown robin:robin 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root     0 Mar  3 23:32 0</span><br><span class=\"line\">-rwxr-xr-x 1 root  root     0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 robin robin 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，在每个shell环境都有一个默认权限概念，使用umask可以获取当前shell的默认权限。umask决定，你直接使用mkdir新建目录或者使用touch新建文件时的默认权限。例如root用户的默认umask为0022，则新建文件的默认权限为644，(-rw-rw-rw-)-(—–w–w-)=(-rw-r–r–)，新建目录的默认权限为755，(-rwxrwxrwx)-(—–w–w-)=(-rwxr-xr-x) 这种用字符计算的方式是我跟高手鸟哥学习的，保证有效。之前用数字相减的方法有漏洞，不要使用！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# umask</span><br><span class=\"line\">0022</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# touch 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 40</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# mkdir 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Linux最优秀的地方之一，就在于它的多用户、多任务环境。为了方便每个用户的使用和数据安全，Linux有严格而又强大的文件和目录管理机制。<br>","more":"</p>\n<p>Linux系统文件和目录权限，<strong>按照身份</strong>可以分为，owner、group、others，例如这个文件夹里的文件，owner是root，group也是root，others是指其他人。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 httpd]# ll</span><br><span class=\"line\">total 12</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Feb 27 01:06 conf</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d</span><br><span class=\"line\">lrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -&gt; ../../var/log/httpd</span><br><span class=\"line\">lrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -&gt; ../../usr/lib64/httpd/modules</span><br><span class=\"line\">lrwxrwxrwx 1 root root   10 Feb 27 01:06 run -&gt; /run/httpd</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统文件和目录权限，<strong>按照操作类型</strong>可以分为，read、write、execute，例如文件夹conf的权限，从左往右看，d代表conf是一个目录，rwx代表ower的权限为读写执行，r-x代表组成员的权限为读执行权限，r-x代表其他人的权限也为读执行权限。例如log最左边是l代表它是一个软连接，如果最左边是-代表它是一个文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 httpd]# ll</span><br><span class=\"line\">total 12</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Feb 27 01:06 conf</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.d</span><br><span class=\"line\">drwxr-xr-x 2 root root 4096 Mar  8 22:10 conf.modules.d</span><br><span class=\"line\">lrwxrwxrwx 1 root root   19 Feb 27 01:06 logs -&gt; ../../var/log/httpd</span><br><span class=\"line\">lrwxrwxrwx 1 root root   29 Feb 27 01:06 modules -&gt; ../../usr/lib64/httpd/modules</span><br><span class=\"line\">lrwxrwxrwx 1 root root   10 Feb 27 01:06 run -&gt; /run/httpd</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，文件的读权限r代表用户可以查看文件里的内容，可以执行类似cat的命令；文件的写权限w代表用户可以修改文件内容，可以执行类似sed的命令，文件的执行权限x代表用户可以把文件内容当作shell脚本一样执行，可以执行bash file_name命令。这个比较好理解，就不用举例了。</p>\n<p>Linux系统，目录的权限一般都是r-x组合，用户可以查看目录内容或者进入到目录，rwx组合用户可以对目录进行任何操作。当目录具有单独的r、w、x权限时，没有实际的用途，例如r权限代表用户具有读取目录结构列表的权限，w权限代表用户有修改目录结构的权限，x权限代表用户能否进入该目录成为工作目录而已。</p>\n<p>Linux文件和目录权限修改，可以使用chown修改文件和目录ower和group的身份，使用chmod可以修改文件和目录的读写执行权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chown robin:robin 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root     0 Mar  3 23:32 0</span><br><span class=\"line\">-rwxr-xr-x 1 root  root     0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 robin robin 4096 Mar 11 00:36 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，在每个shell环境都有一个默认权限概念，使用umask可以获取当前shell的默认权限。umask决定，你直接使用mkdir新建目录或者使用touch新建文件时的默认权限。例如root用户的默认umask为0022，则新建文件的默认权限为644，(-rw-rw-rw-)-(—–w–w-)=(-rw-r–r–)，新建目录的默认权限为755，(-rwxrwxrwx)-(—–w–w-)=(-rwxr-xr-x) 这种用字符计算的方式是我跟高手鸟哥学习的，保证有效。之前用数字相减的方法有漏洞，不要使用！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# umask</span><br><span class=\"line\">0022</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# touch 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 40</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# mkdir 2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">-rwxr-xr-x 1 root  root    0 Mar  3 23:32 0</span><br><span class=\"line\">-rw-r--r-- 1 root  root    0 Mar 11 00:36 1</span><br><span class=\"line\">drwxr-xr-x 2 root  root 4096 Mar 11 00:36 2</span><br></pre></td></tr></table></figure></p>"},{"title":"linux mount the nas or windows share","date":"2019-11-21T18:27:37.000Z","_content":"\n### refer to:\nhttps://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/\nhttp://linux.vbird.org/linux_server/0330nfs.php\nhttps://www.tutorialspoint.com/unix_commands/showmount.htm\n\n### How to mount nas to a linux folder:\n```bash\nmount -t nfs server_fqdn:/prod/ddddd_dr1   /nas/name1\n```\n\n### How to list nas resource at linus server:\n```bash\nshowmount -d server_fqdn\n```\n","source":"_posts/linux/linux_mount_nas.md","raw":"---\ntitle: linux mount the nas or windows share\ndate: 2019-11-21 18:27:37\ntags: nas\ncategories: linux\n---\n\n### refer to:\nhttps://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/\nhttp://linux.vbird.org/linux_server/0330nfs.php\nhttps://www.tutorialspoint.com/unix_commands/showmount.htm\n\n### How to mount nas to a linux folder:\n```bash\nmount -t nfs server_fqdn:/prod/ddddd_dr1   /nas/name1\n```\n\n### How to list nas resource at linus server:\n```bash\nshowmount -d server_fqdn\n```\n","slug":"linux/linux_mount_nas","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdesq003b0en76y3bpcmp","content":"<h3 id=\"refer-to\"><a href=\"#refer-to\" class=\"headerlink\" title=\"refer to:\"></a>refer to:</h3><p><a href=\"https://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/\" target=\"_blank\" rel=\"noopener\">https://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/</a><br><a href=\"http://linux.vbird.org/linux_server/0330nfs.php\" target=\"_blank\" rel=\"noopener\">http://linux.vbird.org/linux_server/0330nfs.php</a><br><a href=\"https://www.tutorialspoint.com/unix_commands/showmount.htm\" target=\"_blank\" rel=\"noopener\">https://www.tutorialspoint.com/unix_commands/showmount.htm</a></p>\n<h3 id=\"How-to-mount-nas-to-a-linux-folder\"><a href=\"#How-to-mount-nas-to-a-linux-folder\" class=\"headerlink\" title=\"How to mount nas to a linux folder:\"></a>How to mount nas to a linux folder:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t nfs server_fqdn:/prod/ddddd_dr1   /nas/name1</span><br></pre></td></tr></table></figure>\n<h3 id=\"How-to-list-nas-resource-at-linus-server\"><a href=\"#How-to-list-nas-resource-at-linus-server\" class=\"headerlink\" title=\"How to list nas resource at linus server:\"></a>How to list nas resource at linus server:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showmount -d server_fqdn</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"refer-to\"><a href=\"#refer-to\" class=\"headerlink\" title=\"refer to:\"></a>refer to:</h3><p><a href=\"https://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/\" target=\"_blank\" rel=\"noopener\">https://www.seagate.com/cn/zh/support/kb/how-to-mount-nfs-and-cifs-file-systems-on-linux-with-the-seagate-blackarmor-nas-209791en/</a><br><a href=\"http://linux.vbird.org/linux_server/0330nfs.php\" target=\"_blank\" rel=\"noopener\">http://linux.vbird.org/linux_server/0330nfs.php</a><br><a href=\"https://www.tutorialspoint.com/unix_commands/showmount.htm\" target=\"_blank\" rel=\"noopener\">https://www.tutorialspoint.com/unix_commands/showmount.htm</a></p>\n<h3 id=\"How-to-mount-nas-to-a-linux-folder\"><a href=\"#How-to-mount-nas-to-a-linux-folder\" class=\"headerlink\" title=\"How to mount nas to a linux folder:\"></a>How to mount nas to a linux folder:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t nfs server_fqdn:/prod/ddddd_dr1   /nas/name1</span><br></pre></td></tr></table></figure>\n<h3 id=\"How-to-list-nas-resource-at-linus-server\"><a href=\"#How-to-list-nas-resource-at-linus-server\" class=\"headerlink\" title=\"How to list nas resource at linus server:\"></a>How to list nas resource at linus server:</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">showmount -d server_fqdn</span><br></pre></td></tr></table></figure>\n"},{"title":"使用证书登陆Linux服务器","date":"2018-12-03T23:27:37.000Z","_content":"\n当你的运维对象为大量服务器时，使用证书登陆极为迫切。\n<!--more-->\n\n### 主要步骤：\n\n#### 0.私钥放在client，公钥放置在server端。\n\n#### 1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\n\n#### 2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\n\n#### 3.redhat系统的selinux是个很容易忽略的东东，一定要检查。\n\n参考：CentOS 7 SSH使用证书登录 https://blog.csdn.net/long690276759/article/details/53535464","source":"_posts/linux/linux_login_with_cert.md","raw":"---\ntitle: 使用证书登陆Linux服务器\ndate: 2018-12-03 23:27:37\ntags: linux\ncategories: linux\n---\n\n当你的运维对象为大量服务器时，使用证书登陆极为迫切。\n<!--more-->\n\n### 主要步骤：\n\n#### 0.私钥放在client，公钥放置在server端。\n\n#### 1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\n\n#### 2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\n\n#### 3.redhat系统的selinux是个很容易忽略的东东，一定要检查。\n\n参考：CentOS 7 SSH使用证书登录 https://blog.csdn.net/long690276759/article/details/53535464","slug":"linux/linux_login_with_cert","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdess003f0en7317tzn4e","content":"<p>当你的运维对象为大量服务器时，使用证书登陆极为迫切。<br><a id=\"more\"></a></p>\n<h3 id=\"主要步骤：\"><a href=\"#主要步骤：\" class=\"headerlink\" title=\"主要步骤：\"></a>主要步骤：</h3><h4 id=\"0-私钥放在client，公钥放置在server端。\"><a href=\"#0-私钥放在client，公钥放置在server端。\" class=\"headerlink\" title=\"0.私钥放在client，公钥放置在server端。\"></a>0.私钥放在client，公钥放置在server端。</h4><h4 id=\"1-私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\"><a href=\"#1-私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\" class=\"headerlink\" title=\"1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\"></a>1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。</h4><h4 id=\"2-公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\"><a href=\"#2-公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\" class=\"headerlink\" title=\"2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\"></a>2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）</h4><h4 id=\"3-redhat系统的selinux是个很容易忽略的东东，一定要检查。\"><a href=\"#3-redhat系统的selinux是个很容易忽略的东东，一定要检查。\" class=\"headerlink\" title=\"3.redhat系统的selinux是个很容易忽略的东东，一定要检查。\"></a>3.redhat系统的selinux是个很容易忽略的东东，一定要检查。</h4><p>参考：CentOS 7 SSH使用证书登录 <a href=\"https://blog.csdn.net/long690276759/article/details/53535464\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/long690276759/article/details/53535464</a></p>\n","site":{"data":{}},"excerpt":"<p>当你的运维对象为大量服务器时，使用证书登陆极为迫切。<br>","more":"</p>\n<h3 id=\"主要步骤：\"><a href=\"#主要步骤：\" class=\"headerlink\" title=\"主要步骤：\"></a>主要步骤：</h3><h4 id=\"0-私钥放在client，公钥放置在server端。\"><a href=\"#0-私钥放在client，公钥放置在server端。\" class=\"headerlink\" title=\"0.私钥放在client，公钥放置在server端。\"></a>0.私钥放在client，公钥放置在server端。</h4><h4 id=\"1-私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\"><a href=\"#1-私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\" class=\"headerlink\" title=\"1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。\"></a>1.私钥在客户端可以重复使用，可以通过私钥访问多个服务器。</h4><h4 id=\"2-公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\"><a href=\"#2-公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\" class=\"headerlink\" title=\"2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）\"></a>2.公钥必须与私钥配合使用，只有server开启了证书认证，并且添加了公钥数据，client才可以访问。一个server可以添加多个公钥，每段公钥使用空行隔开。（server端修改了相关配置后，需要重启httpd服务）</h4><h4 id=\"3-redhat系统的selinux是个很容易忽略的东东，一定要检查。\"><a href=\"#3-redhat系统的selinux是个很容易忽略的东东，一定要检查。\" class=\"headerlink\" title=\"3.redhat系统的selinux是个很容易忽略的东东，一定要检查。\"></a>3.redhat系统的selinux是个很容易忽略的东东，一定要检查。</h4><p>参考：CentOS 7 SSH使用证书登录 <a href=\"https://blog.csdn.net/long690276759/article/details/53535464\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/long690276759/article/details/53535464</a></p>"},{"title":"Linux之如何学习linux","date":"2020-03-12T23:50:37.000Z","_content":"\n这些天我们也分享了好多linux的内容，从文本相关命令到文件和目录操作命令，也讲了shell、管道、环境变量等内容。其实Linux的内容不仅仅如此，后续我暂时会停止全面讲解基本和常用命令的步伐，会挑选一些重点、难点​内容来分享。今天我来讲讲如何学习Linux​，仅供参考。\n\n<!--more-->\n首先，你要知道linux都有什么东西，通读一遍linux普及的书籍，知道linux能干嘛。这个第一遍，重点学习常见的内容，对于有些既深奥又难理解的概念和命令，先不要碰，否则你​学习的热情就没了。\n\n其次，你要选择一本易读易懂的工具书，我觉得鸟哥的书就很好，​很适合初学者学习，当然对难点的讲解也很深刻。​这个工具书你后面可能需要反复地翻阅和学习。虽然linux自带了帮助文档，使用man可以查到所有命令的帮助文档，但是​那个太全面了，还是没有查阅工具书快速。\n\n然后，接下来就是动手使用linux，这次其实是对第一遍学习的一个验证和纠错的阶段，因为不能保证作者写的东西和你看到并理解的东西完全一致。先自己安装一次linux，熟悉下linux的shell的使用，环境变量概念、linux文件、文本、目录的相关操作，并试图理解他，如果不理解再去看书，再来​实践。linux的设计完全颠覆了我们之前​对操作系统的认识，因为我们之前大部分人玩的是windows。遇到问题阅读高手的书籍、去社区发帖子、​自己通过实践摸索都可以的。\n\n最后，不断的提升自己的​认知水平，这一级就比较难了。这个需要在实践中慢慢来，每次遇到问题要敢于提问，大胆猜想，​仔细求证。学习是个很严肃的事情，不要囫囵吞枣，否则你到头会脑子混乱，一无所知，除过会写几个命令，别的什么都不会。","source":"_posts/linux/linux_how_to_learn.md","raw":"---\ntitle: Linux之如何学习linux\ndate: 2020-03-12 23:50:37\ntags: learn\ncategories: linux\n---\n\n这些天我们也分享了好多linux的内容，从文本相关命令到文件和目录操作命令，也讲了shell、管道、环境变量等内容。其实Linux的内容不仅仅如此，后续我暂时会停止全面讲解基本和常用命令的步伐，会挑选一些重点、难点​内容来分享。今天我来讲讲如何学习Linux​，仅供参考。\n\n<!--more-->\n首先，你要知道linux都有什么东西，通读一遍linux普及的书籍，知道linux能干嘛。这个第一遍，重点学习常见的内容，对于有些既深奥又难理解的概念和命令，先不要碰，否则你​学习的热情就没了。\n\n其次，你要选择一本易读易懂的工具书，我觉得鸟哥的书就很好，​很适合初学者学习，当然对难点的讲解也很深刻。​这个工具书你后面可能需要反复地翻阅和学习。虽然linux自带了帮助文档，使用man可以查到所有命令的帮助文档，但是​那个太全面了，还是没有查阅工具书快速。\n\n然后，接下来就是动手使用linux，这次其实是对第一遍学习的一个验证和纠错的阶段，因为不能保证作者写的东西和你看到并理解的东西完全一致。先自己安装一次linux，熟悉下linux的shell的使用，环境变量概念、linux文件、文本、目录的相关操作，并试图理解他，如果不理解再去看书，再来​实践。linux的设计完全颠覆了我们之前​对操作系统的认识，因为我们之前大部分人玩的是windows。遇到问题阅读高手的书籍、去社区发帖子、​自己通过实践摸索都可以的。\n\n最后，不断的提升自己的​认知水平，这一级就比较难了。这个需要在实践中慢慢来，每次遇到问题要敢于提问，大胆猜想，​仔细求证。学习是个很严肃的事情，不要囫囵吞枣，否则你到头会脑子混乱，一无所知，除过会写几个命令，别的什么都不会。","slug":"linux/linux_how_to_learn","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdesu003h0en7ktqmctjb","content":"<p>这些天我们也分享了好多linux的内容，从文本相关命令到文件和目录操作命令，也讲了shell、管道、环境变量等内容。其实Linux的内容不仅仅如此，后续我暂时会停止全面讲解基本和常用命令的步伐，会挑选一些重点、难点​内容来分享。今天我来讲讲如何学习Linux​，仅供参考。</p>\n<a id=\"more\"></a>\n<p>首先，你要知道linux都有什么东西，通读一遍linux普及的书籍，知道linux能干嘛。这个第一遍，重点学习常见的内容，对于有些既深奥又难理解的概念和命令，先不要碰，否则你​学习的热情就没了。</p>\n<p>其次，你要选择一本易读易懂的工具书，我觉得鸟哥的书就很好，​很适合初学者学习，当然对难点的讲解也很深刻。​这个工具书你后面可能需要反复地翻阅和学习。虽然linux自带了帮助文档，使用man可以查到所有命令的帮助文档，但是​那个太全面了，还是没有查阅工具书快速。</p>\n<p>然后，接下来就是动手使用linux，这次其实是对第一遍学习的一个验证和纠错的阶段，因为不能保证作者写的东西和你看到并理解的东西完全一致。先自己安装一次linux，熟悉下linux的shell的使用，环境变量概念、linux文件、文本、目录的相关操作，并试图理解他，如果不理解再去看书，再来​实践。linux的设计完全颠覆了我们之前​对操作系统的认识，因为我们之前大部分人玩的是windows。遇到问题阅读高手的书籍、去社区发帖子、​自己通过实践摸索都可以的。</p>\n<p>最后，不断的提升自己的​认知水平，这一级就比较难了。这个需要在实践中慢慢来，每次遇到问题要敢于提问，大胆猜想，​仔细求证。学习是个很严肃的事情，不要囫囵吞枣，否则你到头会脑子混乱，一无所知，除过会写几个命令，别的什么都不会。</p>\n","site":{"data":{}},"excerpt":"<p>这些天我们也分享了好多linux的内容，从文本相关命令到文件和目录操作命令，也讲了shell、管道、环境变量等内容。其实Linux的内容不仅仅如此，后续我暂时会停止全面讲解基本和常用命令的步伐，会挑选一些重点、难点​内容来分享。今天我来讲讲如何学习Linux​，仅供参考。</p>","more":"<p>首先，你要知道linux都有什么东西，通读一遍linux普及的书籍，知道linux能干嘛。这个第一遍，重点学习常见的内容，对于有些既深奥又难理解的概念和命令，先不要碰，否则你​学习的热情就没了。</p>\n<p>其次，你要选择一本易读易懂的工具书，我觉得鸟哥的书就很好，​很适合初学者学习，当然对难点的讲解也很深刻。​这个工具书你后面可能需要反复地翻阅和学习。虽然linux自带了帮助文档，使用man可以查到所有命令的帮助文档，但是​那个太全面了，还是没有查阅工具书快速。</p>\n<p>然后，接下来就是动手使用linux，这次其实是对第一遍学习的一个验证和纠错的阶段，因为不能保证作者写的东西和你看到并理解的东西完全一致。先自己安装一次linux，熟悉下linux的shell的使用，环境变量概念、linux文件、文本、目录的相关操作，并试图理解他，如果不理解再去看书，再来​实践。linux的设计完全颠覆了我们之前​对操作系统的认识，因为我们之前大部分人玩的是windows。遇到问题阅读高手的书籍、去社区发帖子、​自己通过实践摸索都可以的。</p>\n<p>最后，不断的提升自己的​认知水平，这一级就比较难了。这个需要在实践中慢慢来，每次遇到问题要敢于提问，大胆猜想，​仔细求证。学习是个很严肃的事情，不要囫囵吞枣，否则你到头会脑子混乱，一无所知，除过会写几个命令，别的什么都不会。</p>"},{"title":"Linux之shell参数传递","date":"2019-03-11T15:15:37.000Z","_content":"\n# 背景\n最近编写ansible脚本，需要自动调用之前写好的shell脚本，由于shell脚本中包含了read命令接收用户的手动输入，为了实现ansible脚本的自动运行，不得不将手动输入转换为自动输入。以下为常见的两种场景：\n\n<!--more-->\n\n# read命令接收输入\n```\n#!/bin/sh\n#file name start.sh\necho \"please input name\"\nread name\necho \"please intput pssword\"\nread password\n\necho $name\necho 'line end'\necho $password\n```\n\n## 第一种方式\n```\necho -e \"robin\\npassword\"|./start.sh\n```\n第一种方式，其实就是使用管道将一个或多个输入传递给待执行的脚本，如果传入多个变量，一定要注意这个\\n，经检验read每次读入一个变量值，遇到\\n则截断。\n\n## 第二种方式\n```\necho -e \"robin\\npassword\" >parm\n./start.sh < parm\n```\n第二种方式，其实就是将一个或多个变量值存入一个参数文件，每个变量以\\n结尾，再将该参数文件传递给shell脚本文件。\n\n## 第三种方式\n```\n使用expect\n```\n由于需要yum install expect 暂未研究。\n\n# $1 $2 .. 接收传入的参数\n```\n#!/bin/sh\n#file name start.sh\nname=$1\npassword=$2\n\necho -e  $name\\n\necho $password\n```\n```\n./start.sh robin password\n```\n这种接收参数的方式，也是最简单的好用的方式，shell文件按照顺序接收传入的参数值。\n\n# 使用getopts接收传入的参数\n```\n#!/bin/sh\n\nwhile getopts \":a:b:c:\" opt\ndo\n   case $opt in\n        a)\n        echo \"参数a的值$OPTARG\"\n        ;;\n        b) echo \"参数b的值$OPTARG\"\n        ;;\n        c) echo \"参数c的值$OPTARG\"\n        ;;\n        ?) echo \"未知参数\"\n           exit 1;;\n   esac\ndone\n```\n\n```\n./start_4.sh -a 1 -b 2\n```","source":"_posts/linux/linux_parameter_send1.md","raw":"---\ntitle: Linux之shell参数传递\ndate: 2019-03-11 15:15:37\ntags: shell\ncategories: linux\n---\n\n# 背景\n最近编写ansible脚本，需要自动调用之前写好的shell脚本，由于shell脚本中包含了read命令接收用户的手动输入，为了实现ansible脚本的自动运行，不得不将手动输入转换为自动输入。以下为常见的两种场景：\n\n<!--more-->\n\n# read命令接收输入\n```\n#!/bin/sh\n#file name start.sh\necho \"please input name\"\nread name\necho \"please intput pssword\"\nread password\n\necho $name\necho 'line end'\necho $password\n```\n\n## 第一种方式\n```\necho -e \"robin\\npassword\"|./start.sh\n```\n第一种方式，其实就是使用管道将一个或多个输入传递给待执行的脚本，如果传入多个变量，一定要注意这个\\n，经检验read每次读入一个变量值，遇到\\n则截断。\n\n## 第二种方式\n```\necho -e \"robin\\npassword\" >parm\n./start.sh < parm\n```\n第二种方式，其实就是将一个或多个变量值存入一个参数文件，每个变量以\\n结尾，再将该参数文件传递给shell脚本文件。\n\n## 第三种方式\n```\n使用expect\n```\n由于需要yum install expect 暂未研究。\n\n# $1 $2 .. 接收传入的参数\n```\n#!/bin/sh\n#file name start.sh\nname=$1\npassword=$2\n\necho -e  $name\\n\necho $password\n```\n```\n./start.sh robin password\n```\n这种接收参数的方式，也是最简单的好用的方式，shell文件按照顺序接收传入的参数值。\n\n# 使用getopts接收传入的参数\n```\n#!/bin/sh\n\nwhile getopts \":a:b:c:\" opt\ndo\n   case $opt in\n        a)\n        echo \"参数a的值$OPTARG\"\n        ;;\n        b) echo \"参数b的值$OPTARG\"\n        ;;\n        c) echo \"参数c的值$OPTARG\"\n        ;;\n        ?) echo \"未知参数\"\n           exit 1;;\n   esac\ndone\n```\n\n```\n./start_4.sh -a 1 -b 2\n```","slug":"linux/linux_parameter_send1","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdesw003m0en7b1cetq5d","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>最近编写ansible脚本，需要自动调用之前写好的shell脚本，由于shell脚本中包含了read命令接收用户的手动输入，为了实现ansible脚本的自动运行，不得不将手动输入转换为自动输入。以下为常见的两种场景：</p>\n<a id=\"more\"></a>\n<h1 id=\"read命令接收输入\"><a href=\"#read命令接收输入\" class=\"headerlink\" title=\"read命令接收输入\"></a>read命令接收输入</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#file name start.sh</span><br><span class=\"line\">echo &quot;please input name&quot;</span><br><span class=\"line\">read name</span><br><span class=\"line\">echo &quot;please intput pssword&quot;</span><br><span class=\"line\">read password</span><br><span class=\"line\"></span><br><span class=\"line\">echo $name</span><br><span class=\"line\">echo &apos;line end&apos;</span><br><span class=\"line\">echo $password</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一种方式\"><a href=\"#第一种方式\" class=\"headerlink\" title=\"第一种方式\"></a>第一种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e &quot;robin\\npassword&quot;|./start.sh</span><br></pre></td></tr></table></figure>\n<p>第一种方式，其实就是使用管道将一个或多个输入传递给待执行的脚本，如果传入多个变量，一定要注意这个\\n，经检验read每次读入一个变量值，遇到\\n则截断。</p>\n<h2 id=\"第二种方式\"><a href=\"#第二种方式\" class=\"headerlink\" title=\"第二种方式\"></a>第二种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e &quot;robin\\npassword&quot; &gt;parm</span><br><span class=\"line\">./start.sh &lt; parm</span><br></pre></td></tr></table></figure>\n<p>第二种方式，其实就是将一个或多个变量值存入一个参数文件，每个变量以\\n结尾，再将该参数文件传递给shell脚本文件。</p>\n<h2 id=\"第三种方式\"><a href=\"#第三种方式\" class=\"headerlink\" title=\"第三种方式\"></a>第三种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用expect</span><br></pre></td></tr></table></figure>\n<p>由于需要yum install expect 暂未研究。</p>\n<h1 id=\"1-2-接收传入的参数\"><a href=\"#1-2-接收传入的参数\" class=\"headerlink\" title=\"$1 $2 .. 接收传入的参数\"></a>$1 $2 .. 接收传入的参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#file name start.sh</span><br><span class=\"line\">name=$1</span><br><span class=\"line\">password=$2</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e  $name\\n</span><br><span class=\"line\">echo $password</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start.sh robin password</span><br></pre></td></tr></table></figure>\n<p>这种接收参数的方式，也是最简单的好用的方式，shell文件按照顺序接收传入的参数值。</p>\n<h1 id=\"使用getopts接收传入的参数\"><a href=\"#使用getopts接收传入的参数\" class=\"headerlink\" title=\"使用getopts接收传入的参数\"></a>使用getopts接收传入的参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">while getopts &quot;:a:b:c:&quot; opt</span><br><span class=\"line\">do</span><br><span class=\"line\">   case $opt in</span><br><span class=\"line\">        a)</span><br><span class=\"line\">        echo &quot;参数a的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        b) echo &quot;参数b的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        c) echo &quot;参数c的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        ?) echo &quot;未知参数&quot;</span><br><span class=\"line\">           exit 1;;</span><br><span class=\"line\">   esac</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start_4.sh -a 1 -b 2</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>最近编写ansible脚本，需要自动调用之前写好的shell脚本，由于shell脚本中包含了read命令接收用户的手动输入，为了实现ansible脚本的自动运行，不得不将手动输入转换为自动输入。以下为常见的两种场景：</p>","more":"<h1 id=\"read命令接收输入\"><a href=\"#read命令接收输入\" class=\"headerlink\" title=\"read命令接收输入\"></a>read命令接收输入</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#file name start.sh</span><br><span class=\"line\">echo &quot;please input name&quot;</span><br><span class=\"line\">read name</span><br><span class=\"line\">echo &quot;please intput pssword&quot;</span><br><span class=\"line\">read password</span><br><span class=\"line\"></span><br><span class=\"line\">echo $name</span><br><span class=\"line\">echo &apos;line end&apos;</span><br><span class=\"line\">echo $password</span><br></pre></td></tr></table></figure>\n<h2 id=\"第一种方式\"><a href=\"#第一种方式\" class=\"headerlink\" title=\"第一种方式\"></a>第一种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e &quot;robin\\npassword&quot;|./start.sh</span><br></pre></td></tr></table></figure>\n<p>第一种方式，其实就是使用管道将一个或多个输入传递给待执行的脚本，如果传入多个变量，一定要注意这个\\n，经检验read每次读入一个变量值，遇到\\n则截断。</p>\n<h2 id=\"第二种方式\"><a href=\"#第二种方式\" class=\"headerlink\" title=\"第二种方式\"></a>第二种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo -e &quot;robin\\npassword&quot; &gt;parm</span><br><span class=\"line\">./start.sh &lt; parm</span><br></pre></td></tr></table></figure>\n<p>第二种方式，其实就是将一个或多个变量值存入一个参数文件，每个变量以\\n结尾，再将该参数文件传递给shell脚本文件。</p>\n<h2 id=\"第三种方式\"><a href=\"#第三种方式\" class=\"headerlink\" title=\"第三种方式\"></a>第三种方式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用expect</span><br></pre></td></tr></table></figure>\n<p>由于需要yum install expect 暂未研究。</p>\n<h1 id=\"1-2-接收传入的参数\"><a href=\"#1-2-接收传入的参数\" class=\"headerlink\" title=\"$1 $2 .. 接收传入的参数\"></a>$1 $2 .. 接收传入的参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#file name start.sh</span><br><span class=\"line\">name=$1</span><br><span class=\"line\">password=$2</span><br><span class=\"line\"></span><br><span class=\"line\">echo -e  $name\\n</span><br><span class=\"line\">echo $password</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start.sh robin password</span><br></pre></td></tr></table></figure>\n<p>这种接收参数的方式，也是最简单的好用的方式，shell文件按照顺序接收传入的参数值。</p>\n<h1 id=\"使用getopts接收传入的参数\"><a href=\"#使用getopts接收传入的参数\" class=\"headerlink\" title=\"使用getopts接收传入的参数\"></a>使用getopts接收传入的参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">while getopts &quot;:a:b:c:&quot; opt</span><br><span class=\"line\">do</span><br><span class=\"line\">   case $opt in</span><br><span class=\"line\">        a)</span><br><span class=\"line\">        echo &quot;参数a的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        b) echo &quot;参数b的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        c) echo &quot;参数c的值$OPTARG&quot;</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">        ?) echo &quot;未知参数&quot;</span><br><span class=\"line\">           exit 1;;</span><br><span class=\"line\">   esac</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start_4.sh -a 1 -b 2</span><br></pre></td></tr></table></figure>"},{"title":"Linux之系统性能优化","date":"2020-03-29T23:00:00.000Z","_content":"\n如果你是操作系统管理员、中间件管理员、数据库管理员或者开发人员，肯定有机会遇到系统运行缓慢相关的问题。\n<!--more-->\n\n\n# 1.内存使用率\n## 1.1 物理内存使用率高\n这个其实是好多linux初学者最开始遇到的问题，刚申请的服务器，还没跑程序就发现物理内存使用率很高，少则80%，90%，有些甚至接近100%。其实，我们是用windows的使用经验就判断linux，当面对物理内存使用率高的时候，才会恐慌。其实，只要物理内存可用不为0，swap几乎还没开始使用，就是安全的。\n```\nMem这一行代表物理内存的使用情况，看available就知道还有多少物理内存空闲。\n[robin@instance-2 ~]$ free -m\n              total        used        free      shared  buff/cache   available\nMem:           3529         327        1420          80        1780        2863\nSwap:             0           0           0\n[robin@instance-2 ~]$ free -g\n              total        used        free      shared  buff/cache   available\nMem:              3           0           1           0           1           2\nSwap:             0           0           0\n\n```\n## 1.2 虚拟内存使用高\n大家都知道，虚拟内存是使用硬盘作为内存的一种方式，性能想比较物理内存，差很多。所以当swap开始大于零的时候，就要去考虑增大内存，或者去查找程序本身的错误了。\n```\nSwap这一行代表虚拟内存的使用情况，看used这个值，就知道已经使用了都少swap内存。\n[robin@instance-2 ~]$ free -m\n              total        used        free      shared  buff/cache   available\nMem:           3529         327        1420          80        1780        2863\nSwap:             0           0           0\n[robin@instance-2 ~]$ free -g\n              total        used        free      shared  buff/cache   available\nMem:              3           0           1           0           1           2\nSwap:             0           0           0\n\n```\n## 1.3 找出消耗内存的元凶\n当某一天你发现，LInux操作系统的内存严重不足，已经开始大量使用 Swap，甚至都用了多少G的Swap内存。\n### 1.3.1 使用top查看物理内存占用\n```\n使用top命令，并且CTRL+M就会按照内存的使用率给进程排序。\ntop - 00:10:46 up 8 days,  1:39,  2 users,  load average: 0.00, 0.01, 0.05\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2305048 free,  1037268 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439208 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n 4956 jenkins   20   0 4657416 783268  22980 S   0.3 20.9  29:19.30 java\n 4796 mysql     20   0  978712  94268   7028 S   0.3  2.5  16:59.70 mysqld\n\n```\n### 1.3.2 循环查询虚拟内存占用\n```\n第一列为PID，第二列为这个进程占用的虚拟内存\n[root@localhost ~]# for i in $( cd /proc;ls |grep \"^[0-9]\"|awk ' $0 >100') ;do awk '/Swap:/{a=a+$2}END{print '\"$i\"',a/1024\"M\"}' /proc/$i/smaps 2>/dev/null ; done | sort -k2nr | head -10\n112 0M\n1149 0M\n1155 0M\n1169 0M\n1172 0M\n1184 0M\n1187 0M\n1191 0M\n1198 0M\n1210 0M\n\n```\n# 2.CPU使用率\n其实，总结来讲判断目前的CPU运算时间够不够用，主要看内存的使用率和系统负载，只要系统负载不高，一般都很安全。\n## 2.1 CPU使用率高但负载低\n这种情况说明，目前CPU资源较为紧张，但是不是性能的瓶颈，CPU基本满足要求。我们一般看负载，只要负载是CPU核心数的0.75倍，就很安全。第一行的load average: 0.00, 0.01, 0.05就代表最近5分钟、10分钟、15分钟的平均负载，第三行的%Cpu(s)代表整体的CPU使用率。\n```\n使用top的时候，默认情况下，看到第三行的CPU使用率，那是一个整体的CPU使用率。\ntop - 00:17:55 up 8 days,  1:46,  2 users,  load average: 0.00, 0.01, 0.05\nTasks: 161 total,   1 running, 160 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304972 free,  1037344 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439132 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n25965 root      20   0  162024   2380   1600 R   1.7  0.1   0:01.42 top\n 5302 robin     20   0  149972   2128   1600 S   0.8  0.1  12:36.84 ping\n\n使用top的时候，如果还想查看单个CPU的使用情况，输入1就可以了。\ntop - 00:19:22 up 8 days,  1:48,  2 users,  load average: 0.17, 0.06, 0.06\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304932 free,  1037384 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439092 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n25967 root      20   0  162024   2380   1600 R   1.5  0.1   0:00.03 top\n    1 root      20   0  190976   3988   2620 S   0.0  0.1   1:11.02 systemd\n    2 root      20   0       0      0      0 S   0.0  0.0   0:00.19 kthreadd\n```\n## 2.2 CPU使用率高负载也高\n这种情况说明，目前CPU资源紧张，而且已经造成了系统缓慢，一般负载大于CPU核心数的0.75倍，我们就认为负载也高了。这个时候，就要查查CPU都是被谁占用了，而且可能还伴随着IO或者其他访问的问题。\n# 3.系统负载高\n系统负载的概念，在Linux系统管理方面非常实用，通过平均负载值就可以快速判断当前系统的安全状况。\n## 3.1 使用uptime查看负载\n```\n其实，uptime不仅能查看系统开机多久了，而且也能查看系统在5min 10min 15min的平均负载情况。\n[root@localhost ~]# uptime\n 00:23:41 up 8 days,  1:52,  2 users,  load average: 0.00, 0.03, 0.05\n[root@localhost ~]#\n```\n## 3.2 使用top查看负载\n```\ntop是我认为的linux系统最好的性能优化命令或者工具，第一行load average: 0.00, 0.02, 0.05就是值最近5min 10min 15min的平均负载。\n[root@localhost ~]# top\ntop - 00:24:38 up 8 days,  1:53,  2 users,  load average: 0.00, 0.02, 0.05\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  1.4 us,  2.9 sy,  0.0 ni, 95.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304984 free,  1037212 used,   413952 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439168 avail Mem\n```\n## 3.3 定位负载高的原因\n先使用top命令查看整体的负载情况。\n```\ntop - 00:13:53 up 12 min,  2 users,  load average: 0.00, 0.11, 0.13\nTasks: 170 total,   1 running, 169 sleeping,   0 stopped,   0 zombie\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu2  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756132 total,  1771392 free,  1026936 used,   957804 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2467352 avail Mem\n```\n第一行的load average后面的三个数值分别代表最近1分钟、5分钟、15分钟的负载数据。\n第二行显示不同类型的task，其中zombie也就是传说的僵尸进程，如果存在可能会严重影响整体性能。\n第三行到第6行，显示每个cpu的使用情况，us代表用户占用CPU百分比，sy代表内核占用CPU百分比，id代表空闲CPU百分比，wa代表IO等待占用的CPU百分比，wa如果超过了30要高度注意了，可能瓶颈在磁盘I/O\n\n再用vmstat命令查看更加全面的性能指标。\n```\n[root@localhost ~]# vmstat 3\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 0  0      0 1771872   2132 955968    0    0    68    84   81  119  2  0 98  0  0\n```\nr表示运行队列(就是说多少个进程真的分配到CPU)，一般不能超过CPU数量。\nb表示堵塞的进程数量，只要大于0了，就会影响性能。\nswpd 表示虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了。\nfree表示物理内存还有多少空闲。\ncache直接用来记忆我们打开的文件，给文件做缓冲。\nsi代表每秒从磁盘读入虚拟内存的大小，只要大于0就说明内存不足了。\nso代表每秒虚拟内存写入磁盘的大小，只要大于0就说明内存不足了。\nbi/bo代表块设备每秒接收和发送的块数据。\nin 代表每秒CPU的中断次数，包括时间中断。\ncs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。\nus 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。\nsy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。\nid  空闲 CPU时间。\nwt 等待IO CPU时间，一般来说，id + us + sy+ wa = 100。","source":"_posts/linux/linux_performance.md","raw":"---\ntitle: Linux之系统性能优化\ndate: 2020-03-29 23:00:00\ntags: linux\ncategories: linux\n---\n\n如果你是操作系统管理员、中间件管理员、数据库管理员或者开发人员，肯定有机会遇到系统运行缓慢相关的问题。\n<!--more-->\n\n\n# 1.内存使用率\n## 1.1 物理内存使用率高\n这个其实是好多linux初学者最开始遇到的问题，刚申请的服务器，还没跑程序就发现物理内存使用率很高，少则80%，90%，有些甚至接近100%。其实，我们是用windows的使用经验就判断linux，当面对物理内存使用率高的时候，才会恐慌。其实，只要物理内存可用不为0，swap几乎还没开始使用，就是安全的。\n```\nMem这一行代表物理内存的使用情况，看available就知道还有多少物理内存空闲。\n[robin@instance-2 ~]$ free -m\n              total        used        free      shared  buff/cache   available\nMem:           3529         327        1420          80        1780        2863\nSwap:             0           0           0\n[robin@instance-2 ~]$ free -g\n              total        used        free      shared  buff/cache   available\nMem:              3           0           1           0           1           2\nSwap:             0           0           0\n\n```\n## 1.2 虚拟内存使用高\n大家都知道，虚拟内存是使用硬盘作为内存的一种方式，性能想比较物理内存，差很多。所以当swap开始大于零的时候，就要去考虑增大内存，或者去查找程序本身的错误了。\n```\nSwap这一行代表虚拟内存的使用情况，看used这个值，就知道已经使用了都少swap内存。\n[robin@instance-2 ~]$ free -m\n              total        used        free      shared  buff/cache   available\nMem:           3529         327        1420          80        1780        2863\nSwap:             0           0           0\n[robin@instance-2 ~]$ free -g\n              total        used        free      shared  buff/cache   available\nMem:              3           0           1           0           1           2\nSwap:             0           0           0\n\n```\n## 1.3 找出消耗内存的元凶\n当某一天你发现，LInux操作系统的内存严重不足，已经开始大量使用 Swap，甚至都用了多少G的Swap内存。\n### 1.3.1 使用top查看物理内存占用\n```\n使用top命令，并且CTRL+M就会按照内存的使用率给进程排序。\ntop - 00:10:46 up 8 days,  1:39,  2 users,  load average: 0.00, 0.01, 0.05\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2305048 free,  1037268 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439208 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n 4956 jenkins   20   0 4657416 783268  22980 S   0.3 20.9  29:19.30 java\n 4796 mysql     20   0  978712  94268   7028 S   0.3  2.5  16:59.70 mysqld\n\n```\n### 1.3.2 循环查询虚拟内存占用\n```\n第一列为PID，第二列为这个进程占用的虚拟内存\n[root@localhost ~]# for i in $( cd /proc;ls |grep \"^[0-9]\"|awk ' $0 >100') ;do awk '/Swap:/{a=a+$2}END{print '\"$i\"',a/1024\"M\"}' /proc/$i/smaps 2>/dev/null ; done | sort -k2nr | head -10\n112 0M\n1149 0M\n1155 0M\n1169 0M\n1172 0M\n1184 0M\n1187 0M\n1191 0M\n1198 0M\n1210 0M\n\n```\n# 2.CPU使用率\n其实，总结来讲判断目前的CPU运算时间够不够用，主要看内存的使用率和系统负载，只要系统负载不高，一般都很安全。\n## 2.1 CPU使用率高但负载低\n这种情况说明，目前CPU资源较为紧张，但是不是性能的瓶颈，CPU基本满足要求。我们一般看负载，只要负载是CPU核心数的0.75倍，就很安全。第一行的load average: 0.00, 0.01, 0.05就代表最近5分钟、10分钟、15分钟的平均负载，第三行的%Cpu(s)代表整体的CPU使用率。\n```\n使用top的时候，默认情况下，看到第三行的CPU使用率，那是一个整体的CPU使用率。\ntop - 00:17:55 up 8 days,  1:46,  2 users,  load average: 0.00, 0.01, 0.05\nTasks: 161 total,   1 running, 160 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304972 free,  1037344 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439132 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n25965 root      20   0  162024   2380   1600 R   1.7  0.1   0:01.42 top\n 5302 robin     20   0  149972   2128   1600 S   0.8  0.1  12:36.84 ping\n\n使用top的时候，如果还想查看单个CPU的使用情况，输入1就可以了。\ntop - 00:19:22 up 8 days,  1:48,  2 users,  load average: 0.17, 0.06, 0.06\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304932 free,  1037384 used,   413832 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439092 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n25967 root      20   0  162024   2380   1600 R   1.5  0.1   0:00.03 top\n    1 root      20   0  190976   3988   2620 S   0.0  0.1   1:11.02 systemd\n    2 root      20   0       0      0      0 S   0.0  0.0   0:00.19 kthreadd\n```\n## 2.2 CPU使用率高负载也高\n这种情况说明，目前CPU资源紧张，而且已经造成了系统缓慢，一般负载大于CPU核心数的0.75倍，我们就认为负载也高了。这个时候，就要查查CPU都是被谁占用了，而且可能还伴随着IO或者其他访问的问题。\n# 3.系统负载高\n系统负载的概念，在Linux系统管理方面非常实用，通过平均负载值就可以快速判断当前系统的安全状况。\n## 3.1 使用uptime查看负载\n```\n其实，uptime不仅能查看系统开机多久了，而且也能查看系统在5min 10min 15min的平均负载情况。\n[root@localhost ~]# uptime\n 00:23:41 up 8 days,  1:52,  2 users,  load average: 0.00, 0.03, 0.05\n[root@localhost ~]#\n```\n## 3.2 使用top查看负载\n```\ntop是我认为的linux系统最好的性能优化命令或者工具，第一行load average: 0.00, 0.02, 0.05就是值最近5min 10min 15min的平均负载。\n[root@localhost ~]# top\ntop - 00:24:38 up 8 days,  1:53,  2 users,  load average: 0.00, 0.02, 0.05\nTasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  1.4 us,  2.9 sy,  0.0 ni, 95.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756148 total,  2304984 free,  1037212 used,   413952 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2439168 avail Mem\n```\n## 3.3 定位负载高的原因\n先使用top命令查看整体的负载情况。\n```\ntop - 00:13:53 up 12 min,  2 users,  load average: 0.00, 0.11, 0.13\nTasks: 170 total,   1 running, 169 sleeping,   0 stopped,   0 zombie\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu2  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  3756132 total,  1771392 free,  1026936 used,   957804 buff/cache\nKiB Swap:  3932156 total,  3932156 free,        0 used.  2467352 avail Mem\n```\n第一行的load average后面的三个数值分别代表最近1分钟、5分钟、15分钟的负载数据。\n第二行显示不同类型的task，其中zombie也就是传说的僵尸进程，如果存在可能会严重影响整体性能。\n第三行到第6行，显示每个cpu的使用情况，us代表用户占用CPU百分比，sy代表内核占用CPU百分比，id代表空闲CPU百分比，wa代表IO等待占用的CPU百分比，wa如果超过了30要高度注意了，可能瓶颈在磁盘I/O\n\n再用vmstat命令查看更加全面的性能指标。\n```\n[root@localhost ~]# vmstat 3\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 0  0      0 1771872   2132 955968    0    0    68    84   81  119  2  0 98  0  0\n```\nr表示运行队列(就是说多少个进程真的分配到CPU)，一般不能超过CPU数量。\nb表示堵塞的进程数量，只要大于0了，就会影响性能。\nswpd 表示虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了。\nfree表示物理内存还有多少空闲。\ncache直接用来记忆我们打开的文件，给文件做缓冲。\nsi代表每秒从磁盘读入虚拟内存的大小，只要大于0就说明内存不足了。\nso代表每秒虚拟内存写入磁盘的大小，只要大于0就说明内存不足了。\nbi/bo代表块设备每秒接收和发送的块数据。\nin 代表每秒CPU的中断次数，包括时间中断。\ncs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。\nus 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。\nsy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。\nid  空闲 CPU时间。\nwt 等待IO CPU时间，一般来说，id + us + sy+ wa = 100。","slug":"linux/linux_performance","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdet0003o0en7d23fo85s","content":"<p>如果你是操作系统管理员、中间件管理员、数据库管理员或者开发人员，肯定有机会遇到系统运行缓慢相关的问题。<br><a id=\"more\"></a></p>\n<h1 id=\"1-内存使用率\"><a href=\"#1-内存使用率\" class=\"headerlink\" title=\"1.内存使用率\"></a>1.内存使用率</h1><h2 id=\"1-1-物理内存使用率高\"><a href=\"#1-1-物理内存使用率高\" class=\"headerlink\" title=\"1.1 物理内存使用率高\"></a>1.1 物理内存使用率高</h2><p>这个其实是好多linux初学者最开始遇到的问题，刚申请的服务器，还没跑程序就发现物理内存使用率很高，少则80%，90%，有些甚至接近100%。其实，我们是用windows的使用经验就判断linux，当面对物理内存使用率高的时候，才会恐慌。其实，只要物理内存可用不为0，swap几乎还没开始使用，就是安全的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mem这一行代表物理内存的使用情况，看available就知道还有多少物理内存空闲。</span><br><span class=\"line\">[robin@instance-2 ~]$ free -m</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           3529         327        1420          80        1780        2863</span><br><span class=\"line\">Swap:             0           0           0</span><br><span class=\"line\">[robin@instance-2 ~]$ free -g</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:              3           0           1           0           1           2</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-虚拟内存使用高\"><a href=\"#1-2-虚拟内存使用高\" class=\"headerlink\" title=\"1.2 虚拟内存使用高\"></a>1.2 虚拟内存使用高</h2><p>大家都知道，虚拟内存是使用硬盘作为内存的一种方式，性能想比较物理内存，差很多。所以当swap开始大于零的时候，就要去考虑增大内存，或者去查找程序本身的错误了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Swap这一行代表虚拟内存的使用情况，看used这个值，就知道已经使用了都少swap内存。</span><br><span class=\"line\">[robin@instance-2 ~]$ free -m</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           3529         327        1420          80        1780        2863</span><br><span class=\"line\">Swap:             0           0           0</span><br><span class=\"line\">[robin@instance-2 ~]$ free -g</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:              3           0           1           0           1           2</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-3-找出消耗内存的元凶\"><a href=\"#1-3-找出消耗内存的元凶\" class=\"headerlink\" title=\"1.3 找出消耗内存的元凶\"></a>1.3 找出消耗内存的元凶</h2><p>当某一天你发现，LInux操作系统的内存严重不足，已经开始大量使用 Swap，甚至都用了多少G的Swap内存。</p>\n<h3 id=\"1-3-1-使用top查看物理内存占用\"><a href=\"#1-3-1-使用top查看物理内存占用\" class=\"headerlink\" title=\"1.3.1 使用top查看物理内存占用\"></a>1.3.1 使用top查看物理内存占用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用top命令，并且CTRL+M就会按照内存的使用率给进程排序。</span><br><span class=\"line\">top - 00:10:46 up 8 days,  1:39,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2305048 free,  1037268 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439208 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\"> 4956 jenkins   20   0 4657416 783268  22980 S   0.3 20.9  29:19.30 java</span><br><span class=\"line\"> 4796 mysql     20   0  978712  94268   7028 S   0.3  2.5  16:59.70 mysqld</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2-循环查询虚拟内存占用\"><a href=\"#1-3-2-循环查询虚拟内存占用\" class=\"headerlink\" title=\"1.3.2 循环查询虚拟内存占用\"></a>1.3.2 循环查询虚拟内存占用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一列为PID，第二列为这个进程占用的虚拟内存</span><br><span class=\"line\">[root@localhost ~]# for i in $( cd /proc;ls |grep &quot;^[0-9]&quot;|awk &apos; $0 &gt;100&apos;) ;do awk &apos;/Swap:/&#123;a=a+$2&#125;END&#123;print &apos;&quot;$i&quot;&apos;,a/1024&quot;M&quot;&#125;&apos; /proc/$i/smaps 2&gt;/dev/null ; done | sort -k2nr | head -10</span><br><span class=\"line\">112 0M</span><br><span class=\"line\">1149 0M</span><br><span class=\"line\">1155 0M</span><br><span class=\"line\">1169 0M</span><br><span class=\"line\">1172 0M</span><br><span class=\"line\">1184 0M</span><br><span class=\"line\">1187 0M</span><br><span class=\"line\">1191 0M</span><br><span class=\"line\">1198 0M</span><br><span class=\"line\">1210 0M</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-CPU使用率\"><a href=\"#2-CPU使用率\" class=\"headerlink\" title=\"2.CPU使用率\"></a>2.CPU使用率</h1><p>其实，总结来讲判断目前的CPU运算时间够不够用，主要看内存的使用率和系统负载，只要系统负载不高，一般都很安全。</p>\n<h2 id=\"2-1-CPU使用率高但负载低\"><a href=\"#2-1-CPU使用率高但负载低\" class=\"headerlink\" title=\"2.1 CPU使用率高但负载低\"></a>2.1 CPU使用率高但负载低</h2><p>这种情况说明，目前CPU资源较为紧张，但是不是性能的瓶颈，CPU基本满足要求。我们一般看负载，只要负载是CPU核心数的0.75倍，就很安全。第一行的load average: 0.00, 0.01, 0.05就代表最近5分钟、10分钟、15分钟的平均负载，第三行的%Cpu(s)代表整体的CPU使用率。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用top的时候，默认情况下，看到第三行的CPU使用率，那是一个整体的CPU使用率。</span><br><span class=\"line\">top - 00:17:55 up 8 days,  1:46,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 161 total,   1 running, 160 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304972 free,  1037344 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439132 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">25965 root      20   0  162024   2380   1600 R   1.7  0.1   0:01.42 top</span><br><span class=\"line\"> 5302 robin     20   0  149972   2128   1600 S   0.8  0.1  12:36.84 ping</span><br><span class=\"line\"></span><br><span class=\"line\">使用top的时候，如果还想查看单个CPU的使用情况，输入1就可以了。</span><br><span class=\"line\">top - 00:19:22 up 8 days,  1:48,  2 users,  load average: 0.17, 0.06, 0.06</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu1  :  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304932 free,  1037384 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439092 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">25967 root      20   0  162024   2380   1600 R   1.5  0.1   0:00.03 top</span><br><span class=\"line\">    1 root      20   0  190976   3988   2620 S   0.0  0.1   1:11.02 systemd</span><br><span class=\"line\">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.19 kthreadd</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-CPU使用率高负载也高\"><a href=\"#2-2-CPU使用率高负载也高\" class=\"headerlink\" title=\"2.2 CPU使用率高负载也高\"></a>2.2 CPU使用率高负载也高</h2><p>这种情况说明，目前CPU资源紧张，而且已经造成了系统缓慢，一般负载大于CPU核心数的0.75倍，我们就认为负载也高了。这个时候，就要查查CPU都是被谁占用了，而且可能还伴随着IO或者其他访问的问题。</p>\n<h1 id=\"3-系统负载高\"><a href=\"#3-系统负载高\" class=\"headerlink\" title=\"3.系统负载高\"></a>3.系统负载高</h1><p>系统负载的概念，在Linux系统管理方面非常实用，通过平均负载值就可以快速判断当前系统的安全状况。</p>\n<h2 id=\"3-1-使用uptime查看负载\"><a href=\"#3-1-使用uptime查看负载\" class=\"headerlink\" title=\"3.1 使用uptime查看负载\"></a>3.1 使用uptime查看负载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其实，uptime不仅能查看系统开机多久了，而且也能查看系统在5min 10min 15min的平均负载情况。</span><br><span class=\"line\">[root@localhost ~]# uptime</span><br><span class=\"line\"> 00:23:41 up 8 days,  1:52,  2 users,  load average: 0.00, 0.03, 0.05</span><br><span class=\"line\">[root@localhost ~]#</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-使用top查看负载\"><a href=\"#3-2-使用top查看负载\" class=\"headerlink\" title=\"3.2 使用top查看负载\"></a>3.2 使用top查看负载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top是我认为的linux系统最好的性能优化命令或者工具，第一行load average: 0.00, 0.02, 0.05就是值最近5min 10min 15min的平均负载。</span><br><span class=\"line\">[root@localhost ~]# top</span><br><span class=\"line\">top - 00:24:38 up 8 days,  1:53,  2 users,  load average: 0.00, 0.02, 0.05</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  1.4 us,  2.9 sy,  0.0 ni, 95.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304984 free,  1037212 used,   413952 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439168 avail Mem</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-定位负载高的原因\"><a href=\"#3-3-定位负载高的原因\" class=\"headerlink\" title=\"3.3 定位负载高的原因\"></a>3.3 定位负载高的原因</h2><p>先使用top命令查看整体的负载情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 00:13:53 up 12 min,  2 users,  load average: 0.00, 0.11, 0.13</span><br><span class=\"line\">Tasks: 170 total,   1 running, 169 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu2  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756132 total,  1771392 free,  1026936 used,   957804 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2467352 avail Mem</span><br></pre></td></tr></table></figure></p>\n<p>第一行的load average后面的三个数值分别代表最近1分钟、5分钟、15分钟的负载数据。<br>第二行显示不同类型的task，其中zombie也就是传说的僵尸进程，如果存在可能会严重影响整体性能。<br>第三行到第6行，显示每个cpu的使用情况，us代表用户占用CPU百分比，sy代表内核占用CPU百分比，id代表空闲CPU百分比，wa代表IO等待占用的CPU百分比，wa如果超过了30要高度注意了，可能瓶颈在磁盘I/O</p>\n<p>再用vmstat命令查看更加全面的性能指标。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# vmstat 3</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 0  0      0 1771872   2132 955968    0    0    68    84   81  119  2  0 98  0  0</span><br></pre></td></tr></table></figure></p>\n<p>r表示运行队列(就是说多少个进程真的分配到CPU)，一般不能超过CPU数量。<br>b表示堵塞的进程数量，只要大于0了，就会影响性能。<br>swpd 表示虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了。<br>free表示物理内存还有多少空闲。<br>cache直接用来记忆我们打开的文件，给文件做缓冲。<br>si代表每秒从磁盘读入虚拟内存的大小，只要大于0就说明内存不足了。<br>so代表每秒虚拟内存写入磁盘的大小，只要大于0就说明内存不足了。<br>bi/bo代表块设备每秒接收和发送的块数据。<br>in 代表每秒CPU的中断次数，包括时间中断。<br>cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。<br>us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。<br>sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。<br>id  空闲 CPU时间。<br>wt 等待IO CPU时间，一般来说，id + us + sy+ wa = 100。</p>\n","site":{"data":{}},"excerpt":"<p>如果你是操作系统管理员、中间件管理员、数据库管理员或者开发人员，肯定有机会遇到系统运行缓慢相关的问题。<br>","more":"</p>\n<h1 id=\"1-内存使用率\"><a href=\"#1-内存使用率\" class=\"headerlink\" title=\"1.内存使用率\"></a>1.内存使用率</h1><h2 id=\"1-1-物理内存使用率高\"><a href=\"#1-1-物理内存使用率高\" class=\"headerlink\" title=\"1.1 物理内存使用率高\"></a>1.1 物理内存使用率高</h2><p>这个其实是好多linux初学者最开始遇到的问题，刚申请的服务器，还没跑程序就发现物理内存使用率很高，少则80%，90%，有些甚至接近100%。其实，我们是用windows的使用经验就判断linux，当面对物理内存使用率高的时候，才会恐慌。其实，只要物理内存可用不为0，swap几乎还没开始使用，就是安全的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mem这一行代表物理内存的使用情况，看available就知道还有多少物理内存空闲。</span><br><span class=\"line\">[robin@instance-2 ~]$ free -m</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           3529         327        1420          80        1780        2863</span><br><span class=\"line\">Swap:             0           0           0</span><br><span class=\"line\">[robin@instance-2 ~]$ free -g</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:              3           0           1           0           1           2</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-2-虚拟内存使用高\"><a href=\"#1-2-虚拟内存使用高\" class=\"headerlink\" title=\"1.2 虚拟内存使用高\"></a>1.2 虚拟内存使用高</h2><p>大家都知道，虚拟内存是使用硬盘作为内存的一种方式，性能想比较物理内存，差很多。所以当swap开始大于零的时候，就要去考虑增大内存，或者去查找程序本身的错误了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Swap这一行代表虚拟内存的使用情况，看used这个值，就知道已经使用了都少swap内存。</span><br><span class=\"line\">[robin@instance-2 ~]$ free -m</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           3529         327        1420          80        1780        2863</span><br><span class=\"line\">Swap:             0           0           0</span><br><span class=\"line\">[robin@instance-2 ~]$ free -g</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:              3           0           1           0           1           2</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"1-3-找出消耗内存的元凶\"><a href=\"#1-3-找出消耗内存的元凶\" class=\"headerlink\" title=\"1.3 找出消耗内存的元凶\"></a>1.3 找出消耗内存的元凶</h2><p>当某一天你发现，LInux操作系统的内存严重不足，已经开始大量使用 Swap，甚至都用了多少G的Swap内存。</p>\n<h3 id=\"1-3-1-使用top查看物理内存占用\"><a href=\"#1-3-1-使用top查看物理内存占用\" class=\"headerlink\" title=\"1.3.1 使用top查看物理内存占用\"></a>1.3.1 使用top查看物理内存占用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用top命令，并且CTRL+M就会按照内存的使用率给进程排序。</span><br><span class=\"line\">top - 00:10:46 up 8 days,  1:39,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.1 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2305048 free,  1037268 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439208 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\"> 4956 jenkins   20   0 4657416 783268  22980 S   0.3 20.9  29:19.30 java</span><br><span class=\"line\"> 4796 mysql     20   0  978712  94268   7028 S   0.3  2.5  16:59.70 mysqld</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2-循环查询虚拟内存占用\"><a href=\"#1-3-2-循环查询虚拟内存占用\" class=\"headerlink\" title=\"1.3.2 循环查询虚拟内存占用\"></a>1.3.2 循环查询虚拟内存占用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一列为PID，第二列为这个进程占用的虚拟内存</span><br><span class=\"line\">[root@localhost ~]# for i in $( cd /proc;ls |grep &quot;^[0-9]&quot;|awk &apos; $0 &gt;100&apos;) ;do awk &apos;/Swap:/&#123;a=a+$2&#125;END&#123;print &apos;&quot;$i&quot;&apos;,a/1024&quot;M&quot;&#125;&apos; /proc/$i/smaps 2&gt;/dev/null ; done | sort -k2nr | head -10</span><br><span class=\"line\">112 0M</span><br><span class=\"line\">1149 0M</span><br><span class=\"line\">1155 0M</span><br><span class=\"line\">1169 0M</span><br><span class=\"line\">1172 0M</span><br><span class=\"line\">1184 0M</span><br><span class=\"line\">1187 0M</span><br><span class=\"line\">1191 0M</span><br><span class=\"line\">1198 0M</span><br><span class=\"line\">1210 0M</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-CPU使用率\"><a href=\"#2-CPU使用率\" class=\"headerlink\" title=\"2.CPU使用率\"></a>2.CPU使用率</h1><p>其实，总结来讲判断目前的CPU运算时间够不够用，主要看内存的使用率和系统负载，只要系统负载不高，一般都很安全。</p>\n<h2 id=\"2-1-CPU使用率高但负载低\"><a href=\"#2-1-CPU使用率高但负载低\" class=\"headerlink\" title=\"2.1 CPU使用率高但负载低\"></a>2.1 CPU使用率高但负载低</h2><p>这种情况说明，目前CPU资源较为紧张，但是不是性能的瓶颈，CPU基本满足要求。我们一般看负载，只要负载是CPU核心数的0.75倍，就很安全。第一行的load average: 0.00, 0.01, 0.05就代表最近5分钟、10分钟、15分钟的平均负载，第三行的%Cpu(s)代表整体的CPU使用率。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用top的时候，默认情况下，看到第三行的CPU使用率，那是一个整体的CPU使用率。</span><br><span class=\"line\">top - 00:17:55 up 8 days,  1:46,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks: 161 total,   1 running, 160 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304972 free,  1037344 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439132 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">25965 root      20   0  162024   2380   1600 R   1.7  0.1   0:01.42 top</span><br><span class=\"line\"> 5302 robin     20   0  149972   2128   1600 S   0.8  0.1  12:36.84 ping</span><br><span class=\"line\"></span><br><span class=\"line\">使用top的时候，如果还想查看单个CPU的使用情况，输入1就可以了。</span><br><span class=\"line\">top - 00:19:22 up 8 days,  1:48,  2 users,  load average: 0.17, 0.06, 0.06</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu1  :  0.0 us,  1.5 sy,  0.0 ni, 98.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304932 free,  1037384 used,   413832 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439092 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">25967 root      20   0  162024   2380   1600 R   1.5  0.1   0:00.03 top</span><br><span class=\"line\">    1 root      20   0  190976   3988   2620 S   0.0  0.1   1:11.02 systemd</span><br><span class=\"line\">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.19 kthreadd</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-CPU使用率高负载也高\"><a href=\"#2-2-CPU使用率高负载也高\" class=\"headerlink\" title=\"2.2 CPU使用率高负载也高\"></a>2.2 CPU使用率高负载也高</h2><p>这种情况说明，目前CPU资源紧张，而且已经造成了系统缓慢，一般负载大于CPU核心数的0.75倍，我们就认为负载也高了。这个时候，就要查查CPU都是被谁占用了，而且可能还伴随着IO或者其他访问的问题。</p>\n<h1 id=\"3-系统负载高\"><a href=\"#3-系统负载高\" class=\"headerlink\" title=\"3.系统负载高\"></a>3.系统负载高</h1><p>系统负载的概念，在Linux系统管理方面非常实用，通过平均负载值就可以快速判断当前系统的安全状况。</p>\n<h2 id=\"3-1-使用uptime查看负载\"><a href=\"#3-1-使用uptime查看负载\" class=\"headerlink\" title=\"3.1 使用uptime查看负载\"></a>3.1 使用uptime查看负载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其实，uptime不仅能查看系统开机多久了，而且也能查看系统在5min 10min 15min的平均负载情况。</span><br><span class=\"line\">[root@localhost ~]# uptime</span><br><span class=\"line\"> 00:23:41 up 8 days,  1:52,  2 users,  load average: 0.00, 0.03, 0.05</span><br><span class=\"line\">[root@localhost ~]#</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-使用top查看负载\"><a href=\"#3-2-使用top查看负载\" class=\"headerlink\" title=\"3.2 使用top查看负载\"></a>3.2 使用top查看负载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top是我认为的linux系统最好的性能优化命令或者工具，第一行load average: 0.00, 0.02, 0.05就是值最近5min 10min 15min的平均负载。</span><br><span class=\"line\">[root@localhost ~]# top</span><br><span class=\"line\">top - 00:24:38 up 8 days,  1:53,  2 users,  load average: 0.00, 0.02, 0.05</span><br><span class=\"line\">Tasks: 162 total,   1 running, 161 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  1.4 us,  2.9 sy,  0.0 ni, 95.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756148 total,  2304984 free,  1037212 used,   413952 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2439168 avail Mem</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-定位负载高的原因\"><a href=\"#3-3-定位负载高的原因\" class=\"headerlink\" title=\"3.3 定位负载高的原因\"></a>3.3 定位负载高的原因</h2><p>先使用top命令查看整体的负载情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 00:13:53 up 12 min,  2 users,  load average: 0.00, 0.11, 0.13</span><br><span class=\"line\">Tasks: 170 total,   1 running, 169 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu2  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :  3756132 total,  1771392 free,  1026936 used,   957804 buff/cache</span><br><span class=\"line\">KiB Swap:  3932156 total,  3932156 free,        0 used.  2467352 avail Mem</span><br></pre></td></tr></table></figure></p>\n<p>第一行的load average后面的三个数值分别代表最近1分钟、5分钟、15分钟的负载数据。<br>第二行显示不同类型的task，其中zombie也就是传说的僵尸进程，如果存在可能会严重影响整体性能。<br>第三行到第6行，显示每个cpu的使用情况，us代表用户占用CPU百分比，sy代表内核占用CPU百分比，id代表空闲CPU百分比，wa代表IO等待占用的CPU百分比，wa如果超过了30要高度注意了，可能瓶颈在磁盘I/O</p>\n<p>再用vmstat命令查看更加全面的性能指标。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# vmstat 3</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 0  0      0 1771872   2132 955968    0    0    68    84   81  119  2  0 98  0  0</span><br></pre></td></tr></table></figure></p>\n<p>r表示运行队列(就是说多少个进程真的分配到CPU)，一般不能超过CPU数量。<br>b表示堵塞的进程数量，只要大于0了，就会影响性能。<br>swpd 表示虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了。<br>free表示物理内存还有多少空闲。<br>cache直接用来记忆我们打开的文件，给文件做缓冲。<br>si代表每秒从磁盘读入虚拟内存的大小，只要大于0就说明内存不足了。<br>so代表每秒虚拟内存写入磁盘的大小，只要大于0就说明内存不足了。<br>bi/bo代表块设备每秒接收和发送的块数据。<br>in 代表每秒CPU的中断次数，包括时间中断。<br>cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。<br>us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。<br>sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。<br>id  空闲 CPU时间。<br>wt 等待IO CPU时间，一般来说，id + us + sy+ wa = 100。</p>"},{"title":"Linux之程序管理","date":"2020-03-24T23:00:00.000Z","_content":"\nLinux系统是一个多任务的开源操作系统，后台运行着很多的进程。今天我们来学习下进程相关的内容。\n<!--more-->\n\n#### 1.1 什么是进程\n在linux系统中，触发任何一个事件时，系统都会将它定义为一个进程，并且给这个进程分配一个PID。\n\n##### 1.1.1 进程与程序\n简单地说，执行一个程序、脚本或命令，就可以触发一个事件并且取得一个PID。在我看来就是内核读取磁盘中的一个程序，并且加载到内存中，给他分配一个进程号PID。总结下来，进程就是一个运行中的程序。\n```\n运行bash后会生成一个子shell，查看其产生的进程\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  3819  3817  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n4 S     0  3875  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep\n0 S     0  3881  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep\n4 S     0  3949  3819  0  80   0 - 28894 do_wai pts/0    00:00:00 bash\n0 R     0  3960  3949  0  80   0 - 38312 -      pts/0    00:00:00 ps\n```\n##### 1.1.2 工作管理（job control )\n将一个命令丢到后台去执行，即在命令末尾增加&，就会产生一个job，包括job number，进程id等，这里的1是job号，3991是进程号。最开始的job状态是Running，后来执行结束后就自动变成了Done。\n```\n[root@aliyun-hk1 ~]# jobs\n[root@aliyun-hk1 ~]# sleep 20 &\n[1] 3991\n[root@aliyun-hk1 ~]# jobs\n[1]+  Running                 sleep 20 &\n[root@aliyun-hk1 ~]# jobs\n[1]+  Done                    sleep 20\n[root@aliyun-hk1 ~]#\n```\n\n使用CTRL+Z，将目前的工作丢到后台去，所以就会产生一个job number。\n```\n[root@aliyun-hk1 ~]# vim hello.js\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n```\n\n使用jobs查看后前的后台工作状态\n```\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n```\n\n使用fg将后台作业恢复到前台执行,继续执行刚才的文件编辑。\n```\n[root@aliyun-hk1 ~]#fg\n```\n\n使用bg将在后台而且已暂停执行的job成为运行状态。\n```\n[root@aliyun-hk1 ~]# jobs\n[1]-  Stopped                 vim hello.js\n[2]   Running                 nohup sleep 20000 &\n[3]+  Stopped                 sleep 100000\n[root@aliyun-hk1 ~]# bg 3\n[3]+ sleep 100000 &\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[2]   Running                 nohup sleep 20000 &\n[3]-  Running                 sleep 100000 &\n[root@aliyun-hk1 ~]#\n```\n\n管理后台运行中的job：kill\n```\nkill -signal job-number\nkill -9 job-number 强制删除一个job\nkill -15 以正常的程序方式终止一项工作\nkill -2 代表由键盘执行CTRL+C一样的操作\n```\n\n##### 1.1.3 进程管理\n学习和研究进程管理的意义其实很重大。在linux每个运行的程序，都会运行一个进程，这个程序是否还在运行需要看进程是否存在；如果linux系统的资源使用情况突然异常，需要快速找出这个可疑的进程；如果某个程序写得不好，导致有问题的进程存在，也需要找出他；如果有多个重要的用户级进程在系统运行，如果调整他们的优先级，也很重要。\n\n**进程基本信息查看，可以使用ps命令**\n```\n[root@aliyun-hk1 ~]# ps -l  仅查看自己的bash相关进程\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  6931  6929  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n0 R     0  7000  6931  0  80   0 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]#\n```\n\n```\n[root@aliyun-hk1 ~]# ps aux 列出目前所有在内存中的进程\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.6  43532  3420 ?        Ss   Mar15   0:07 /usr/lib/systemd/systemd\nroot         4  0.0  0.0      0     0 ?        S<   Mar15   0:00 [kworker/0:0H]\nroot         5  0.0  0.0      0     0 ?        S    Mar15   0:01 [kworker/u2:0]\nroot         6  0.0  0.0      0     0 ?        S    Mar15   0:01 [ksoftirqd/0]\nroot         7  0.0  0.0      0     0 ?        S    Mar15   0:00 [migration/0]\n```\n\n```\n[root@aliyun-hk1 ~]# ps axjf 查看进程并且包含进程树\n    1   838   838   838 ?           -1 Ssl      0   1:39 /usr/bin/python2 -Es /usr/sbin/tuned -l -P\n 6931  7004  7003  6931 pts/0     7003 S+       0   0:00          \\_ grep --color=auto python\n    1  1297  1296  1266 ?           -1 Sl       0   2:53 python proxyserver.py 11081\n[root@aliyun-hk1 ~]#\n```\n\n**进程动态信息查看，可以使用top命令**\n```\n输入top后，默认系统就会列出所有进程的信息和整体资源的占用情况。\ntop - 23:14:35 up 11 days, 12:39,  1 user,  load average: 0.00, 0.01, 0.05\nTasks:  71 total,   1 running,  70 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   498664 total,    36480 free,    95232 used,   366952 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   389812 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n  975 root      10 -10  127960  10768   6216 S  1.3  2.2 146:08.95 AliYunDun\n    1 root      20   0   43532   3420   2104 S  0.0  0.7   0:07.60 systemd\n    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd\n```\n\n```\n查看某个进程的负载，可以这样玩\n[root@aliyun-hk1 linux-shell-test]# top -d 2 -p 975 \nTasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   498664 total,    36232 free,    95160 used,   367272 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   389892 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n  975 root      10 -10  127960  10768   6216 S  1.0  2.2 146:13.63 AliYunDun\n```\n*top命令很强大，可以持续监测整个系统的工作状态，默认情况下5秒更新一次。这个命令今天暂时不展开讲了。*\n\n**进程之间关系的查看**\n```\n[root@aliyun-hk1 ~]# pstree\nsystemd─┬─AliYunDun───23*[{AliYunDun}]\n        ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]\n        ├─2*[agetty]\n        ├─aliyun-service───2*[{aliyun-service}]\n        ├─atd\n        ├─auditd───{auditd}\n        ├─chronyd\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─lvmetad\n        ├─nginx───nginx\n        ├─polkitd───6*[{polkitd}]\n        ├─python───13*[{python}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd───sshd───bash───pstree\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        └─tuned───4*[{tuned}]\n[root@aliyun-hk1 ~]#\n\n```\n\n**进程的管理和控制**\n我们要控制某个进程，只要给他发信号就可以了，进程的唯一标识符就是进程ID。\n通过进程PID来终止进程，语法为：kill -signal PID，例如: kill -9 12306\n代号     | 含义\n-------- | -----\n1  | 启动被终止的进程\n2 | 相当于键盘输入CTRL+C来中断一个进程\n9  |强制中断某一个进程\n15|等待进程完成后续操作后，结束该进程\n17|相当于用户键入CTRL+Z暂停一个进程的执行\n\n通过进程PID来终止进程，语法为：killall [command name]，例如：killall -9 httpd\n\n\n**进程的执行顺序**\nLinux是多用户、多任务的环境，由top输出的结果我们也可以发现，系统同时间有非常多的进程运行中，只是绝大部分的进程都在休眠（sleep)状态而已。操作系统内核，有默认的调度规则，会自动计算出一个“优先执行序”（priority,PRI)，这个PRI值越低代表越优先，用户无法干预这个PRI。\n```\n[robin@aliyun-hk1 linux-shell-test]$ ps -alt\nF   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND\n4     0   560     1  20   0 110108   824 n_tty_ Ss+  ttyS0      0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220\n4     0   561     1  20   0 110108   820 n_tty_ Ss+  tty1       0:00 /sbin/agetty --noclear tty1 linux\n4     0  8614  8612  20   0 115580  2084 do_wai Ss   pts/0      0:00 -bash\n4     0  8631  8614  20   0 191784  2340 do_wai S    pts/0      0:00 su - robin\n4  1000  8632  8631  20   0 115448  2096 do_wai S    pts/0      0:00 -bash\n0  1000  8675  8632  20   0 153248  1500 -      R+   pts/0      0:00 ps -alt\n[robin@aliyun-hk1 linux-shell-test]$\n```\n\n可以通过Nice来调整，也就是上面的NI，一般他们的关系如下：\n```\nPRI(new) = PRI(old) + nice\n```\n\nroot可以随意调整自己或他人进程的nice值，调整的范围是-20~19；\n一般用户可以调整的范围仅为0-19（为了避免抢占系统资源），而且只能调大，或者初次使用时设置。\n```\n新启动一个程序，并设置nice为-5\n[root@aliyun-hk1 ~]# nice -n -5 vi &\n[1] 8699\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  75  -5 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8700  8614  0  80   0 - 38312 -      pts/0    00:00:00 ps\n\n[1]+  Stopped                 nice -n -5 vi\n[root@aliyun-hk1 ~]#\n```\n\n调整现有进程的优先级，nice值重新调整\n```\n[root@aliyun-hk1 ~]# renice 10 8699\n8699 (process ID) old priority -5, new priority 10\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  90  10 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8718  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]# renice 9 8699\n8699 (process ID) old priority 10, new priority 9\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  89   9 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8720  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]#\n```\n*因为一般用户只能调高nice，即降低优先级，所以我们一般通过调大nice降低非核心任务的优先级，保证核心业务运行的优先级。*\n\n**系统资源查看**\n除了系统进程管理外，我们还需要了解如何查询其他系统资源，例如：\n```\n[root@aliyun-hk1 ~]# free -m free 查看内存使用情况\n              total        used        free      shared  buff/cache   available\nMem:            486          93          34           0         359         380\nSwap:             0           0           0\n```\n*Linux系统管理内存的方式跟windows有很大差异，为了让用户的体验更好，系统性能更好，内核会尽可能使用现有的内存，所以如果内存几乎被用光，不要心慌。除非swap开始被大量使用， 才要开始警惕。*\n\n```\n[root@aliyun-hk1 ~]# uname -a 内核基本信息查看\nLinux aliyun-hk1 3.10.0-1062.12.1.el7.x86_64 #1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 ~]#\n```\n*内核基本信息主要包括，主机名、内核版本、创建日期、试用的硬件平台等。*\n\n```\n[root@aliyun-hk1 ~]# uptime 查看系统启动时间及负载\n 00:03:22 up 12 days, 13:28,  1 user,  load average: 0.00, 0.01, 0.05\n[root@aliyun-hk1 ~]#\n```\n*启动时间就是系统已经开启或重启多久了，负载就是只1，5，15分钟的平均负载。*\n\n```\n[root@aliyun-hk1 ~]# netstat -an 查看网络信息\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State\ntcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:11081           0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\ntcp        0      0 172.31.200.164:11081    47.103.99.182:53826     ESTABLISHED\n\n```\n*一般我们最长去使用netstat去判断某个进程是否开启了xx监听端口。*\n\n\n```\n[root@aliyun-hk1 ~]# dmesg |more 分析内核产生的信息\n[    0.000000]   0 base 000080000000 mask 3FFF80000000 uncachable\n[    0.000000]   1 disabled\n[    0.000000]   2 disabled\n[    0.000000]   3 disabled\n[    0.000000]   4 disabled\n[    0.000000]   5 disabled\n[    0.000000]   6 disabled\n[    0.000000]   7 disabled\n[    0.000000] PAT configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- UC\n[    0.000000] found SMP MP-table at [mem 0x000f59f0-0x000f59ff] mapped at [ffffffffff2009f0]\n[    0.000000] Base memory trampoline at [ffff9bf500099000] 99000 size 24576\n[    0.000000] Using GB pages for direct mapping\n[    0.000000] BRK [0x0b270000, 0x0b270fff] PGTABLE\n[    0.000000] BRK [0x0b271000, 0x0b271fff] PGTABLE\n```\n\n**vmstat 检测系统资源变化，结合top分析系统瓶颈。**\n他可以动态查看CPU/内存/磁盘/IO等数据。\n```\n[root@aliyun-hk1 ~]# vmstat 查看一次数据\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 2  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0\n[root@aliyun-hk1 ~]# vmstat 3 每3秒动态输出一次\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0\n 0  0      0  34064  67800 300812    0    0     0     5  267  875  0  0 99  0  0\n^C\n```\n\n##### 1.1.4 特殊文件与程序\n###### 1.1.4.1 具有SUID/SGID权限的命令执行状态\n普通用户用户都有权限通过passwd修改自己的密码，但是密码文件的权限是root，那为什么普通用户有权限读写呢？因为普通用户有passwd程序的特殊权限，他在运行passwd程序时，会自动取得一个新的进程与PID，且具有owner的权限，即具有读写权限。\n```\n密码文件的默认权限644，也就是普通用户只可以去读。\n[robin@aliyun-hk1 ~]$ ls -alt /etc/passwd\n-rw-r--r-- 1 root root 1175 Mar 11 00:07 /etc/passwd\n[robin@aliyun-hk1 ~]$\n\n找到passwd程序，并看他的权限，他有SUID权限\n[robin@aliyun-hk1 ~]$ whereis passwd\npasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz\n[robin@aliyun-hk1 ~]$ ls -alt /usr/bin/passwd\n-rwsr-xr-x 1 root root 27856 Aug  9  2019 /usr/bin/passwd\n[robin@aliyun-hk1 ~]$\n```\n\n###### 1.1.4.2 进程数据的查看\n其实进程都是加载到内存中运行的，而内存中的数据又都是写入到/proc/*这个目录的。我们当然可以查看/proc/下面的数据。我们发现目前主机上运行的进程，都是以PID编号命名，存到这里的。\n```\n[robin@aliyun-hk1 ~]$ ls -ltr /proc/\ntotal 0\nlrwxrwxrwx  1 root    root                  0 Mar 15 10:34 self -> 10312\n-r--r--r--  1 root    root                  0 Mar 15 10:34 swaps\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 342\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 362\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 363\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 468\ndr-xr-xr-x  9 polkitd polkitd               0 Mar 15 10:34 492\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 496\ndr-xr-xr-x  9 dbus    dbus                  0 Mar 15 10:34 503\ndr-xr-xr-x  9 chrony  chrony                0 Mar 15 10:34 510\n\n[robin@aliyun-hk1 ~]$ ps -ef|grep 342\nroot       342     1  0 Mar15 ?        00:00:03 /usr/lib/systemd/systemd-journald\nrobin    10314 10261  0 22:33 pts/1    00:00:00 grep --color=auto 342\n[robin@aliyun-hk1 ~]$\n```\n\n这个以PID编号命名的为文件夹里，有什么内容呢？这里面有好多内容，我们可以先了解下cmdline和environ，前者存储的是这个进程被启动的命令串，后者存储的是进程的环境变量。\n```\n[robin@aliyun-hk1 10319]$ ps -ef|grep sleep\nrobin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000\nrobin    10346 10261  0 22:39 pts/1    00:00:00 grep --color=auto sleep\n[robin@aliyun-hk1 10319]$ cd /proc/10319/\n[robin@aliyun-hk1 10319]$ ll\ntotal 0\ndr-xr-xr-x 2 robin robin 0 Mar 28 22:35 attr\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 autogroup\n-r-------- 1 robin robin 0 Mar 28 22:35 auxv\n-r--r--r-- 1 robin robin 0 Mar 28 22:34 cgroup\n--w------- 1 robin robin 0 Mar 28 22:35 clear_refs\n-r--r--r-- 1 robin robin 0 Mar 28 22:34 cmdline\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 comm\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 coredump_filter\n-r--r--r-- 1 robin robin 0 Mar 28 22:35 cpuset\nlrwxrwxrwx 1 robin robin 0 Mar 28 22:34 cwd -> /proc/342\n-r-------- 1 robin robin 0 Mar 28 22:35 environ\n.....\n\n[robin@aliyun-hk1 10319]$ cat cmdline\nsleep100000[robin@aliyun-hk1 10319]$ cat environ\nXDG_SESSION_ID=2314HOSTNAME=aliyun-hk1TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=\n......\n```\n\nLinux系统，常见/prod/下文件与对应的内容。\n文件名     | 文件内容\n-------- | -----\n/proc/cmdline | 加载kernel时所执行的相关参数\n/proc/cpuinfo | 本机CPU相关的信息，例如频率、类型、数量\n/proc/devices | 记录了系统各个主要设备的代号\n/proc/filesystems| 目前系统上已加载的文件系统\n/proc/loadavg|top uptime命令中负载的三个平均值就记录在这里\n/proc/meminfo|查阅内存信息，相当于free的作用\n/proc/mounts|\t查阅系统已经挂载的数据，相当于mount\n/proc/swaps|记录swap内容使用的文件系统\n/proc/version|记录内核的版本\n\n###### 1.1.4.3 查询程序已打开的文件\n大家都应该遇到过，\"too many open files...\" 之类的错误吧? 这个其实跟打开文件数量超过系统限制有关系。\n**使用fuser找出正在使用该文件的程序**\n```\n不加参数，默认打印PID号\n[robin@aliyun-hk1 ~]$ fuser nohup.out\n/home/robin/nohup.out: 10319\n[robin@aliyun-hk1 ~]$ ps -ef|grep 10319\nrobin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000\nrobin    10380 10261  0 22:58 pts/1    00:00:00 grep --color=auto 10319\n[robin@aliyun-hk1 ~]$\n\n加参数可以获取更多的进程信息\n[robin@aliyun-hk1 ~]$ fuser -uv nohup.out\n                     USER        PID ACCESS COMMAND\n/home/robin/nohup.out:\n                     robin     10319 F.... (robin)sleep\n[robin@aliyun-hk1 ~]$\n```\n\n**使用lsof找出被进程打开的文件**\n```\n找出robin用户下，被程序打开的所有文件\n[root@aliyun-hk1 ~]# lsof -u robin|wc -l\n108\n[root@aliyun-hk1 ~]#\n```","source":"_posts/linux/linux_program.md","raw":"---\ntitle: Linux之程序管理\ndate: 2020-03-24 23:00:00\ntags: progress\ncategories: linux\n---\n\nLinux系统是一个多任务的开源操作系统，后台运行着很多的进程。今天我们来学习下进程相关的内容。\n<!--more-->\n\n#### 1.1 什么是进程\n在linux系统中，触发任何一个事件时，系统都会将它定义为一个进程，并且给这个进程分配一个PID。\n\n##### 1.1.1 进程与程序\n简单地说，执行一个程序、脚本或命令，就可以触发一个事件并且取得一个PID。在我看来就是内核读取磁盘中的一个程序，并且加载到内存中，给他分配一个进程号PID。总结下来，进程就是一个运行中的程序。\n```\n运行bash后会生成一个子shell，查看其产生的进程\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  3819  3817  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n4 S     0  3875  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep\n0 S     0  3881  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep\n4 S     0  3949  3819  0  80   0 - 28894 do_wai pts/0    00:00:00 bash\n0 R     0  3960  3949  0  80   0 - 38312 -      pts/0    00:00:00 ps\n```\n##### 1.1.2 工作管理（job control )\n将一个命令丢到后台去执行，即在命令末尾增加&，就会产生一个job，包括job number，进程id等，这里的1是job号，3991是进程号。最开始的job状态是Running，后来执行结束后就自动变成了Done。\n```\n[root@aliyun-hk1 ~]# jobs\n[root@aliyun-hk1 ~]# sleep 20 &\n[1] 3991\n[root@aliyun-hk1 ~]# jobs\n[1]+  Running                 sleep 20 &\n[root@aliyun-hk1 ~]# jobs\n[1]+  Done                    sleep 20\n[root@aliyun-hk1 ~]#\n```\n\n使用CTRL+Z，将目前的工作丢到后台去，所以就会产生一个job number。\n```\n[root@aliyun-hk1 ~]# vim hello.js\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n```\n\n使用jobs查看后前的后台工作状态\n```\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[root@aliyun-hk1 ~]#\n```\n\n使用fg将后台作业恢复到前台执行,继续执行刚才的文件编辑。\n```\n[root@aliyun-hk1 ~]#fg\n```\n\n使用bg将在后台而且已暂停执行的job成为运行状态。\n```\n[root@aliyun-hk1 ~]# jobs\n[1]-  Stopped                 vim hello.js\n[2]   Running                 nohup sleep 20000 &\n[3]+  Stopped                 sleep 100000\n[root@aliyun-hk1 ~]# bg 3\n[3]+ sleep 100000 &\n[root@aliyun-hk1 ~]# jobs\n[1]+  Stopped                 vim hello.js\n[2]   Running                 nohup sleep 20000 &\n[3]-  Running                 sleep 100000 &\n[root@aliyun-hk1 ~]#\n```\n\n管理后台运行中的job：kill\n```\nkill -signal job-number\nkill -9 job-number 强制删除一个job\nkill -15 以正常的程序方式终止一项工作\nkill -2 代表由键盘执行CTRL+C一样的操作\n```\n\n##### 1.1.3 进程管理\n学习和研究进程管理的意义其实很重大。在linux每个运行的程序，都会运行一个进程，这个程序是否还在运行需要看进程是否存在；如果linux系统的资源使用情况突然异常，需要快速找出这个可疑的进程；如果某个程序写得不好，导致有问题的进程存在，也需要找出他；如果有多个重要的用户级进程在系统运行，如果调整他们的优先级，也很重要。\n\n**进程基本信息查看，可以使用ps命令**\n```\n[root@aliyun-hk1 ~]# ps -l  仅查看自己的bash相关进程\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  6931  6929  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n0 R     0  7000  6931  0  80   0 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]#\n```\n\n```\n[root@aliyun-hk1 ~]# ps aux 列出目前所有在内存中的进程\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.6  43532  3420 ?        Ss   Mar15   0:07 /usr/lib/systemd/systemd\nroot         4  0.0  0.0      0     0 ?        S<   Mar15   0:00 [kworker/0:0H]\nroot         5  0.0  0.0      0     0 ?        S    Mar15   0:01 [kworker/u2:0]\nroot         6  0.0  0.0      0     0 ?        S    Mar15   0:01 [ksoftirqd/0]\nroot         7  0.0  0.0      0     0 ?        S    Mar15   0:00 [migration/0]\n```\n\n```\n[root@aliyun-hk1 ~]# ps axjf 查看进程并且包含进程树\n    1   838   838   838 ?           -1 Ssl      0   1:39 /usr/bin/python2 -Es /usr/sbin/tuned -l -P\n 6931  7004  7003  6931 pts/0     7003 S+       0   0:00          \\_ grep --color=auto python\n    1  1297  1296  1266 ?           -1 Sl       0   2:53 python proxyserver.py 11081\n[root@aliyun-hk1 ~]#\n```\n\n**进程动态信息查看，可以使用top命令**\n```\n输入top后，默认系统就会列出所有进程的信息和整体资源的占用情况。\ntop - 23:14:35 up 11 days, 12:39,  1 user,  load average: 0.00, 0.01, 0.05\nTasks:  71 total,   1 running,  70 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   498664 total,    36480 free,    95232 used,   366952 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   389812 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n  975 root      10 -10  127960  10768   6216 S  1.3  2.2 146:08.95 AliYunDun\n    1 root      20   0   43532   3420   2104 S  0.0  0.7   0:07.60 systemd\n    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd\n```\n\n```\n查看某个进程的负载，可以这样玩\n[root@aliyun-hk1 linux-shell-test]# top -d 2 -p 975 \nTasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :   498664 total,    36232 free,    95160 used,   367272 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.   389892 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n  975 root      10 -10  127960  10768   6216 S  1.0  2.2 146:13.63 AliYunDun\n```\n*top命令很强大，可以持续监测整个系统的工作状态，默认情况下5秒更新一次。这个命令今天暂时不展开讲了。*\n\n**进程之间关系的查看**\n```\n[root@aliyun-hk1 ~]# pstree\nsystemd─┬─AliYunDun───23*[{AliYunDun}]\n        ├─AliYunDunUpdate───3*[{AliYunDunUpdate}]\n        ├─2*[agetty]\n        ├─aliyun-service───2*[{aliyun-service}]\n        ├─atd\n        ├─auditd───{auditd}\n        ├─chronyd\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─lvmetad\n        ├─nginx───nginx\n        ├─polkitd───6*[{polkitd}]\n        ├─python───13*[{python}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd───sshd───bash───pstree\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        └─tuned───4*[{tuned}]\n[root@aliyun-hk1 ~]#\n\n```\n\n**进程的管理和控制**\n我们要控制某个进程，只要给他发信号就可以了，进程的唯一标识符就是进程ID。\n通过进程PID来终止进程，语法为：kill -signal PID，例如: kill -9 12306\n代号     | 含义\n-------- | -----\n1  | 启动被终止的进程\n2 | 相当于键盘输入CTRL+C来中断一个进程\n9  |强制中断某一个进程\n15|等待进程完成后续操作后，结束该进程\n17|相当于用户键入CTRL+Z暂停一个进程的执行\n\n通过进程PID来终止进程，语法为：killall [command name]，例如：killall -9 httpd\n\n\n**进程的执行顺序**\nLinux是多用户、多任务的环境，由top输出的结果我们也可以发现，系统同时间有非常多的进程运行中，只是绝大部分的进程都在休眠（sleep)状态而已。操作系统内核，有默认的调度规则，会自动计算出一个“优先执行序”（priority,PRI)，这个PRI值越低代表越优先，用户无法干预这个PRI。\n```\n[robin@aliyun-hk1 linux-shell-test]$ ps -alt\nF   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND\n4     0   560     1  20   0 110108   824 n_tty_ Ss+  ttyS0      0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220\n4     0   561     1  20   0 110108   820 n_tty_ Ss+  tty1       0:00 /sbin/agetty --noclear tty1 linux\n4     0  8614  8612  20   0 115580  2084 do_wai Ss   pts/0      0:00 -bash\n4     0  8631  8614  20   0 191784  2340 do_wai S    pts/0      0:00 su - robin\n4  1000  8632  8631  20   0 115448  2096 do_wai S    pts/0      0:00 -bash\n0  1000  8675  8632  20   0 153248  1500 -      R+   pts/0      0:00 ps -alt\n[robin@aliyun-hk1 linux-shell-test]$\n```\n\n可以通过Nice来调整，也就是上面的NI，一般他们的关系如下：\n```\nPRI(new) = PRI(old) + nice\n```\n\nroot可以随意调整自己或他人进程的nice值，调整的范围是-20~19；\n一般用户可以调整的范围仅为0-19（为了避免抢占系统资源），而且只能调大，或者初次使用时设置。\n```\n新启动一个程序，并设置nice为-5\n[root@aliyun-hk1 ~]# nice -n -5 vi &\n[1] 8699\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  80   0 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  75  -5 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8700  8614  0  80   0 - 38312 -      pts/0    00:00:00 ps\n\n[1]+  Stopped                 nice -n -5 vi\n[root@aliyun-hk1 ~]#\n```\n\n调整现有进程的优先级，nice值重新调整\n```\n[root@aliyun-hk1 ~]# renice 10 8699\n8699 (process ID) old priority -5, new priority 10\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  90  10 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8718  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]# renice 9 8699\n8699 (process ID) old priority 10, new priority 9\n[root@aliyun-hk1 ~]# ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash\n4 T     0  8699  8614  0  89   9 - 31055 do_sig pts/0    00:00:00 vi\n0 R     0  8720  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps\n[root@aliyun-hk1 ~]#\n```\n*因为一般用户只能调高nice，即降低优先级，所以我们一般通过调大nice降低非核心任务的优先级，保证核心业务运行的优先级。*\n\n**系统资源查看**\n除了系统进程管理外，我们还需要了解如何查询其他系统资源，例如：\n```\n[root@aliyun-hk1 ~]# free -m free 查看内存使用情况\n              total        used        free      shared  buff/cache   available\nMem:            486          93          34           0         359         380\nSwap:             0           0           0\n```\n*Linux系统管理内存的方式跟windows有很大差异，为了让用户的体验更好，系统性能更好，内核会尽可能使用现有的内存，所以如果内存几乎被用光，不要心慌。除非swap开始被大量使用， 才要开始警惕。*\n\n```\n[root@aliyun-hk1 ~]# uname -a 内核基本信息查看\nLinux aliyun-hk1 3.10.0-1062.12.1.el7.x86_64 #1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 ~]#\n```\n*内核基本信息主要包括，主机名、内核版本、创建日期、试用的硬件平台等。*\n\n```\n[root@aliyun-hk1 ~]# uptime 查看系统启动时间及负载\n 00:03:22 up 12 days, 13:28,  1 user,  load average: 0.00, 0.01, 0.05\n[root@aliyun-hk1 ~]#\n```\n*启动时间就是系统已经开启或重启多久了，负载就是只1，5，15分钟的平均负载。*\n\n```\n[root@aliyun-hk1 ~]# netstat -an 查看网络信息\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State\ntcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:11081           0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN\ntcp        0      0 172.31.200.164:11081    47.103.99.182:53826     ESTABLISHED\n\n```\n*一般我们最长去使用netstat去判断某个进程是否开启了xx监听端口。*\n\n\n```\n[root@aliyun-hk1 ~]# dmesg |more 分析内核产生的信息\n[    0.000000]   0 base 000080000000 mask 3FFF80000000 uncachable\n[    0.000000]   1 disabled\n[    0.000000]   2 disabled\n[    0.000000]   3 disabled\n[    0.000000]   4 disabled\n[    0.000000]   5 disabled\n[    0.000000]   6 disabled\n[    0.000000]   7 disabled\n[    0.000000] PAT configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- UC\n[    0.000000] found SMP MP-table at [mem 0x000f59f0-0x000f59ff] mapped at [ffffffffff2009f0]\n[    0.000000] Base memory trampoline at [ffff9bf500099000] 99000 size 24576\n[    0.000000] Using GB pages for direct mapping\n[    0.000000] BRK [0x0b270000, 0x0b270fff] PGTABLE\n[    0.000000] BRK [0x0b271000, 0x0b271fff] PGTABLE\n```\n\n**vmstat 检测系统资源变化，结合top分析系统瓶颈。**\n他可以动态查看CPU/内存/磁盘/IO等数据。\n```\n[root@aliyun-hk1 ~]# vmstat 查看一次数据\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 2  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0\n[root@aliyun-hk1 ~]# vmstat 3 每3秒动态输出一次\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0\n 0  0      0  34064  67800 300812    0    0     0     5  267  875  0  0 99  0  0\n^C\n```\n\n##### 1.1.4 特殊文件与程序\n###### 1.1.4.1 具有SUID/SGID权限的命令执行状态\n普通用户用户都有权限通过passwd修改自己的密码，但是密码文件的权限是root，那为什么普通用户有权限读写呢？因为普通用户有passwd程序的特殊权限，他在运行passwd程序时，会自动取得一个新的进程与PID，且具有owner的权限，即具有读写权限。\n```\n密码文件的默认权限644，也就是普通用户只可以去读。\n[robin@aliyun-hk1 ~]$ ls -alt /etc/passwd\n-rw-r--r-- 1 root root 1175 Mar 11 00:07 /etc/passwd\n[robin@aliyun-hk1 ~]$\n\n找到passwd程序，并看他的权限，他有SUID权限\n[robin@aliyun-hk1 ~]$ whereis passwd\npasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz\n[robin@aliyun-hk1 ~]$ ls -alt /usr/bin/passwd\n-rwsr-xr-x 1 root root 27856 Aug  9  2019 /usr/bin/passwd\n[robin@aliyun-hk1 ~]$\n```\n\n###### 1.1.4.2 进程数据的查看\n其实进程都是加载到内存中运行的，而内存中的数据又都是写入到/proc/*这个目录的。我们当然可以查看/proc/下面的数据。我们发现目前主机上运行的进程，都是以PID编号命名，存到这里的。\n```\n[robin@aliyun-hk1 ~]$ ls -ltr /proc/\ntotal 0\nlrwxrwxrwx  1 root    root                  0 Mar 15 10:34 self -> 10312\n-r--r--r--  1 root    root                  0 Mar 15 10:34 swaps\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 342\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 362\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 363\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 468\ndr-xr-xr-x  9 polkitd polkitd               0 Mar 15 10:34 492\ndr-xr-xr-x  9 root    root                  0 Mar 15 10:34 496\ndr-xr-xr-x  9 dbus    dbus                  0 Mar 15 10:34 503\ndr-xr-xr-x  9 chrony  chrony                0 Mar 15 10:34 510\n\n[robin@aliyun-hk1 ~]$ ps -ef|grep 342\nroot       342     1  0 Mar15 ?        00:00:03 /usr/lib/systemd/systemd-journald\nrobin    10314 10261  0 22:33 pts/1    00:00:00 grep --color=auto 342\n[robin@aliyun-hk1 ~]$\n```\n\n这个以PID编号命名的为文件夹里，有什么内容呢？这里面有好多内容，我们可以先了解下cmdline和environ，前者存储的是这个进程被启动的命令串，后者存储的是进程的环境变量。\n```\n[robin@aliyun-hk1 10319]$ ps -ef|grep sleep\nrobin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000\nrobin    10346 10261  0 22:39 pts/1    00:00:00 grep --color=auto sleep\n[robin@aliyun-hk1 10319]$ cd /proc/10319/\n[robin@aliyun-hk1 10319]$ ll\ntotal 0\ndr-xr-xr-x 2 robin robin 0 Mar 28 22:35 attr\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 autogroup\n-r-------- 1 robin robin 0 Mar 28 22:35 auxv\n-r--r--r-- 1 robin robin 0 Mar 28 22:34 cgroup\n--w------- 1 robin robin 0 Mar 28 22:35 clear_refs\n-r--r--r-- 1 robin robin 0 Mar 28 22:34 cmdline\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 comm\n-rw-r--r-- 1 robin robin 0 Mar 28 22:35 coredump_filter\n-r--r--r-- 1 robin robin 0 Mar 28 22:35 cpuset\nlrwxrwxrwx 1 robin robin 0 Mar 28 22:34 cwd -> /proc/342\n-r-------- 1 robin robin 0 Mar 28 22:35 environ\n.....\n\n[robin@aliyun-hk1 10319]$ cat cmdline\nsleep100000[robin@aliyun-hk1 10319]$ cat environ\nXDG_SESSION_ID=2314HOSTNAME=aliyun-hk1TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=\n......\n```\n\nLinux系统，常见/prod/下文件与对应的内容。\n文件名     | 文件内容\n-------- | -----\n/proc/cmdline | 加载kernel时所执行的相关参数\n/proc/cpuinfo | 本机CPU相关的信息，例如频率、类型、数量\n/proc/devices | 记录了系统各个主要设备的代号\n/proc/filesystems| 目前系统上已加载的文件系统\n/proc/loadavg|top uptime命令中负载的三个平均值就记录在这里\n/proc/meminfo|查阅内存信息，相当于free的作用\n/proc/mounts|\t查阅系统已经挂载的数据，相当于mount\n/proc/swaps|记录swap内容使用的文件系统\n/proc/version|记录内核的版本\n\n###### 1.1.4.3 查询程序已打开的文件\n大家都应该遇到过，\"too many open files...\" 之类的错误吧? 这个其实跟打开文件数量超过系统限制有关系。\n**使用fuser找出正在使用该文件的程序**\n```\n不加参数，默认打印PID号\n[robin@aliyun-hk1 ~]$ fuser nohup.out\n/home/robin/nohup.out: 10319\n[robin@aliyun-hk1 ~]$ ps -ef|grep 10319\nrobin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000\nrobin    10380 10261  0 22:58 pts/1    00:00:00 grep --color=auto 10319\n[robin@aliyun-hk1 ~]$\n\n加参数可以获取更多的进程信息\n[robin@aliyun-hk1 ~]$ fuser -uv nohup.out\n                     USER        PID ACCESS COMMAND\n/home/robin/nohup.out:\n                     robin     10319 F.... (robin)sleep\n[robin@aliyun-hk1 ~]$\n```\n\n**使用lsof找出被进程打开的文件**\n```\n找出robin用户下，被程序打开的所有文件\n[root@aliyun-hk1 ~]# lsof -u robin|wc -l\n108\n[root@aliyun-hk1 ~]#\n```","slug":"linux/linux_program","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdet3003s0en7arrxk445","content":"<p>Linux系统是一个多任务的开源操作系统，后台运行着很多的进程。今天我们来学习下进程相关的内容。<br><a id=\"more\"></a></p>\n<h4 id=\"1-1-什么是进程\"><a href=\"#1-1-什么是进程\" class=\"headerlink\" title=\"1.1 什么是进程\"></a>1.1 什么是进程</h4><p>在linux系统中，触发任何一个事件时，系统都会将它定义为一个进程，并且给这个进程分配一个PID。</p>\n<h5 id=\"1-1-1-进程与程序\"><a href=\"#1-1-1-进程与程序\" class=\"headerlink\" title=\"1.1.1 进程与程序\"></a>1.1.1 进程与程序</h5><p>简单地说，执行一个程序、脚本或命令，就可以触发一个事件并且取得一个PID。在我看来就是内核读取磁盘中的一个程序，并且加载到内存中，给他分配一个进程号PID。总结下来，进程就是一个运行中的程序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行bash后会生成一个子shell，查看其产生的进程</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  3819  3817  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 S     0  3875  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep</span><br><span class=\"line\">0 S     0  3881  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep</span><br><span class=\"line\">4 S     0  3949  3819  0  80   0 - 28894 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">0 R     0  3960  3949  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-2-工作管理（job-control\"><a href=\"#1-1-2-工作管理（job-control\" class=\"headerlink\" title=\"1.1.2 工作管理（job control )\"></a>1.1.2 工作管理（job control )</h5><p>将一个命令丢到后台去执行，即在命令末尾增加&amp;，就会产生一个job，包括job number，进程id等，这里的1是job号，3991是进程号。最开始的job状态是Running，后来执行结束后就自动变成了Done。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[root@aliyun-hk1 ~]# sleep 20 &amp;</span><br><span class=\"line\">[1] 3991</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Running                 sleep 20 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Done                    sleep 20</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用CTRL+Z，将目前的工作丢到后台去，所以就会产生一个job number。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# vim hello.js</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用jobs查看后前的后台工作状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用fg将后台作业恢复到前台执行,继续执行刚才的文件编辑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]#fg</span><br></pre></td></tr></table></figure></p>\n<p>使用bg将在后台而且已暂停执行的job成为运行状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]-  Stopped                 vim hello.js</span><br><span class=\"line\">[2]   Running                 nohup sleep 20000 &amp;</span><br><span class=\"line\">[3]+  Stopped                 sleep 100000</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bg 3</span><br><span class=\"line\">[3]+ sleep 100000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[2]   Running                 nohup sleep 20000 &amp;</span><br><span class=\"line\">[3]-  Running                 sleep 100000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>管理后台运行中的job：kill<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -signal job-number</span><br><span class=\"line\">kill -9 job-number 强制删除一个job</span><br><span class=\"line\">kill -15 以正常的程序方式终止一项工作</span><br><span class=\"line\">kill -2 代表由键盘执行CTRL+C一样的操作</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-3-进程管理\"><a href=\"#1-1-3-进程管理\" class=\"headerlink\" title=\"1.1.3 进程管理\"></a>1.1.3 进程管理</h5><p>学习和研究进程管理的意义其实很重大。在linux每个运行的程序，都会运行一个进程，这个程序是否还在运行需要看进程是否存在；如果linux系统的资源使用情况突然异常，需要快速找出这个可疑的进程；如果某个程序写得不好，导致有问题的进程存在，也需要找出他；如果有多个重要的用户级进程在系统运行，如果调整他们的优先级，也很重要。</p>\n<p><strong>进程基本信息查看，可以使用ps命令</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -l  仅查看自己的bash相关进程</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  6931  6929  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">0 R     0  7000  6931  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps aux 列出目前所有在内存中的进程</span><br><span class=\"line\">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\">root         1  0.0  0.6  43532  3420 ?        Ss   Mar15   0:07 /usr/lib/systemd/systemd</span><br><span class=\"line\">root         4  0.0  0.0      0     0 ?        S&lt;   Mar15   0:00 [kworker/0:0H]</span><br><span class=\"line\">root         5  0.0  0.0      0     0 ?        S    Mar15   0:01 [kworker/u2:0]</span><br><span class=\"line\">root         6  0.0  0.0      0     0 ?        S    Mar15   0:01 [ksoftirqd/0]</span><br><span class=\"line\">root         7  0.0  0.0      0     0 ?        S    Mar15   0:00 [migration/0]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps axjf 查看进程并且包含进程树</span><br><span class=\"line\">    1   838   838   838 ?           -1 Ssl      0   1:39 /usr/bin/python2 -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\"> 6931  7004  7003  6931 pts/0     7003 S+       0   0:00          \\_ grep --color=auto python</span><br><span class=\"line\">    1  1297  1296  1266 ?           -1 Sl       0   2:53 python proxyserver.py 11081</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><strong>进程动态信息查看，可以使用top命令</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入top后，默认系统就会列出所有进程的信息和整体资源的占用情况。</span><br><span class=\"line\">top - 23:14:35 up 11 days, 12:39,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks:  71 total,   1 running,  70 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :   498664 total,    36480 free,    95232 used,   366952 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.   389812 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  975 root      10 -10  127960  10768   6216 S  1.3  2.2 146:08.95 AliYunDun</span><br><span class=\"line\">    1 root      20   0   43532   3420   2104 S  0.0  0.7   0:07.60 systemd</span><br><span class=\"line\">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看某个进程的负载，可以这样玩</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# top -d 2 -p 975 </span><br><span class=\"line\">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :   498664 total,    36232 free,    95160 used,   367272 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.   389892 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  975 root      10 -10  127960  10768   6216 S  1.0  2.2 146:13.63 AliYunDun</span><br></pre></td></tr></table></figure>\n<p><em>top命令很强大，可以持续监测整个系统的工作状态，默认情况下5秒更新一次。这个命令今天暂时不展开讲了。</em></p>\n<p><strong>进程之间关系的查看</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# pstree</span><br><span class=\"line\">systemd─┬─AliYunDun───23*[&#123;AliYunDun&#125;]</span><br><span class=\"line\">        ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;]</span><br><span class=\"line\">        ├─2*[agetty]</span><br><span class=\"line\">        ├─aliyun-service───2*[&#123;aliyun-service&#125;]</span><br><span class=\"line\">        ├─atd</span><br><span class=\"line\">        ├─auditd───&#123;auditd&#125;</span><br><span class=\"line\">        ├─chronyd</span><br><span class=\"line\">        ├─crond</span><br><span class=\"line\">        ├─dbus-daemon</span><br><span class=\"line\">        ├─dhclient</span><br><span class=\"line\">        ├─lvmetad</span><br><span class=\"line\">        ├─nginx───nginx</span><br><span class=\"line\">        ├─polkitd───6*[&#123;polkitd&#125;]</span><br><span class=\"line\">        ├─python───13*[&#123;python&#125;]</span><br><span class=\"line\">        ├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class=\"line\">        ├─sshd───sshd───bash───pstree</span><br><span class=\"line\">        ├─systemd-journal</span><br><span class=\"line\">        ├─systemd-logind</span><br><span class=\"line\">        ├─systemd-udevd</span><br><span class=\"line\">        └─tuned───4*[&#123;tuned&#125;]</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>进程的管理和控制</strong><br>我们要控制某个进程，只要给他发信号就可以了，进程的唯一标识符就是进程ID。<br>通过进程PID来终止进程，语法为：kill -signal PID，例如: kill -9 12306<br>代号     | 含义<br>——– | —–<br>1  | 启动被终止的进程<br>2 | 相当于键盘输入CTRL+C来中断一个进程<br>9  |强制中断某一个进程<br>15|等待进程完成后续操作后，结束该进程<br>17|相当于用户键入CTRL+Z暂停一个进程的执行</p>\n<p>通过进程PID来终止进程，语法为：killall [command name]，例如：killall -9 httpd</p>\n<p><strong>进程的执行顺序</strong><br>Linux是多用户、多任务的环境，由top输出的结果我们也可以发现，系统同时间有非常多的进程运行中，只是绝大部分的进程都在休眠（sleep)状态而已。操作系统内核，有默认的调度规则，会自动计算出一个“优先执行序”（priority,PRI)，这个PRI值越低代表越优先，用户无法干预这个PRI。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 linux-shell-test]$ ps -alt</span><br><span class=\"line\">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class=\"line\">4     0   560     1  20   0 110108   824 n_tty_ Ss+  ttyS0      0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220</span><br><span class=\"line\">4     0   561     1  20   0 110108   820 n_tty_ Ss+  tty1       0:00 /sbin/agetty --noclear tty1 linux</span><br><span class=\"line\">4     0  8614  8612  20   0 115580  2084 do_wai Ss   pts/0      0:00 -bash</span><br><span class=\"line\">4     0  8631  8614  20   0 191784  2340 do_wai S    pts/0      0:00 su - robin</span><br><span class=\"line\">4  1000  8632  8631  20   0 115448  2096 do_wai S    pts/0      0:00 -bash</span><br><span class=\"line\">0  1000  8675  8632  20   0 153248  1500 -      R+   pts/0      0:00 ps -alt</span><br><span class=\"line\">[robin@aliyun-hk1 linux-shell-test]$</span><br></pre></td></tr></table></figure></p>\n<p>可以通过Nice来调整，也就是上面的NI，一般他们的关系如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRI(new) = PRI(old) + nice</span><br></pre></td></tr></table></figure></p>\n<p>root可以随意调整自己或他人进程的nice值，调整的范围是-20~19；<br>一般用户可以调整的范围仅为0-19（为了避免抢占系统资源），而且只能调大，或者初次使用时设置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新启动一个程序，并设置nice为-5</span><br><span class=\"line\">[root@aliyun-hk1 ~]# nice -n -5 vi &amp;</span><br><span class=\"line\">[1] 8699</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  75  -5 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8700  8614  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\"></span><br><span class=\"line\">[1]+  Stopped                 nice -n -5 vi</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>调整现有进程的优先级，nice值重新调整<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# renice 10 8699</span><br><span class=\"line\">8699 (process ID) old priority -5, new priority 10</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  90  10 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8718  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]# renice 9 8699</span><br><span class=\"line\">8699 (process ID) old priority 10, new priority 9</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  89   9 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8720  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p><em>因为一般用户只能调高nice，即降低优先级，所以我们一般通过调大nice降低非核心任务的优先级，保证核心业务运行的优先级。</em></p>\n<p><strong>系统资源查看</strong><br>除了系统进程管理外，我们还需要了解如何查询其他系统资源，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# free -m free 查看内存使用情况</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:            486          93          34           0         359         380</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<p><em>Linux系统管理内存的方式跟windows有很大差异，为了让用户的体验更好，系统性能更好，内核会尽可能使用现有的内存，所以如果内存几乎被用光，不要心慌。除非swap开始被大量使用， 才要开始警惕。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# uname -a 内核基本信息查看</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-1062.12.1.el7.x86_64 #1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><em>内核基本信息主要包括，主机名、内核版本、创建日期、试用的硬件平台等。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# uptime 查看系统启动时间及负载</span><br><span class=\"line\"> 00:03:22 up 12 days, 13:28,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><em>启动时间就是系统已经开启或重启多久了，负载就是只1，5，15分钟的平均负载。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# netstat -an 查看网络信息</span><br><span class=\"line\">Active Internet connections (servers and established)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class=\"line\">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:11081           0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 172.31.200.164:11081    47.103.99.182:53826     ESTABLISHED</span><br></pre></td></tr></table></figure>\n<p><em>一般我们最长去使用netstat去判断某个进程是否开启了xx监听端口。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# dmesg |more 分析内核产生的信息</span><br><span class=\"line\">[    0.000000]   0 base 000080000000 mask 3FFF80000000 uncachable</span><br><span class=\"line\">[    0.000000]   1 disabled</span><br><span class=\"line\">[    0.000000]   2 disabled</span><br><span class=\"line\">[    0.000000]   3 disabled</span><br><span class=\"line\">[    0.000000]   4 disabled</span><br><span class=\"line\">[    0.000000]   5 disabled</span><br><span class=\"line\">[    0.000000]   6 disabled</span><br><span class=\"line\">[    0.000000]   7 disabled</span><br><span class=\"line\">[    0.000000] PAT configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- UC</span><br><span class=\"line\">[    0.000000] found SMP MP-table at [mem 0x000f59f0-0x000f59ff] mapped at [ffffffffff2009f0]</span><br><span class=\"line\">[    0.000000] Base memory trampoline at [ffff9bf500099000] 99000 size 24576</span><br><span class=\"line\">[    0.000000] Using GB pages for direct mapping</span><br><span class=\"line\">[    0.000000] BRK [0x0b270000, 0x0b270fff] PGTABLE</span><br><span class=\"line\">[    0.000000] BRK [0x0b271000, 0x0b271fff] PGTABLE</span><br></pre></td></tr></table></figure>\n<p><strong>vmstat 检测系统资源变化，结合top分析系统瓶颈。</strong><br>他可以动态查看CPU/内存/磁盘/IO等数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# vmstat 查看一次数据</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 2  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0</span><br><span class=\"line\">[root@aliyun-hk1 ~]# vmstat 3 每3秒动态输出一次</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0</span><br><span class=\"line\"> 0  0      0  34064  67800 300812    0    0     0     5  267  875  0  0 99  0  0</span><br><span class=\"line\">^C</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-4-特殊文件与程序\"><a href=\"#1-1-4-特殊文件与程序\" class=\"headerlink\" title=\"1.1.4 特殊文件与程序\"></a>1.1.4 特殊文件与程序</h5><h6 id=\"1-1-4-1-具有SUID-SGID权限的命令执行状态\"><a href=\"#1-1-4-1-具有SUID-SGID权限的命令执行状态\" class=\"headerlink\" title=\"1.1.4.1 具有SUID/SGID权限的命令执行状态\"></a>1.1.4.1 具有SUID/SGID权限的命令执行状态</h6><p>普通用户用户都有权限通过passwd修改自己的密码，但是密码文件的权限是root，那为什么普通用户有权限读写呢？因为普通用户有passwd程序的特殊权限，他在运行passwd程序时，会自动取得一个新的进程与PID，且具有owner的权限，即具有读写权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密码文件的默认权限644，也就是普通用户只可以去读。</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -alt /etc/passwd</span><br><span class=\"line\">-rw-r--r-- 1 root root 1175 Mar 11 00:07 /etc/passwd</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">找到passwd程序，并看他的权限，他有SUID权限</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ whereis passwd</span><br><span class=\"line\">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -alt /usr/bin/passwd</span><br><span class=\"line\">-rwsr-xr-x 1 root root 27856 Aug  9  2019 /usr/bin/passwd</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"1-1-4-2-进程数据的查看\"><a href=\"#1-1-4-2-进程数据的查看\" class=\"headerlink\" title=\"1.1.4.2 进程数据的查看\"></a>1.1.4.2 进程数据的查看</h6><p>其实进程都是加载到内存中运行的，而内存中的数据又都是写入到/proc/*这个目录的。我们当然可以查看/proc/下面的数据。我们发现目前主机上运行的进程，都是以PID编号命名，存到这里的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -ltr /proc/</span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx  1 root    root                  0 Mar 15 10:34 self -&gt; 10312</span><br><span class=\"line\">-r--r--r--  1 root    root                  0 Mar 15 10:34 swaps</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 342</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 362</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 363</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 468</span><br><span class=\"line\">dr-xr-xr-x  9 polkitd polkitd               0 Mar 15 10:34 492</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 496</span><br><span class=\"line\">dr-xr-xr-x  9 dbus    dbus                  0 Mar 15 10:34 503</span><br><span class=\"line\">dr-xr-xr-x  9 chrony  chrony                0 Mar 15 10:34 510</span><br><span class=\"line\"></span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ps -ef|grep 342</span><br><span class=\"line\">root       342     1  0 Mar15 ?        00:00:03 /usr/lib/systemd/systemd-journald</span><br><span class=\"line\">robin    10314 10261  0 22:33 pts/1    00:00:00 grep --color=auto 342</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<p>这个以PID编号命名的为文件夹里，有什么内容呢？这里面有好多内容，我们可以先了解下cmdline和environ，前者存储的是这个进程被启动的命令串，后者存储的是进程的环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 10319]$ ps -ef|grep sleep</span><br><span class=\"line\">robin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000</span><br><span class=\"line\">robin    10346 10261  0 22:39 pts/1    00:00:00 grep --color=auto sleep</span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ cd /proc/10319/</span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ ll</span><br><span class=\"line\">total 0</span><br><span class=\"line\">dr-xr-xr-x 2 robin robin 0 Mar 28 22:35 attr</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 autogroup</span><br><span class=\"line\">-r-------- 1 robin robin 0 Mar 28 22:35 auxv</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:34 cgroup</span><br><span class=\"line\">--w------- 1 robin robin 0 Mar 28 22:35 clear_refs</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:34 cmdline</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 comm</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 coredump_filter</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:35 cpuset</span><br><span class=\"line\">lrwxrwxrwx 1 robin robin 0 Mar 28 22:34 cwd -&gt; /proc/342</span><br><span class=\"line\">-r-------- 1 robin robin 0 Mar 28 22:35 environ</span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ cat cmdline</span><br><span class=\"line\">sleep100000[robin@aliyun-hk1 10319]$ cat environ</span><br><span class=\"line\">XDG_SESSION_ID=2314HOSTNAME=aliyun-hk1TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，常见/prod/下文件与对应的内容。<br>文件名     | 文件内容<br>——– | —–<br>/proc/cmdline | 加载kernel时所执行的相关参数<br>/proc/cpuinfo | 本机CPU相关的信息，例如频率、类型、数量<br>/proc/devices | 记录了系统各个主要设备的代号<br>/proc/filesystems| 目前系统上已加载的文件系统<br>/proc/loadavg|top uptime命令中负载的三个平均值就记录在这里<br>/proc/meminfo|查阅内存信息，相当于free的作用<br>/proc/mounts|    查阅系统已经挂载的数据，相当于mount<br>/proc/swaps|记录swap内容使用的文件系统<br>/proc/version|记录内核的版本</p>\n<h6 id=\"1-1-4-3-查询程序已打开的文件\"><a href=\"#1-1-4-3-查询程序已打开的文件\" class=\"headerlink\" title=\"1.1.4.3 查询程序已打开的文件\"></a>1.1.4.3 查询程序已打开的文件</h6><p>大家都应该遇到过，”too many open files…” 之类的错误吧? 这个其实跟打开文件数量超过系统限制有关系。<br><strong>使用fuser找出正在使用该文件的程序</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不加参数，默认打印PID号</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ fuser nohup.out</span><br><span class=\"line\">/home/robin/nohup.out: 10319</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ps -ef|grep 10319</span><br><span class=\"line\">robin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000</span><br><span class=\"line\">robin    10380 10261  0 22:58 pts/1    00:00:00 grep --color=auto 10319</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">加参数可以获取更多的进程信息</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ fuser -uv nohup.out</span><br><span class=\"line\">                     USER        PID ACCESS COMMAND</span><br><span class=\"line\">/home/robin/nohup.out:</span><br><span class=\"line\">                     robin     10319 F.... (robin)sleep</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用lsof找出被进程打开的文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找出robin用户下，被程序打开的所有文件</span><br><span class=\"line\">[root@aliyun-hk1 ~]# lsof -u robin|wc -l</span><br><span class=\"line\">108</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Linux系统是一个多任务的开源操作系统，后台运行着很多的进程。今天我们来学习下进程相关的内容。<br>","more":"</p>\n<h4 id=\"1-1-什么是进程\"><a href=\"#1-1-什么是进程\" class=\"headerlink\" title=\"1.1 什么是进程\"></a>1.1 什么是进程</h4><p>在linux系统中，触发任何一个事件时，系统都会将它定义为一个进程，并且给这个进程分配一个PID。</p>\n<h5 id=\"1-1-1-进程与程序\"><a href=\"#1-1-1-进程与程序\" class=\"headerlink\" title=\"1.1.1 进程与程序\"></a>1.1.1 进程与程序</h5><p>简单地说，执行一个程序、脚本或命令，就可以触发一个事件并且取得一个PID。在我看来就是内核读取磁盘中的一个程序，并且加载到内存中，给他分配一个进程号PID。总结下来，进程就是一个运行中的程序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运行bash后会生成一个子shell，查看其产生的进程</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  3819  3817  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 S     0  3875  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep</span><br><span class=\"line\">0 S     0  3881  3819  0  80   0 - 26989 hrtime pts/0    00:00:00 sleep</span><br><span class=\"line\">4 S     0  3949  3819  0  80   0 - 28894 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">0 R     0  3960  3949  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-2-工作管理（job-control\"><a href=\"#1-1-2-工作管理（job-control\" class=\"headerlink\" title=\"1.1.2 工作管理（job control )\"></a>1.1.2 工作管理（job control )</h5><p>将一个命令丢到后台去执行，即在命令末尾增加&amp;，就会产生一个job，包括job number，进程id等，这里的1是job号，3991是进程号。最开始的job状态是Running，后来执行结束后就自动变成了Done。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[root@aliyun-hk1 ~]# sleep 20 &amp;</span><br><span class=\"line\">[1] 3991</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Running                 sleep 20 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Done                    sleep 20</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用CTRL+Z，将目前的工作丢到后台去，所以就会产生一个job number。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# vim hello.js</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用jobs查看后前的后台工作状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>使用fg将后台作业恢复到前台执行,继续执行刚才的文件编辑。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]#fg</span><br></pre></td></tr></table></figure></p>\n<p>使用bg将在后台而且已暂停执行的job成为运行状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]-  Stopped                 vim hello.js</span><br><span class=\"line\">[2]   Running                 nohup sleep 20000 &amp;</span><br><span class=\"line\">[3]+  Stopped                 sleep 100000</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bg 3</span><br><span class=\"line\">[3]+ sleep 100000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# jobs</span><br><span class=\"line\">[1]+  Stopped                 vim hello.js</span><br><span class=\"line\">[2]   Running                 nohup sleep 20000 &amp;</span><br><span class=\"line\">[3]-  Running                 sleep 100000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>管理后台运行中的job：kill<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -signal job-number</span><br><span class=\"line\">kill -9 job-number 强制删除一个job</span><br><span class=\"line\">kill -15 以正常的程序方式终止一项工作</span><br><span class=\"line\">kill -2 代表由键盘执行CTRL+C一样的操作</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-3-进程管理\"><a href=\"#1-1-3-进程管理\" class=\"headerlink\" title=\"1.1.3 进程管理\"></a>1.1.3 进程管理</h5><p>学习和研究进程管理的意义其实很重大。在linux每个运行的程序，都会运行一个进程，这个程序是否还在运行需要看进程是否存在；如果linux系统的资源使用情况突然异常，需要快速找出这个可疑的进程；如果某个程序写得不好，导致有问题的进程存在，也需要找出他；如果有多个重要的用户级进程在系统运行，如果调整他们的优先级，也很重要。</p>\n<p><strong>进程基本信息查看，可以使用ps命令</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -l  仅查看自己的bash相关进程</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  6931  6929  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">0 R     0  7000  6931  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps aux 列出目前所有在内存中的进程</span><br><span class=\"line\">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\">root         1  0.0  0.6  43532  3420 ?        Ss   Mar15   0:07 /usr/lib/systemd/systemd</span><br><span class=\"line\">root         4  0.0  0.0      0     0 ?        S&lt;   Mar15   0:00 [kworker/0:0H]</span><br><span class=\"line\">root         5  0.0  0.0      0     0 ?        S    Mar15   0:01 [kworker/u2:0]</span><br><span class=\"line\">root         6  0.0  0.0      0     0 ?        S    Mar15   0:01 [ksoftirqd/0]</span><br><span class=\"line\">root         7  0.0  0.0      0     0 ?        S    Mar15   0:00 [migration/0]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps axjf 查看进程并且包含进程树</span><br><span class=\"line\">    1   838   838   838 ?           -1 Ssl      0   1:39 /usr/bin/python2 -Es /usr/sbin/tuned -l -P</span><br><span class=\"line\"> 6931  7004  7003  6931 pts/0     7003 S+       0   0:00          \\_ grep --color=auto python</span><br><span class=\"line\">    1  1297  1296  1266 ?           -1 Sl       0   2:53 python proxyserver.py 11081</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><strong>进程动态信息查看，可以使用top命令</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入top后，默认系统就会列出所有进程的信息和整体资源的占用情况。</span><br><span class=\"line\">top - 23:14:35 up 11 days, 12:39,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">Tasks:  71 total,   1 running,  70 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :   498664 total,    36480 free,    95232 used,   366952 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.   389812 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  975 root      10 -10  127960  10768   6216 S  1.3  2.2 146:08.95 AliYunDun</span><br><span class=\"line\">    1 root      20   0   43532   3420   2104 S  0.0  0.7   0:07.60 systemd</span><br><span class=\"line\">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看某个进程的负载，可以这样玩</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# top -d 2 -p 975 </span><br><span class=\"line\">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">%Cpu(s):  0.5 us,  0.0 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :   498664 total,    36232 free,    95160 used,   367272 buff/cache</span><br><span class=\"line\">KiB Swap:        0 total,        0 free,        0 used.   389892 avail Mem</span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  975 root      10 -10  127960  10768   6216 S  1.0  2.2 146:13.63 AliYunDun</span><br></pre></td></tr></table></figure>\n<p><em>top命令很强大，可以持续监测整个系统的工作状态，默认情况下5秒更新一次。这个命令今天暂时不展开讲了。</em></p>\n<p><strong>进程之间关系的查看</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# pstree</span><br><span class=\"line\">systemd─┬─AliYunDun───23*[&#123;AliYunDun&#125;]</span><br><span class=\"line\">        ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;]</span><br><span class=\"line\">        ├─2*[agetty]</span><br><span class=\"line\">        ├─aliyun-service───2*[&#123;aliyun-service&#125;]</span><br><span class=\"line\">        ├─atd</span><br><span class=\"line\">        ├─auditd───&#123;auditd&#125;</span><br><span class=\"line\">        ├─chronyd</span><br><span class=\"line\">        ├─crond</span><br><span class=\"line\">        ├─dbus-daemon</span><br><span class=\"line\">        ├─dhclient</span><br><span class=\"line\">        ├─lvmetad</span><br><span class=\"line\">        ├─nginx───nginx</span><br><span class=\"line\">        ├─polkitd───6*[&#123;polkitd&#125;]</span><br><span class=\"line\">        ├─python───13*[&#123;python&#125;]</span><br><span class=\"line\">        ├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class=\"line\">        ├─sshd───sshd───bash───pstree</span><br><span class=\"line\">        ├─systemd-journal</span><br><span class=\"line\">        ├─systemd-logind</span><br><span class=\"line\">        ├─systemd-udevd</span><br><span class=\"line\">        └─tuned───4*[&#123;tuned&#125;]</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>进程的管理和控制</strong><br>我们要控制某个进程，只要给他发信号就可以了，进程的唯一标识符就是进程ID。<br>通过进程PID来终止进程，语法为：kill -signal PID，例如: kill -9 12306<br>代号     | 含义<br>——– | —–<br>1  | 启动被终止的进程<br>2 | 相当于键盘输入CTRL+C来中断一个进程<br>9  |强制中断某一个进程<br>15|等待进程完成后续操作后，结束该进程<br>17|相当于用户键入CTRL+Z暂停一个进程的执行</p>\n<p>通过进程PID来终止进程，语法为：killall [command name]，例如：killall -9 httpd</p>\n<p><strong>进程的执行顺序</strong><br>Linux是多用户、多任务的环境，由top输出的结果我们也可以发现，系统同时间有非常多的进程运行中，只是绝大部分的进程都在休眠（sleep)状态而已。操作系统内核，有默认的调度规则，会自动计算出一个“优先执行序”（priority,PRI)，这个PRI值越低代表越优先，用户无法干预这个PRI。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 linux-shell-test]$ ps -alt</span><br><span class=\"line\">F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND</span><br><span class=\"line\">4     0   560     1  20   0 110108   824 n_tty_ Ss+  ttyS0      0:00 /sbin/agetty --keep-baud 115200,38400,9600 ttyS0 vt220</span><br><span class=\"line\">4     0   561     1  20   0 110108   820 n_tty_ Ss+  tty1       0:00 /sbin/agetty --noclear tty1 linux</span><br><span class=\"line\">4     0  8614  8612  20   0 115580  2084 do_wai Ss   pts/0      0:00 -bash</span><br><span class=\"line\">4     0  8631  8614  20   0 191784  2340 do_wai S    pts/0      0:00 su - robin</span><br><span class=\"line\">4  1000  8632  8631  20   0 115448  2096 do_wai S    pts/0      0:00 -bash</span><br><span class=\"line\">0  1000  8675  8632  20   0 153248  1500 -      R+   pts/0      0:00 ps -alt</span><br><span class=\"line\">[robin@aliyun-hk1 linux-shell-test]$</span><br></pre></td></tr></table></figure></p>\n<p>可以通过Nice来调整，也就是上面的NI，一般他们的关系如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRI(new) = PRI(old) + nice</span><br></pre></td></tr></table></figure></p>\n<p>root可以随意调整自己或他人进程的nice值，调整的范围是-20~19；<br>一般用户可以调整的范围仅为0-19（为了避免抢占系统资源），而且只能调大，或者初次使用时设置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新启动一个程序，并设置nice为-5</span><br><span class=\"line\">[root@aliyun-hk1 ~]# nice -n -5 vi &amp;</span><br><span class=\"line\">[1] 8699</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  80   0 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  75  -5 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8700  8614  0  80   0 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\"></span><br><span class=\"line\">[1]+  Stopped                 nice -n -5 vi</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>调整现有进程的优先级，nice值重新调整<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# renice 10 8699</span><br><span class=\"line\">8699 (process ID) old priority -5, new priority 10</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  90  10 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8718  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]# renice 9 8699</span><br><span class=\"line\">8699 (process ID) old priority 10, new priority 9</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">4 S     0  8614  8612  0  90  10 - 28895 do_wai pts/0    00:00:00 bash</span><br><span class=\"line\">4 T     0  8699  8614  0  89   9 - 31055 do_sig pts/0    00:00:00 vi</span><br><span class=\"line\">0 R     0  8720  8614  0  90  10 - 38312 -      pts/0    00:00:00 ps</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p><em>因为一般用户只能调高nice，即降低优先级，所以我们一般通过调大nice降低非核心任务的优先级，保证核心业务运行的优先级。</em></p>\n<p><strong>系统资源查看</strong><br>除了系统进程管理外，我们还需要了解如何查询其他系统资源，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# free -m free 查看内存使用情况</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:            486          93          34           0         359         380</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure></p>\n<p><em>Linux系统管理内存的方式跟windows有很大差异，为了让用户的体验更好，系统性能更好，内核会尽可能使用现有的内存，所以如果内存几乎被用光，不要心慌。除非swap开始被大量使用， 才要开始警惕。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# uname -a 内核基本信息查看</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-1062.12.1.el7.x86_64 #1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><em>内核基本信息主要包括，主机名、内核版本、创建日期、试用的硬件平台等。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# uptime 查看系统启动时间及负载</span><br><span class=\"line\"> 00:03:22 up 12 days, 13:28,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure>\n<p><em>启动时间就是系统已经开启或重启多久了，负载就是只1，5，15分钟的平均负载。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# netstat -an 查看网络信息</span><br><span class=\"line\">Active Internet connections (servers and established)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class=\"line\">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:11081           0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN</span><br><span class=\"line\">tcp        0      0 172.31.200.164:11081    47.103.99.182:53826     ESTABLISHED</span><br></pre></td></tr></table></figure>\n<p><em>一般我们最长去使用netstat去判断某个进程是否开启了xx监听端口。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# dmesg |more 分析内核产生的信息</span><br><span class=\"line\">[    0.000000]   0 base 000080000000 mask 3FFF80000000 uncachable</span><br><span class=\"line\">[    0.000000]   1 disabled</span><br><span class=\"line\">[    0.000000]   2 disabled</span><br><span class=\"line\">[    0.000000]   3 disabled</span><br><span class=\"line\">[    0.000000]   4 disabled</span><br><span class=\"line\">[    0.000000]   5 disabled</span><br><span class=\"line\">[    0.000000]   6 disabled</span><br><span class=\"line\">[    0.000000]   7 disabled</span><br><span class=\"line\">[    0.000000] PAT configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- UC</span><br><span class=\"line\">[    0.000000] found SMP MP-table at [mem 0x000f59f0-0x000f59ff] mapped at [ffffffffff2009f0]</span><br><span class=\"line\">[    0.000000] Base memory trampoline at [ffff9bf500099000] 99000 size 24576</span><br><span class=\"line\">[    0.000000] Using GB pages for direct mapping</span><br><span class=\"line\">[    0.000000] BRK [0x0b270000, 0x0b270fff] PGTABLE</span><br><span class=\"line\">[    0.000000] BRK [0x0b271000, 0x0b271fff] PGTABLE</span><br></pre></td></tr></table></figure>\n<p><strong>vmstat 检测系统资源变化，结合top分析系统瓶颈。</strong><br>他可以动态查看CPU/内存/磁盘/IO等数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# vmstat 查看一次数据</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 2  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0</span><br><span class=\"line\">[root@aliyun-hk1 ~]# vmstat 3 每3秒动态输出一次</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 1  0      0  34064  67792 300812    0    0     1     2   31    4  0  0 99  0  0</span><br><span class=\"line\"> 0  0      0  34064  67800 300812    0    0     0     5  267  875  0  0 99  0  0</span><br><span class=\"line\">^C</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-4-特殊文件与程序\"><a href=\"#1-1-4-特殊文件与程序\" class=\"headerlink\" title=\"1.1.4 特殊文件与程序\"></a>1.1.4 特殊文件与程序</h5><h6 id=\"1-1-4-1-具有SUID-SGID权限的命令执行状态\"><a href=\"#1-1-4-1-具有SUID-SGID权限的命令执行状态\" class=\"headerlink\" title=\"1.1.4.1 具有SUID/SGID权限的命令执行状态\"></a>1.1.4.1 具有SUID/SGID权限的命令执行状态</h6><p>普通用户用户都有权限通过passwd修改自己的密码，但是密码文件的权限是root，那为什么普通用户有权限读写呢？因为普通用户有passwd程序的特殊权限，他在运行passwd程序时，会自动取得一个新的进程与PID，且具有owner的权限，即具有读写权限。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">密码文件的默认权限644，也就是普通用户只可以去读。</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -alt /etc/passwd</span><br><span class=\"line\">-rw-r--r-- 1 root root 1175 Mar 11 00:07 /etc/passwd</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">找到passwd程序，并看他的权限，他有SUID权限</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ whereis passwd</span><br><span class=\"line\">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -alt /usr/bin/passwd</span><br><span class=\"line\">-rwsr-xr-x 1 root root 27856 Aug  9  2019 /usr/bin/passwd</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"1-1-4-2-进程数据的查看\"><a href=\"#1-1-4-2-进程数据的查看\" class=\"headerlink\" title=\"1.1.4.2 进程数据的查看\"></a>1.1.4.2 进程数据的查看</h6><p>其实进程都是加载到内存中运行的，而内存中的数据又都是写入到/proc/*这个目录的。我们当然可以查看/proc/下面的数据。我们发现目前主机上运行的进程，都是以PID编号命名，存到这里的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 ~]$ ls -ltr /proc/</span><br><span class=\"line\">total 0</span><br><span class=\"line\">lrwxrwxrwx  1 root    root                  0 Mar 15 10:34 self -&gt; 10312</span><br><span class=\"line\">-r--r--r--  1 root    root                  0 Mar 15 10:34 swaps</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 342</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 362</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 363</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 468</span><br><span class=\"line\">dr-xr-xr-x  9 polkitd polkitd               0 Mar 15 10:34 492</span><br><span class=\"line\">dr-xr-xr-x  9 root    root                  0 Mar 15 10:34 496</span><br><span class=\"line\">dr-xr-xr-x  9 dbus    dbus                  0 Mar 15 10:34 503</span><br><span class=\"line\">dr-xr-xr-x  9 chrony  chrony                0 Mar 15 10:34 510</span><br><span class=\"line\"></span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ps -ef|grep 342</span><br><span class=\"line\">root       342     1  0 Mar15 ?        00:00:03 /usr/lib/systemd/systemd-journald</span><br><span class=\"line\">robin    10314 10261  0 22:33 pts/1    00:00:00 grep --color=auto 342</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<p>这个以PID编号命名的为文件夹里，有什么内容呢？这里面有好多内容，我们可以先了解下cmdline和environ，前者存储的是这个进程被启动的命令串，后者存储的是进程的环境变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[robin@aliyun-hk1 10319]$ ps -ef|grep sleep</span><br><span class=\"line\">robin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000</span><br><span class=\"line\">robin    10346 10261  0 22:39 pts/1    00:00:00 grep --color=auto sleep</span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ cd /proc/10319/</span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ ll</span><br><span class=\"line\">total 0</span><br><span class=\"line\">dr-xr-xr-x 2 robin robin 0 Mar 28 22:35 attr</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 autogroup</span><br><span class=\"line\">-r-------- 1 robin robin 0 Mar 28 22:35 auxv</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:34 cgroup</span><br><span class=\"line\">--w------- 1 robin robin 0 Mar 28 22:35 clear_refs</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:34 cmdline</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 comm</span><br><span class=\"line\">-rw-r--r-- 1 robin robin 0 Mar 28 22:35 coredump_filter</span><br><span class=\"line\">-r--r--r-- 1 robin robin 0 Mar 28 22:35 cpuset</span><br><span class=\"line\">lrwxrwxrwx 1 robin robin 0 Mar 28 22:34 cwd -&gt; /proc/342</span><br><span class=\"line\">-r-------- 1 robin robin 0 Mar 28 22:35 environ</span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><br><span class=\"line\">[robin@aliyun-hk1 10319]$ cat cmdline</span><br><span class=\"line\">sleep100000[robin@aliyun-hk1 10319]$ cat environ</span><br><span class=\"line\">XDG_SESSION_ID=2314HOSTNAME=aliyun-hk1TERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>Linux系统，常见/prod/下文件与对应的内容。<br>文件名     | 文件内容<br>——– | —–<br>/proc/cmdline | 加载kernel时所执行的相关参数<br>/proc/cpuinfo | 本机CPU相关的信息，例如频率、类型、数量<br>/proc/devices | 记录了系统各个主要设备的代号<br>/proc/filesystems| 目前系统上已加载的文件系统<br>/proc/loadavg|top uptime命令中负载的三个平均值就记录在这里<br>/proc/meminfo|查阅内存信息，相当于free的作用<br>/proc/mounts|    查阅系统已经挂载的数据，相当于mount<br>/proc/swaps|记录swap内容使用的文件系统<br>/proc/version|记录内核的版本</p>\n<h6 id=\"1-1-4-3-查询程序已打开的文件\"><a href=\"#1-1-4-3-查询程序已打开的文件\" class=\"headerlink\" title=\"1.1.4.3 查询程序已打开的文件\"></a>1.1.4.3 查询程序已打开的文件</h6><p>大家都应该遇到过，”too many open files…” 之类的错误吧? 这个其实跟打开文件数量超过系统限制有关系。<br><strong>使用fuser找出正在使用该文件的程序</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不加参数，默认打印PID号</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ fuser nohup.out</span><br><span class=\"line\">/home/robin/nohup.out: 10319</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ ps -ef|grep 10319</span><br><span class=\"line\">robin    10319 10261  0 22:34 pts/1    00:00:00 sleep 100000</span><br><span class=\"line\">robin    10380 10261  0 22:58 pts/1    00:00:00 grep --color=auto 10319</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br><span class=\"line\"></span><br><span class=\"line\">加参数可以获取更多的进程信息</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$ fuser -uv nohup.out</span><br><span class=\"line\">                     USER        PID ACCESS COMMAND</span><br><span class=\"line\">/home/robin/nohup.out:</span><br><span class=\"line\">                     robin     10319 F.... (robin)sleep</span><br><span class=\"line\">[robin@aliyun-hk1 ~]$</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用lsof找出被进程打开的文件</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找出robin用户下，被程序打开的所有文件</span><br><span class=\"line\">[root@aliyun-hk1 ~]# lsof -u robin|wc -l</span><br><span class=\"line\">108</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之管道命令","date":"2020-03-08T23:08:08.000Z","_content":"\n在linux世界，虽然你不一定熟悉**管道**的概念，但是你肯定已经用过了。当Bash命令执行的时候大部分时候都会有数据输出，如果这个输出的数据还要传递给其他的命令继续处理，就要用到管道(pipe)命令了，管道命令使用的是“|”这个符号。\n<!--more-->\n\nexample1: 查询docker进程是否存在，我们将ps命令查询的结果通过管道传递给grep命令，再进行二次刷选，结果就出来了。**注意：这个管道命令“|”仅能处理经由前面一个命令传来的正确信息，也就是standard output的信息**，对于standard error并没有直接处理的能力。**管道后面必须是“命令”，而且这个命令必须可以接收standard input的数据才行**，例如less,more,grep等，至于例如ls,cp,mv就不会接收来自stdin的数据。\n```\n[root@aliyun-hk1 ~]# ps -ef|grep docker\nroot     10269 10243  0 00:02 pts/0    00:00:00 grep --color=auto docker\nroot     29006     1  0 Mar02 ?        00:06:53 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2\nroot     29011 29006  0 Mar02 ?        00:04:31 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --runtime-args --systemd-cgroup=true\nroot     31808 29006  0 Mar02 ?        00:00:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 8081 -container-ip 172.17.0.2 -container-port 80\nroot     31826 29011  0 Mar02 ?        00:00:00 /usr/bin/docker-containerd-shim-current b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /var/run/docker/libcontainerd/b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /usr/libexec/docker/docker-runc-current\n[root@aliyun-hk1 ~]#\n```\n\nexample2：支持管道，也就是支持standard input的命令，这些命令用法后面章节细讲。\n```\n字符选取命令 cut,grep\n字符显示命令 less,more,head,tail等文本处理命令\n字符排序命令 sort,wc,uniq\n双重定向命令 tee\n字符转换命令 tr,col,join,paste,expand\n```\n\nexample3：不支持管道，也就是不支持standard input的命令。\n```\n文件或目录操作命令 cp,mv,ls\n```\n\nexample4：**不支持管道的命令，通过xargs传递数据给下一个命令**。xargs可以读入standard input的数据，并且以**空格符或断行字符**进行分辨，将stdin的数据分隔成为命令行参数，供其他命令使用。查询包含docker的文件，并且统计文件数量。\n```\nxargs [-0epn] command\n[root@aliyun-hk1 /]# find . -name docker|xargs ls -alt|wc -l\n158\n```\n\nexample5：xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如**多行变单行，单行变多行**。使用xargs是单行输出全部，使用xargs -nx每行输出x个，\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh          \nhello                                                     \nworld                                                     \nni                                                        \nhao                                                       \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs    \nhello world ni hao                                        \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n2\nhello world                                               \nni hao                                                    \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n3\nhello world ni                                            \nhao                                                       \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n4\nhello world ni hao                                        \n[root@aliyun-hk1 linux-shell-test]#                       \n​```\n\nexample6​：xargs使用非默认的分隔符，默认的分隔符为空格或​断行字符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh\nhelloXworldXnihaoXzhongguo\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX -n2\nhello world\nnihao zhongguo\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX\nhello world nihao zhongguo\n[root@aliyun-hk1 linux-shell-test]#\n```\n\nexample7: xargs使用-I 和-i作为参数​，将管道的stdout转成stdin并逐个在后面命令中使用。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh\nhello\nworld\nni\nhao\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -I {} echo 'this line is {}'\nthis line is hello\nthis line is world\nthis line is ni\nthis line is hao\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -i echo 'this line is {}'\nthis line is hello\nthis line is world\nthis line is ni\nthis line is hao\n```\n\nexample8: xargs逐行显示输出给后面命令的参数，尤其当你需要将文件查找的结果传递给sed的时候，并且sed使用了-i参数的时候。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -t -i sed -i 's/hello/hallo/g' {}\nsed -i s/hello/hallo/g xargs.sh\nsed -i s/hello/hallo/g xargs1.sh\nsed -i s/hello/hallo/g xargs2.sh\n```","source":"_posts/linux/linux_pipe.md","raw":"---\ntitle: Linux之管道命令\ndate: 2020-03-08 23:08:08\ntags: shell\ncategories: linux\n---\n\n在linux世界，虽然你不一定熟悉**管道**的概念，但是你肯定已经用过了。当Bash命令执行的时候大部分时候都会有数据输出，如果这个输出的数据还要传递给其他的命令继续处理，就要用到管道(pipe)命令了，管道命令使用的是“|”这个符号。\n<!--more-->\n\nexample1: 查询docker进程是否存在，我们将ps命令查询的结果通过管道传递给grep命令，再进行二次刷选，结果就出来了。**注意：这个管道命令“|”仅能处理经由前面一个命令传来的正确信息，也就是standard output的信息**，对于standard error并没有直接处理的能力。**管道后面必须是“命令”，而且这个命令必须可以接收standard input的数据才行**，例如less,more,grep等，至于例如ls,cp,mv就不会接收来自stdin的数据。\n```\n[root@aliyun-hk1 ~]# ps -ef|grep docker\nroot     10269 10243  0 00:02 pts/0    00:00:00 grep --color=auto docker\nroot     29006     1  0 Mar02 ?        00:06:53 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2\nroot     29011 29006  0 Mar02 ?        00:04:31 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --runtime-args --systemd-cgroup=true\nroot     31808 29006  0 Mar02 ?        00:00:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 8081 -container-ip 172.17.0.2 -container-port 80\nroot     31826 29011  0 Mar02 ?        00:00:00 /usr/bin/docker-containerd-shim-current b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /var/run/docker/libcontainerd/b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /usr/libexec/docker/docker-runc-current\n[root@aliyun-hk1 ~]#\n```\n\nexample2：支持管道，也就是支持standard input的命令，这些命令用法后面章节细讲。\n```\n字符选取命令 cut,grep\n字符显示命令 less,more,head,tail等文本处理命令\n字符排序命令 sort,wc,uniq\n双重定向命令 tee\n字符转换命令 tr,col,join,paste,expand\n```\n\nexample3：不支持管道，也就是不支持standard input的命令。\n```\n文件或目录操作命令 cp,mv,ls\n```\n\nexample4：**不支持管道的命令，通过xargs传递数据给下一个命令**。xargs可以读入standard input的数据，并且以**空格符或断行字符**进行分辨，将stdin的数据分隔成为命令行参数，供其他命令使用。查询包含docker的文件，并且统计文件数量。\n```\nxargs [-0epn] command\n[root@aliyun-hk1 /]# find . -name docker|xargs ls -alt|wc -l\n158\n```\n\nexample5：xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如**多行变单行，单行变多行**。使用xargs是单行输出全部，使用xargs -nx每行输出x个，\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh          \nhello                                                     \nworld                                                     \nni                                                        \nhao                                                       \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs    \nhello world ni hao                                        \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n2\nhello world                                               \nni hao                                                    \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n3\nhello world ni                                            \nhao                                                       \n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n4\nhello world ni hao                                        \n[root@aliyun-hk1 linux-shell-test]#                       \n​```\n\nexample6​：xargs使用非默认的分隔符，默认的分隔符为空格或​断行字符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh\nhelloXworldXnihaoXzhongguo\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX -n2\nhello world\nnihao zhongguo\n[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX\nhello world nihao zhongguo\n[root@aliyun-hk1 linux-shell-test]#\n```\n\nexample7: xargs使用-I 和-i作为参数​，将管道的stdout转成stdin并逐个在后面命令中使用。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh\nhello\nworld\nni\nhao\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -I {} echo 'this line is {}'\nthis line is hello\nthis line is world\nthis line is ni\nthis line is hao\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -i echo 'this line is {}'\nthis line is hello\nthis line is world\nthis line is ni\nthis line is hao\n```\n\nexample8: xargs逐行显示输出给后面命令的参数，尤其当你需要将文件查找的结果传递给sed的时候，并且sed使用了-i参数的时候。\n```\n[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -t -i sed -i 's/hello/hallo/g' {}\nsed -i s/hello/hallo/g xargs.sh\nsed -i s/hello/hallo/g xargs1.sh\nsed -i s/hello/hallo/g xargs2.sh\n```","slug":"linux/linux_pipe","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdet5003v0en7tc3kt0pq","content":"<p>在linux世界，虽然你不一定熟悉<strong>管道</strong>的概念，但是你肯定已经用过了。当Bash命令执行的时候大部分时候都会有数据输出，如果这个输出的数据还要传递给其他的命令继续处理，就要用到管道(pipe)命令了，管道命令使用的是“|”这个符号。<br><a id=\"more\"></a></p>\n<p>example1: 查询docker进程是否存在，我们将ps命令查询的结果通过管道传递给grep命令，再进行二次刷选，结果就出来了。<strong>注意：这个管道命令“|”仅能处理经由前面一个命令传来的正确信息，也就是standard output的信息</strong>，对于standard error并没有直接处理的能力。<strong>管道后面必须是“命令”，而且这个命令必须可以接收standard input的数据才行</strong>，例如less,more,grep等，至于例如ls,cp,mv就不会接收来自stdin的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -ef|grep docker</span><br><span class=\"line\">root     10269 10243  0 00:02 pts/0    00:00:00 grep --color=auto docker</span><br><span class=\"line\">root     29006     1  0 Mar02 ?        00:06:53 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2</span><br><span class=\"line\">root     29011 29006  0 Mar02 ?        00:04:31 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --runtime-args --systemd-cgroup=true</span><br><span class=\"line\">root     31808 29006  0 Mar02 ?        00:00:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 8081 -container-ip 172.17.0.2 -container-port 80</span><br><span class=\"line\">root     31826 29011  0 Mar02 ?        00:00:00 /usr/bin/docker-containerd-shim-current b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /var/run/docker/libcontainerd/b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /usr/libexec/docker/docker-runc-current</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>example2：支持管道，也就是支持standard input的命令，这些命令用法后面章节细讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符选取命令 cut,grep</span><br><span class=\"line\">字符显示命令 less,more,head,tail等文本处理命令</span><br><span class=\"line\">字符排序命令 sort,wc,uniq</span><br><span class=\"line\">双重定向命令 tee</span><br><span class=\"line\">字符转换命令 tr,col,join,paste,expand</span><br></pre></td></tr></table></figure></p>\n<p>example3：不支持管道，也就是不支持standard input的命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件或目录操作命令 cp,mv,ls</span><br></pre></td></tr></table></figure></p>\n<p>example4：<strong>不支持管道的命令，通过xargs传递数据给下一个命令</strong>。xargs可以读入standard input的数据，并且以<strong>空格符或断行字符</strong>进行分辨，将stdin的数据分隔成为命令行参数，供其他命令使用。查询包含docker的文件，并且统计文件数量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xargs [-0epn] command</span><br><span class=\"line\">[root@aliyun-hk1 /]# find . -name docker|xargs ls -alt|wc -l</span><br><span class=\"line\">158</span><br></pre></td></tr></table></figure></p>\n<p>example5：xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如<strong>多行变单行，单行变多行</strong>。使用xargs是单行输出全部，使用xargs -nx每行输出x个，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh          </span><br><span class=\"line\">hello                                                     </span><br><span class=\"line\">world                                                     </span><br><span class=\"line\">ni                                                        </span><br><span class=\"line\">hao                                                       </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs    </span><br><span class=\"line\">hello world ni hao                                        </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n2</span><br><span class=\"line\">hello world                                               </span><br><span class=\"line\">ni hao                                                    </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n3</span><br><span class=\"line\">hello world ni                                            </span><br><span class=\"line\">hao                                                       </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n4</span><br><span class=\"line\">hello world ni hao                                        </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#                       </span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure></p>\n<p>example6​：xargs使用非默认的分隔符，默认的分隔符为空格或​断行字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh</span><br><span class=\"line\">helloXworldXnihaoXzhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX -n2</span><br><span class=\"line\">hello world</span><br><span class=\"line\">nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX</span><br><span class=\"line\">hello world nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>example7: xargs使用-I 和-i作为参数​，将管道的stdout转成stdin并逐个在后面命令中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">ni</span><br><span class=\"line\">hao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -I &#123;&#125; echo &apos;this line is &#123;&#125;&apos;</span><br><span class=\"line\">this line is hello</span><br><span class=\"line\">this line is world</span><br><span class=\"line\">this line is ni</span><br><span class=\"line\">this line is hao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -i echo &apos;this line is &#123;&#125;&apos;</span><br><span class=\"line\">this line is hello</span><br><span class=\"line\">this line is world</span><br><span class=\"line\">this line is ni</span><br><span class=\"line\">this line is hao</span><br></pre></td></tr></table></figure></p>\n<p>example8: xargs逐行显示输出给后面命令的参数，尤其当你需要将文件查找的结果传递给sed的时候，并且sed使用了-i参数的时候。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -t -i sed -i &apos;s/hello/hallo/g&apos; &#123;&#125;</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs.sh</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs1.sh</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs2.sh</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>在linux世界，虽然你不一定熟悉<strong>管道</strong>的概念，但是你肯定已经用过了。当Bash命令执行的时候大部分时候都会有数据输出，如果这个输出的数据还要传递给其他的命令继续处理，就要用到管道(pipe)命令了，管道命令使用的是“|”这个符号。<br>","more":"</p>\n<p>example1: 查询docker进程是否存在，我们将ps命令查询的结果通过管道传递给grep命令，再进行二次刷选，结果就出来了。<strong>注意：这个管道命令“|”仅能处理经由前面一个命令传来的正确信息，也就是standard output的信息</strong>，对于standard error并没有直接处理的能力。<strong>管道后面必须是“命令”，而且这个命令必须可以接收standard input的数据才行</strong>，例如less,more,grep等，至于例如ls,cp,mv就不会接收来自stdin的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -ef|grep docker</span><br><span class=\"line\">root     10269 10243  0 00:02 pts/0    00:00:00 grep --color=auto docker</span><br><span class=\"line\">root     29006     1  0 Mar02 ?        00:06:53 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-current --seccomp-profile=/etc/docker/seccomp.json --selinux-enabled --log-driver=journald --signature-verification=false --storage-driver overlay2</span><br><span class=\"line\">root     29011 29006  0 Mar02 ?        00:04:31 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --runtime-args --systemd-cgroup=true</span><br><span class=\"line\">root     31808 29006  0 Mar02 ?        00:00:00 /usr/libexec/docker/docker-proxy-current -proto tcp -host-ip 0.0.0.0 -host-port 8081 -container-ip 172.17.0.2 -container-port 80</span><br><span class=\"line\">root     31826 29011  0 Mar02 ?        00:00:00 /usr/bin/docker-containerd-shim-current b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /var/run/docker/libcontainerd/b380c65a2b75d32f53a56f17b1dd816449bfaf0048996b783a47daf023bb7870 /usr/libexec/docker/docker-runc-current</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>example2：支持管道，也就是支持standard input的命令，这些命令用法后面章节细讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符选取命令 cut,grep</span><br><span class=\"line\">字符显示命令 less,more,head,tail等文本处理命令</span><br><span class=\"line\">字符排序命令 sort,wc,uniq</span><br><span class=\"line\">双重定向命令 tee</span><br><span class=\"line\">字符转换命令 tr,col,join,paste,expand</span><br></pre></td></tr></table></figure></p>\n<p>example3：不支持管道，也就是不支持standard input的命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件或目录操作命令 cp,mv,ls</span><br></pre></td></tr></table></figure></p>\n<p>example4：<strong>不支持管道的命令，通过xargs传递数据给下一个命令</strong>。xargs可以读入standard input的数据，并且以<strong>空格符或断行字符</strong>进行分辨，将stdin的数据分隔成为命令行参数，供其他命令使用。查询包含docker的文件，并且统计文件数量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xargs [-0epn] command</span><br><span class=\"line\">[root@aliyun-hk1 /]# find . -name docker|xargs ls -alt|wc -l</span><br><span class=\"line\">158</span><br></pre></td></tr></table></figure></p>\n<p>example5：xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如<strong>多行变单行，单行变多行</strong>。使用xargs是单行输出全部，使用xargs -nx每行输出x个，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh          </span><br><span class=\"line\">hello                                                     </span><br><span class=\"line\">world                                                     </span><br><span class=\"line\">ni                                                        </span><br><span class=\"line\">hao                                                       </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs    </span><br><span class=\"line\">hello world ni hao                                        </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n2</span><br><span class=\"line\">hello world                                               </span><br><span class=\"line\">ni hao                                                    </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n3</span><br><span class=\"line\">hello world ni                                            </span><br><span class=\"line\">hao                                                       </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -n4</span><br><span class=\"line\">hello world ni hao                                        </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#                       </span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure></p>\n<p>example6​：xargs使用非默认的分隔符，默认的分隔符为空格或​断行字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh</span><br><span class=\"line\">helloXworldXnihaoXzhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX -n2</span><br><span class=\"line\">hello world</span><br><span class=\"line\">nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs2.sh|xargs -dX</span><br><span class=\"line\">hello world nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>example7: xargs使用-I 和-i作为参数​，将管道的stdout转成stdin并逐个在后面命令中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">ni</span><br><span class=\"line\">hao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -I &#123;&#125; echo &apos;this line is &#123;&#125;&apos;</span><br><span class=\"line\">this line is hello</span><br><span class=\"line\">this line is world</span><br><span class=\"line\">this line is ni</span><br><span class=\"line\">this line is hao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -i echo &apos;this line is &#123;&#125;&apos;</span><br><span class=\"line\">this line is hello</span><br><span class=\"line\">this line is world</span><br><span class=\"line\">this line is ni</span><br><span class=\"line\">this line is hao</span><br></pre></td></tr></table></figure></p>\n<p>example8: xargs逐行显示输出给后面命令的参数，尤其当你需要将文件查找的结果传递给sed的时候，并且sed使用了-i参数的时候。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat xargs.sh|xargs -t -i sed -i &apos;s/hello/hallo/g&apos; &#123;&#125;</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs.sh</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs1.sh</span><br><span class=\"line\">sed -i s/hello/hallo/g xargs2.sh</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之理解shell","date":"2020-03-06T23:50:37.000Z","_content":"\n**Linux shell**是一个操作系统提供的、时刻都在运行的复杂交互式程序。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上进程的途径。对于linux OS 运维或linux shell编程而言，理解shell的概念​是重要的一课。\n\n<!--more-->\n\n当我们使用ssh客户端工具，通过密钥认证或者密码认证，登陆成功后，操作系统就为我们创建了一个shell进程​。\n```\nλ ssh root@lhh.pub\nLast login: Fri Mar  6 20:59:55 2020 from 222.90.142.131\nWelcome to Alibaba Cloud Elastic Compute Service !\nLast login: Fri Mar  6 20:59:55 2020 from 222.90.142.131\nWelcome to Alibaba Cloud Elastic Compute Service !\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 23:35 pts/1    00:00:00 -bash\nroot     26829 26811  0 23:35 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# date\nFri Mar  6 23:35:17 CST 2020\n```\n\n所有Linux发行版本的默认shell都是bash shell，因为它的功能最强大，除此之外还有korn shell、ash shell、C shell等等。当前用户自动打开什么shell，决定于用户的shell配置。一般root用户默认会使用bash shell,查看所有用户的shell可以这样玩。\n```\n[root@aliyun-hk1 ~]# cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n```\n\nbash shell程序位于/bin目录，可以发现它是个可执行程序。我们可能还听说过sh shell，它竟然是​一个指向bash的软连接，最起码在我们使用的CentOS是这样的。\n```\n[root@aliyun-hk1 ~]# ls -alt /bin/bash\n-rwxr-xr-x. 1 root root 964544 Apr 11  2018 /bin/bash\n[root@aliyun-hk1 ~]# ls -alt /bin/sh\nlrwxrwxrwx. 1 root root 4 Nov 29  2018 /bin/sh -> bash\n```\n\n\nshell的父子关系，我们使用ssh客户端登陆成功后，启动的默认交互shell，是一个父shell，后续​创建的shell都是子shell。请看父shell的进程ID是26811，后面进程的父进程PPID都是上一级的​进程PID。进程就是正在运行的一个程序。bash shell 是一个程序，当它运行的时候，​就会成为一个进程。所以我们经常​看到shell和进程的概念交叉使用。\n```\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28107 26811  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28122 28110  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28124 28110  0 00:00 pts/1    00:00:00 bash\nroot     28137 28124  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# pstree -p 26811\nbash(26811)───bash(28110)───bash(28124)───pstree(28150)\n[root@aliyun-hk1 ~]#\n```\n\n让子shell在后台运行，语法为shell command &\n```\n[root@aliyun-hk1 ~]# sleep 10000 &\n[1] 28458\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28124 28110  0 00:00 pts/1    00:00:00 bash\nroot     28458 28124  0 00:06 pts/1    00:00:00 sleep 10000\nroot     28462 28124  0 00:07 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]#\n```\n\n除了使用ps外，还可以使用jobs命令查看后台的作业信息。\n```\n[root@aliyun-hk1 ~]# jobs -l\n[1]+ 28458 Running                 sleep 10000 &\n[root@aliyun-hk1 ~]#\n```\n\n说到了进程，我们再大概说说线程、​协程。其实跟CPU通信的最小单位是线程，而不是进程​。每个进程使用独立的资源，而同一个进程内部的线程共享资源，同一个线程内的协程​共享资源。以下示例，29006、29011、31826、31827、31926是几个独立的进程，每个进程内都有若干个线程。这几个概念的水其实很深，今天就​先初步讲一讲。\n```\n[root@aliyun-hk1 ~]# pstree -p 29006\ndockerd-current(29006)─┬─docker-containe(29011)─┬─docker-containe(31826)─┬─nginx(31872)───nginx(31926)\n                       │                        │                        ├─{docker-containe}(31831)\n                       │                        │                        ├─{docker-containe}(31832)\n                       │                        │                        ├─{docker-containe}(31833)\n                       │                        │                        ├─{docker-containe}(31834)\n                       │                        │                        ├─{docker-containe}(31835)\n                       │                        │                        ├─{docker-containe}(31836)\n                       │                        │                        ├─{docker-containe}(31842)\n                       │                        │                        └─{docker-containe}(31844)\n                       │                        ├─{docker-containe}(29012)\n                       │                        ├─{docker-containe}(29013)\n                       │                        ├─{docker-containe}(29014)\n                       │                        ├─{docker-containe}(29016)\n                       │                        ├─{docker-containe}(29017)\n                       │                        ├─{docker-containe}(29018)\n                       │                        ├─{docker-containe}(29023)\n                       │                        ├─{docker-containe}(29741)\n                       │                        └─{docker-containe}(29742)\n                       ├─docker-proxy-cu(31808)─┬─{docker-proxy-cu}(31809)\n                       │                        ├─{docker-proxy-cu}(31810)\n                       │                        ├─{docker-proxy-cu}(31811)\n                       │                        └─{docker-proxy-cu}(31812)\n                       ├─{dockerd-current}(29007)\n                       ├─{dockerd-current}(29008)\n                       ├─{dockerd-current}(29009)\n                       ├─{dockerd-current}(29010)\n                       ├─{dockerd-current}(29015)\n                       ├─{dockerd-current}(29020)\n                       ├─{dockerd-current}(29022)\n                       ├─{dockerd-current}(29024)\n                       ├─{dockerd-current}(29628)\n                       └─{dockerd-current}(29629)\n[root@aliyun-hk1 ~]#\n```\n\nshell的内建命令和外部命令，内建命令不会创建子shell和子进程，外部命令​运行时会创建子shell和子进程。例如ps就是一个外部命令，​pwd就是一个内部命令。当外部命令执行时，会创建一个子进程，这种操作也被称为衍生（forking）​。\n```\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     28932 28930  0 00:16 pts/2    00:00:00 -bash\nroot     28973 28932  0 00:16 pts/2    00:00:00 ps -f\n[root@aliyun-hk1 ~]# cd /\n[root@aliyun-hk1 /]# pwd\n/\n[root@aliyun-hk1 /]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     28932 28930  0 00:16 pts/2    00:00:00 -bash\nroot     28989 28932  0 00:17 pts/2    00:00:00 ps -f\n```\n\nhistory可以查看执行过的命令，仅限当前用户执行过的命令，无法跨用户查看history。​\n\n\n\n命令别名查看，使用alias，这个东西其实很重要，可以让好多​操作简化。\n```\n[root@aliyun-hk1 /]# alias -p                                                       \nalias cp='cp -i'                                                                    \nalias egrep='egrep --color=auto'                                                    \nalias fgrep='fgrep --color=auto'                                                    \nalias grep='grep --color=auto'                                                      \nalias l.='ls -d .* --color=auto'                                                    \nalias ll='ls -l --color=auto'                                                       \nalias ls='ls --color=auto'                                                          \nalias mv='mv -i'                                                                    \nalias rm='rm -i'                                                                    \nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n[root@aliyun-hk1 /]#\n```","source":"_posts/linux/linux_shel_under.md","raw":"---\ntitle: Linux之理解shell\ndate: 2020-03-06 23:50:37\ntags: shell\ncategories: linux\n---\n\n**Linux shell**是一个操作系统提供的、时刻都在运行的复杂交互式程序。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上进程的途径。对于linux OS 运维或linux shell编程而言，理解shell的概念​是重要的一课。\n\n<!--more-->\n\n当我们使用ssh客户端工具，通过密钥认证或者密码认证，登陆成功后，操作系统就为我们创建了一个shell进程​。\n```\nλ ssh root@lhh.pub\nLast login: Fri Mar  6 20:59:55 2020 from 222.90.142.131\nWelcome to Alibaba Cloud Elastic Compute Service !\nLast login: Fri Mar  6 20:59:55 2020 from 222.90.142.131\nWelcome to Alibaba Cloud Elastic Compute Service !\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 23:35 pts/1    00:00:00 -bash\nroot     26829 26811  0 23:35 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# date\nFri Mar  6 23:35:17 CST 2020\n```\n\n所有Linux发行版本的默认shell都是bash shell，因为它的功能最强大，除此之外还有korn shell、ash shell、C shell等等。当前用户自动打开什么shell，决定于用户的shell配置。一般root用户默认会使用bash shell,查看所有用户的shell可以这样玩。\n```\n[root@aliyun-hk1 ~]# cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n```\n\nbash shell程序位于/bin目录，可以发现它是个可执行程序。我们可能还听说过sh shell，它竟然是​一个指向bash的软连接，最起码在我们使用的CentOS是这样的。\n```\n[root@aliyun-hk1 ~]# ls -alt /bin/bash\n-rwxr-xr-x. 1 root root 964544 Apr 11  2018 /bin/bash\n[root@aliyun-hk1 ~]# ls -alt /bin/sh\nlrwxrwxrwx. 1 root root 4 Nov 29  2018 /bin/sh -> bash\n```\n\n\nshell的父子关系，我们使用ssh客户端登陆成功后，启动的默认交互shell，是一个父shell，后续​创建的shell都是子shell。请看父shell的进程ID是26811，后面进程的父进程PPID都是上一级的​进程PID。进程就是正在运行的一个程序。bash shell 是一个程序，当它运行的时候，​就会成为一个进程。所以我们经常​看到shell和进程的概念交叉使用。\n```\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28107 26811  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28122 28110  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28124 28110  0 00:00 pts/1    00:00:00 bash\nroot     28137 28124  0 00:00 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]# pstree -p 26811\nbash(26811)───bash(28110)───bash(28124)───pstree(28150)\n[root@aliyun-hk1 ~]#\n```\n\n让子shell在后台运行，语法为shell command &\n```\n[root@aliyun-hk1 ~]# sleep 10000 &\n[1] 28458\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     26811 26808  0 Mar06 pts/1    00:00:00 -bash\nroot     28110 26811  0 00:00 pts/1    00:00:00 bash\nroot     28124 28110  0 00:00 pts/1    00:00:00 bash\nroot     28458 28124  0 00:06 pts/1    00:00:00 sleep 10000\nroot     28462 28124  0 00:07 pts/1    00:00:00 ps -f\n[root@aliyun-hk1 ~]#\n```\n\n除了使用ps外，还可以使用jobs命令查看后台的作业信息。\n```\n[root@aliyun-hk1 ~]# jobs -l\n[1]+ 28458 Running                 sleep 10000 &\n[root@aliyun-hk1 ~]#\n```\n\n说到了进程，我们再大概说说线程、​协程。其实跟CPU通信的最小单位是线程，而不是进程​。每个进程使用独立的资源，而同一个进程内部的线程共享资源，同一个线程内的协程​共享资源。以下示例，29006、29011、31826、31827、31926是几个独立的进程，每个进程内都有若干个线程。这几个概念的水其实很深，今天就​先初步讲一讲。\n```\n[root@aliyun-hk1 ~]# pstree -p 29006\ndockerd-current(29006)─┬─docker-containe(29011)─┬─docker-containe(31826)─┬─nginx(31872)───nginx(31926)\n                       │                        │                        ├─{docker-containe}(31831)\n                       │                        │                        ├─{docker-containe}(31832)\n                       │                        │                        ├─{docker-containe}(31833)\n                       │                        │                        ├─{docker-containe}(31834)\n                       │                        │                        ├─{docker-containe}(31835)\n                       │                        │                        ├─{docker-containe}(31836)\n                       │                        │                        ├─{docker-containe}(31842)\n                       │                        │                        └─{docker-containe}(31844)\n                       │                        ├─{docker-containe}(29012)\n                       │                        ├─{docker-containe}(29013)\n                       │                        ├─{docker-containe}(29014)\n                       │                        ├─{docker-containe}(29016)\n                       │                        ├─{docker-containe}(29017)\n                       │                        ├─{docker-containe}(29018)\n                       │                        ├─{docker-containe}(29023)\n                       │                        ├─{docker-containe}(29741)\n                       │                        └─{docker-containe}(29742)\n                       ├─docker-proxy-cu(31808)─┬─{docker-proxy-cu}(31809)\n                       │                        ├─{docker-proxy-cu}(31810)\n                       │                        ├─{docker-proxy-cu}(31811)\n                       │                        └─{docker-proxy-cu}(31812)\n                       ├─{dockerd-current}(29007)\n                       ├─{dockerd-current}(29008)\n                       ├─{dockerd-current}(29009)\n                       ├─{dockerd-current}(29010)\n                       ├─{dockerd-current}(29015)\n                       ├─{dockerd-current}(29020)\n                       ├─{dockerd-current}(29022)\n                       ├─{dockerd-current}(29024)\n                       ├─{dockerd-current}(29628)\n                       └─{dockerd-current}(29629)\n[root@aliyun-hk1 ~]#\n```\n\nshell的内建命令和外部命令，内建命令不会创建子shell和子进程，外部命令​运行时会创建子shell和子进程。例如ps就是一个外部命令，​pwd就是一个内部命令。当外部命令执行时，会创建一个子进程，这种操作也被称为衍生（forking）​。\n```\n[root@aliyun-hk1 ~]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     28932 28930  0 00:16 pts/2    00:00:00 -bash\nroot     28973 28932  0 00:16 pts/2    00:00:00 ps -f\n[root@aliyun-hk1 ~]# cd /\n[root@aliyun-hk1 /]# pwd\n/\n[root@aliyun-hk1 /]# ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot     28932 28930  0 00:16 pts/2    00:00:00 -bash\nroot     28989 28932  0 00:17 pts/2    00:00:00 ps -f\n```\n\nhistory可以查看执行过的命令，仅限当前用户执行过的命令，无法跨用户查看history。​\n\n\n\n命令别名查看，使用alias，这个东西其实很重要，可以让好多​操作简化。\n```\n[root@aliyun-hk1 /]# alias -p                                                       \nalias cp='cp -i'                                                                    \nalias egrep='egrep --color=auto'                                                    \nalias fgrep='fgrep --color=auto'                                                    \nalias grep='grep --color=auto'                                                      \nalias l.='ls -d .* --color=auto'                                                    \nalias ll='ls -l --color=auto'                                                       \nalias ls='ls --color=auto'                                                          \nalias mv='mv -i'                                                                    \nalias rm='rm -i'                                                                    \nalias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'\n[root@aliyun-hk1 /]#\n```","slug":"linux/linux_shel_under","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdet7003z0en7wbja79by","content":"<p><strong>Linux shell</strong>是一个操作系统提供的、时刻都在运行的复杂交互式程序。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上进程的途径。对于linux OS 运维或linux shell编程而言，理解shell的概念​是重要的一课。</p>\n<a id=\"more\"></a>\n<p>当我们使用ssh客户端工具，通过密钥认证或者密码认证，登陆成功后，操作系统就为我们创建了一个shell进程​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ ssh root@lhh.pub</span><br><span class=\"line\">Last login: Fri Mar  6 20:59:55 2020 from 222.90.142.131</span><br><span class=\"line\">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class=\"line\">Last login: Fri Mar  6 20:59:55 2020 from 222.90.142.131</span><br><span class=\"line\">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 23:35 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     26829 26811  0 23:35 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# date</span><br><span class=\"line\">Fri Mar  6 23:35:17 CST 2020</span><br></pre></td></tr></table></figure></p>\n<p>所有Linux发行版本的默认shell都是bash shell，因为它的功能最强大，除此之外还有korn shell、ash shell、C shell等等。当前用户自动打开什么shell，决定于用户的shell配置。一般root用户默认会使用bash shell,查看所有用户的shell可以这样玩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# cat /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure></p>\n<p>bash shell程序位于/bin目录，可以发现它是个可执行程序。我们可能还听说过sh shell，它竟然是​一个指向bash的软连接，最起码在我们使用的CentOS是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ls -alt /bin/bash</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 964544 Apr 11  2018 /bin/bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ls -alt /bin/sh</span><br><span class=\"line\">lrwxrwxrwx. 1 root root 4 Nov 29  2018 /bin/sh -&gt; bash</span><br></pre></td></tr></table></figure></p>\n<p>shell的父子关系，我们使用ssh客户端登陆成功后，启动的默认交互shell，是一个父shell，后续​创建的shell都是子shell。请看父shell的进程ID是26811，后面进程的父进程PPID都是上一级的​进程PID。进程就是正在运行的一个程序。bash shell 是一个程序，当它运行的时候，​就会成为一个进程。所以我们经常​看到shell和进程的概念交叉使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28107 26811  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28122 28110  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28124 28110  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28137 28124  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# pstree -p 26811</span><br><span class=\"line\">bash(26811)───bash(28110)───bash(28124)───pstree(28150)</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>让子shell在后台运行，语法为shell command &amp;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# sleep 10000 &amp;</span><br><span class=\"line\">[1] 28458</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28124 28110  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28458 28124  0 00:06 pts/1    00:00:00 sleep 10000</span><br><span class=\"line\">root     28462 28124  0 00:07 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>除了使用ps外，还可以使用jobs命令查看后台的作业信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs -l</span><br><span class=\"line\">[1]+ 28458 Running                 sleep 10000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>说到了进程，我们再大概说说线程、​协程。其实跟CPU通信的最小单位是线程，而不是进程​。每个进程使用独立的资源，而同一个进程内部的线程共享资源，同一个线程内的协程​共享资源。以下示例，29006、29011、31826、31827、31926是几个独立的进程，每个进程内都有若干个线程。这几个概念的水其实很深，今天就​先初步讲一讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# pstree -p 29006</span><br><span class=\"line\">dockerd-current(29006)─┬─docker-containe(29011)─┬─docker-containe(31826)─┬─nginx(31872)───nginx(31926)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31831)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31832)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31833)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31834)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31835)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31836)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31842)</span><br><span class=\"line\">                       │                        │                        └─&#123;docker-containe&#125;(31844)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29012)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29013)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29014)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29016)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29017)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29018)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29023)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29741)</span><br><span class=\"line\">                       │                        └─&#123;docker-containe&#125;(29742)</span><br><span class=\"line\">                       ├─docker-proxy-cu(31808)─┬─&#123;docker-proxy-cu&#125;(31809)</span><br><span class=\"line\">                       │                        ├─&#123;docker-proxy-cu&#125;(31810)</span><br><span class=\"line\">                       │                        ├─&#123;docker-proxy-cu&#125;(31811)</span><br><span class=\"line\">                       │                        └─&#123;docker-proxy-cu&#125;(31812)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29007)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29008)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29009)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29010)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29015)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29020)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29022)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29024)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29628)</span><br><span class=\"line\">                       └─&#123;dockerd-current&#125;(29629)</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>shell的内建命令和外部命令，内建命令不会创建子shell和子进程，外部命令​运行时会创建子shell和子进程。例如ps就是一个外部命令，​pwd就是一个内部命令。当外部命令执行时，会创建一个子进程，这种操作也被称为衍生（forking）​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     28932 28930  0 00:16 pts/2    00:00:00 -bash</span><br><span class=\"line\">root     28973 28932  0 00:16 pts/2    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# cd /</span><br><span class=\"line\">[root@aliyun-hk1 /]# pwd</span><br><span class=\"line\">/</span><br><span class=\"line\">[root@aliyun-hk1 /]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     28932 28930  0 00:16 pts/2    00:00:00 -bash</span><br><span class=\"line\">root     28989 28932  0 00:17 pts/2    00:00:00 ps -f</span><br></pre></td></tr></table></figure></p>\n<p>history可以查看执行过的命令，仅限当前用户执行过的命令，无法跨用户查看history。​</p>\n<p>命令别名查看，使用alias，这个东西其实很重要，可以让好多​操作简化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 /]# alias -p                                                       </span><br><span class=\"line\">alias cp=&apos;cp -i&apos;                                                                    </span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;                                                    </span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;                                                    </span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;                                                      </span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;                                                    </span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;                                                       </span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;                                                          </span><br><span class=\"line\">alias mv=&apos;mv -i&apos;                                                                    </span><br><span class=\"line\">alias rm=&apos;rm -i&apos;                                                                    </span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br><span class=\"line\">[root@aliyun-hk1 /]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><strong>Linux shell</strong>是一个操作系统提供的、时刻都在运行的复杂交互式程序。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上进程的途径。对于linux OS 运维或linux shell编程而言，理解shell的概念​是重要的一课。</p>","more":"<p>当我们使用ssh客户端工具，通过密钥认证或者密码认证，登陆成功后，操作系统就为我们创建了一个shell进程​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">λ ssh root@lhh.pub</span><br><span class=\"line\">Last login: Fri Mar  6 20:59:55 2020 from 222.90.142.131</span><br><span class=\"line\">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class=\"line\">Last login: Fri Mar  6 20:59:55 2020 from 222.90.142.131</span><br><span class=\"line\">Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 23:35 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     26829 26811  0 23:35 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# date</span><br><span class=\"line\">Fri Mar  6 23:35:17 CST 2020</span><br></pre></td></tr></table></figure></p>\n<p>所有Linux发行版本的默认shell都是bash shell，因为它的功能最强大，除此之外还有korn shell、ash shell、C shell等等。当前用户自动打开什么shell，决定于用户的shell配置。一般root用户默认会使用bash shell,查看所有用户的shell可以这样玩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# cat /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class=\"line\">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class=\"line\">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class=\"line\">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br></pre></td></tr></table></figure></p>\n<p>bash shell程序位于/bin目录，可以发现它是个可执行程序。我们可能还听说过sh shell，它竟然是​一个指向bash的软连接，最起码在我们使用的CentOS是这样的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ls -alt /bin/bash</span><br><span class=\"line\">-rwxr-xr-x. 1 root root 964544 Apr 11  2018 /bin/bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ls -alt /bin/sh</span><br><span class=\"line\">lrwxrwxrwx. 1 root root 4 Nov 29  2018 /bin/sh -&gt; bash</span><br></pre></td></tr></table></figure></p>\n<p>shell的父子关系，我们使用ssh客户端登陆成功后，启动的默认交互shell，是一个父shell，后续​创建的shell都是子shell。请看父shell的进程ID是26811，后面进程的父进程PPID都是上一级的​进程PID。进程就是正在运行的一个程序。bash shell 是一个程序，当它运行的时候，​就会成为一个进程。所以我们经常​看到shell和进程的概念交叉使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28107 26811  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28122 28110  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28124 28110  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28137 28124  0 00:00 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# pstree -p 26811</span><br><span class=\"line\">bash(26811)───bash(28110)───bash(28124)───pstree(28150)</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>让子shell在后台运行，语法为shell command &amp;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# sleep 10000 &amp;</span><br><span class=\"line\">[1] 28458</span><br><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     26811 26808  0 Mar06 pts/1    00:00:00 -bash</span><br><span class=\"line\">root     28110 26811  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28124 28110  0 00:00 pts/1    00:00:00 bash</span><br><span class=\"line\">root     28458 28124  0 00:06 pts/1    00:00:00 sleep 10000</span><br><span class=\"line\">root     28462 28124  0 00:07 pts/1    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>除了使用ps外，还可以使用jobs命令查看后台的作业信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# jobs -l</span><br><span class=\"line\">[1]+ 28458 Running                 sleep 10000 &amp;</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>说到了进程，我们再大概说说线程、​协程。其实跟CPU通信的最小单位是线程，而不是进程​。每个进程使用独立的资源，而同一个进程内部的线程共享资源，同一个线程内的协程​共享资源。以下示例，29006、29011、31826、31827、31926是几个独立的进程，每个进程内都有若干个线程。这几个概念的水其实很深，今天就​先初步讲一讲。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# pstree -p 29006</span><br><span class=\"line\">dockerd-current(29006)─┬─docker-containe(29011)─┬─docker-containe(31826)─┬─nginx(31872)───nginx(31926)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31831)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31832)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31833)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31834)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31835)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31836)</span><br><span class=\"line\">                       │                        │                        ├─&#123;docker-containe&#125;(31842)</span><br><span class=\"line\">                       │                        │                        └─&#123;docker-containe&#125;(31844)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29012)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29013)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29014)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29016)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29017)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29018)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29023)</span><br><span class=\"line\">                       │                        ├─&#123;docker-containe&#125;(29741)</span><br><span class=\"line\">                       │                        └─&#123;docker-containe&#125;(29742)</span><br><span class=\"line\">                       ├─docker-proxy-cu(31808)─┬─&#123;docker-proxy-cu&#125;(31809)</span><br><span class=\"line\">                       │                        ├─&#123;docker-proxy-cu&#125;(31810)</span><br><span class=\"line\">                       │                        ├─&#123;docker-proxy-cu&#125;(31811)</span><br><span class=\"line\">                       │                        └─&#123;docker-proxy-cu&#125;(31812)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29007)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29008)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29009)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29010)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29015)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29020)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29022)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29024)</span><br><span class=\"line\">                       ├─&#123;dockerd-current&#125;(29628)</span><br><span class=\"line\">                       └─&#123;dockerd-current&#125;(29629)</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<p>shell的内建命令和外部命令，内建命令不会创建子shell和子进程，外部命令​运行时会创建子shell和子进程。例如ps就是一个外部命令，​pwd就是一个内部命令。当外部命令执行时，会创建一个子进程，这种操作也被称为衍生（forking）​。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     28932 28930  0 00:16 pts/2    00:00:00 -bash</span><br><span class=\"line\">root     28973 28932  0 00:16 pts/2    00:00:00 ps -f</span><br><span class=\"line\">[root@aliyun-hk1 ~]# cd /</span><br><span class=\"line\">[root@aliyun-hk1 /]# pwd</span><br><span class=\"line\">/</span><br><span class=\"line\">[root@aliyun-hk1 /]# ps -f</span><br><span class=\"line\">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class=\"line\">root     28932 28930  0 00:16 pts/2    00:00:00 -bash</span><br><span class=\"line\">root     28989 28932  0 00:17 pts/2    00:00:00 ps -f</span><br></pre></td></tr></table></figure></p>\n<p>history可以查看执行过的命令，仅限当前用户执行过的命令，无法跨用户查看history。​</p>\n<p>命令别名查看，使用alias，这个东西其实很重要，可以让好多​操作简化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 /]# alias -p                                                       </span><br><span class=\"line\">alias cp=&apos;cp -i&apos;                                                                    </span><br><span class=\"line\">alias egrep=&apos;egrep --color=auto&apos;                                                    </span><br><span class=\"line\">alias fgrep=&apos;fgrep --color=auto&apos;                                                    </span><br><span class=\"line\">alias grep=&apos;grep --color=auto&apos;                                                      </span><br><span class=\"line\">alias l.=&apos;ls -d .* --color=auto&apos;                                                    </span><br><span class=\"line\">alias ll=&apos;ls -l --color=auto&apos;                                                       </span><br><span class=\"line\">alias ls=&apos;ls --color=auto&apos;                                                          </span><br><span class=\"line\">alias mv=&apos;mv -i&apos;                                                                    </span><br><span class=\"line\">alias rm=&apos;rm -i&apos;                                                                    </span><br><span class=\"line\">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br><span class=\"line\">[root@aliyun-hk1 /]#</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之shell条件判断","date":"2020-03-16T21:57:37.000Z","_content":"\n之前讲过了linux之shell变量，光有变量还不够，对于任何脚本语言或者编程语言来说，变量、条件判断、循环等是必不可少的，shell编程也不例外。今天我就先来讲讲shell条件判断语句。\n<!--more-->\n\n#### 条件判断if-else语句\n许多时候，我们的脚本并不是简单的一路执行下去，而需要做各种条件判断。我们学过C语言或者java中的条件判断，其实shell脚本条件判断跟他们类似。例如c语言，if后面紧跟一个表达式，这个表达式的计算结果如果为True，则执行后面的语句，如果表达式结算结果为False，则不执行后面的语句。**shell的if语句有点不一样，它根据if后面命令执行后的退出状态码判断，如果退出状态码为0，执行then后面的语句，否则不执行then后面的语句。**我们在讲“Linux之shell输入输出重定向”的时候，已经讲个各种退出返回码的含义。\n```\npwd可以成功执行，退出码为0，所以then后面的命令执行了。\n[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh\n#!/bin/bash\n\nif pwd\nthen\n   echo \"hello world\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh\n/apps/linux-shell-test\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n\npwd后面的icantrun执行报错，退出返回码不为0，所以then后面的命令不执行\n[root@aliyun-hk1 linux-shell-test]# cat ifelse2.sh\n#!/bin/bash\n\nif icantrun\nthen\n   echo \"hello world\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse2.sh\n./ifelse2.sh: line 3: icantrun: command not found\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n#### 条件判断if-then-else语句\nif-then语句类似于c语言中的if语句，则if-then-else相当于c语言中的if-else语句。if-then-else语句中，如果if语句后面的命令退出返回码为0，then后面的命令会执行，这跟普通的if-then一样；如果if语句后面的命令退出返回码不为0，then语句后面的命令不执行，但是执行else后面的语句。\n```\n在用户配置文件中找不到lily，退出返回码不为0\n[root@aliyun-hk1 linux-shell-test]# cat if-then-else.sh\n#!/bin/bash\n\nif cat /etc/passwd|grep lily\nthen\n   echo \"lily can found\"\nelse\n   echo \"lily can't found\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./if-then-else.sh\nlily can't found\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 条件判断if-then-elif-then语句\n这个其实就是我们常说的if嵌套语句的简化写法，如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh\n#/bin/bash\n\nif iamnotcommand\nthen\n  echo \"first command return 0\"\nelif pwd\nthen\n  echo \"second command return 0\"\nfi\n[root@aliyun-hk1 linux-shell-test]# chmod 755 ifthenelifthen.sh\n[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh\n./ifthenelifthen.sh: line 3: iamnotcommand: command not found\n/apps/linux-shell-test\nsecond command return 0\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 条件判断if-then-elif-then-多重嵌套语句\n如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句，以此类推,只要第一次遇到命令退出返回码为0，执行相邻的then后，后面的命令都不执行了。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh\n#/bin/bash\n\nif iamnotcommand\nthen\n  echo \"first command return 0\"\nelif 1pwd\nthen\n  echo \"second command return 0\"\nelif 2pwd\nthen\n  echo \"3st command retrun 0\"\nelif pwd\nthen\n  echo \"4st command return 0\"\nelif pwd\nthen\n  echo \"5st command return 0\"\nfi\n\n[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh\n./ifthenelifthen.sh: line 3: iamnotcommand: command not found\n./ifthenelifthen.sh: line 6: 1pwd: command not found\n./ifthenelifthen.sh: line 9: 2pwd: command not found\n/apps/linux-shell-test\n4st command return 0\n[root@aliyun-hk1 linux-shell-test]#\n```\n**注意then后面你可以使用不止一条命令，可以像在其他编程语言中一样，列出多条命令。**\n\n#### 使用test判断一个条件是否成立\n我们能不能像其他编程语言一样，判断一个条件是否成立，成立的话执行一个语句，不成立的话执行另外语句？答案是肯定的。我们可以使用if语句结合test命令来实现。test command，如果这个commad成立，则这条test语句返回0，否则返回非0。test命令可以用来做数值比较、字符串比较、文件比较。\n```\n[root@aliyun-hk1 linux-shell-test]# cat iftestthen.sh\n这里就通过test判断两个变量的值是否相等。\n#!/bin/bash\n\nname1=robin\nname2=robin\n\nif test $name1 = $name2\nthen\n   echo \"name1 same as name2\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./iftestthen.sh\nname1 same as name2\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 使用[]判断一个条件是否成立\n如果[]内的条件成立，则退出返回码为0，执行then后面的命令。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh\n#!/bin/bash\nage=18\nif [ $age -gt 18 ]\nthen\n   echo \"age is more than 18\"\nelif [ $age -eq 18 ]\nthen\n   echo \"age is 18\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh\nage is 18\n[root@aliyun-hk1 linux-shell-test]#\n```\n**这里有人提出疑问了，定义一个整形变量不是要使用declare -i吗? 为什么这里不使用了？ 经过测试发现，目前的shell版本已经可以不用申明变量类型了。当然你加了declare也不会报错。**\n\n#### 讲if-else放在一行执行\n```\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 = $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -eq $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ne $num2 ]; then echo \"num1 is same as num2\";fi;\nnum1 is same as num2\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -le $num2 ]; then echo \"num1 is same as num2\";fi;\nnum1 is same as num2\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ge $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -gt $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### test或[]数值比较用到的参数 \n```\na -eq b  a是否与b相等\na -ge b  a是否大于等于b\na -gt b  a是否大于b\na -le b  a是否小于等于b\na -lt b  a是否小于b\na -ne b  a是否不等于b\n```\n**在shell脚本中如果数值比较如果使用了字符串用的参数，它会进行强制类型转换，这里要注意。**\n\n\n#### test或[]字符串比较用到的参数\n```\nstr1 = str2  str1和str2是否相同\nstr1 != str2 str1和str2是否不同\nstr1 < str2  str1是否比str2小\nstr1 > str2  str1是否比str2大\n-n str1      str1长度是否非0\n-z str1      str1长度是否为0\n```\n**在shell脚本中使用的时候一定要记得给<或<转义，字符串不可以使用数值专用的参数，否则会报错。**\n\n\n#### test或[]文件比较用到的参数\n```\n-d file 检查file是否存在并且式一个目录\n-e file 检查file是否存在\n-f file 检查file是否存在并且式一个文件\n-r file 检查file是否存在并可读\n-s file 检查file是否存在并非空\n-w file 检查file是否存在并且可写\n-x file 检查file是否存在并可执行\n-O file 检查file是否存在并属于当前用户\n-G file 检查file是否存在并且默认组与当前用户相同\nfile1 -nt file2 检查file1是否比file2新\nfile1 -ot file2 检查file1是否比file2旧\n```\n\n#### shell编程if语句的高级用法\n例如if (( $var1 ** > 90 )) 双括号允许你使用高级的数学表达式。\n例如if [[ $USER == r* ]] 双方括号允许你使用高级的字符串表达式。\n**shell 脚本语言对符号的使用很多，这一点让用习惯了python、java、c的同学有点不习惯。所以，我们先挑选熟悉常用的，高级复杂的需要了再学。**\n\n\n#### 下次一我们将会讲解shell for循环的使用。\n敬请期待。","source":"_posts/linux/linux_shell_condition.md","raw":"---\ntitle: Linux之shell条件判断\ndate: 2020-03-16 21:57:37\ntags: shell\ncategories: linux\n---\n\n之前讲过了linux之shell变量，光有变量还不够，对于任何脚本语言或者编程语言来说，变量、条件判断、循环等是必不可少的，shell编程也不例外。今天我就先来讲讲shell条件判断语句。\n<!--more-->\n\n#### 条件判断if-else语句\n许多时候，我们的脚本并不是简单的一路执行下去，而需要做各种条件判断。我们学过C语言或者java中的条件判断，其实shell脚本条件判断跟他们类似。例如c语言，if后面紧跟一个表达式，这个表达式的计算结果如果为True，则执行后面的语句，如果表达式结算结果为False，则不执行后面的语句。**shell的if语句有点不一样，它根据if后面命令执行后的退出状态码判断，如果退出状态码为0，执行then后面的语句，否则不执行then后面的语句。**我们在讲“Linux之shell输入输出重定向”的时候，已经讲个各种退出返回码的含义。\n```\npwd可以成功执行，退出码为0，所以then后面的命令执行了。\n[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh\n#!/bin/bash\n\nif pwd\nthen\n   echo \"hello world\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh\n/apps/linux-shell-test\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n\npwd后面的icantrun执行报错，退出返回码不为0，所以then后面的命令不执行\n[root@aliyun-hk1 linux-shell-test]# cat ifelse2.sh\n#!/bin/bash\n\nif icantrun\nthen\n   echo \"hello world\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse2.sh\n./ifelse2.sh: line 3: icantrun: command not found\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n#### 条件判断if-then-else语句\nif-then语句类似于c语言中的if语句，则if-then-else相当于c语言中的if-else语句。if-then-else语句中，如果if语句后面的命令退出返回码为0，then后面的命令会执行，这跟普通的if-then一样；如果if语句后面的命令退出返回码不为0，then语句后面的命令不执行，但是执行else后面的语句。\n```\n在用户配置文件中找不到lily，退出返回码不为0\n[root@aliyun-hk1 linux-shell-test]# cat if-then-else.sh\n#!/bin/bash\n\nif cat /etc/passwd|grep lily\nthen\n   echo \"lily can found\"\nelse\n   echo \"lily can't found\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./if-then-else.sh\nlily can't found\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 条件判断if-then-elif-then语句\n这个其实就是我们常说的if嵌套语句的简化写法，如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh\n#/bin/bash\n\nif iamnotcommand\nthen\n  echo \"first command return 0\"\nelif pwd\nthen\n  echo \"second command return 0\"\nfi\n[root@aliyun-hk1 linux-shell-test]# chmod 755 ifthenelifthen.sh\n[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh\n./ifthenelifthen.sh: line 3: iamnotcommand: command not found\n/apps/linux-shell-test\nsecond command return 0\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 条件判断if-then-elif-then-多重嵌套语句\n如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句，以此类推,只要第一次遇到命令退出返回码为0，执行相邻的then后，后面的命令都不执行了。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh\n#/bin/bash\n\nif iamnotcommand\nthen\n  echo \"first command return 0\"\nelif 1pwd\nthen\n  echo \"second command return 0\"\nelif 2pwd\nthen\n  echo \"3st command retrun 0\"\nelif pwd\nthen\n  echo \"4st command return 0\"\nelif pwd\nthen\n  echo \"5st command return 0\"\nfi\n\n[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh\n./ifthenelifthen.sh: line 3: iamnotcommand: command not found\n./ifthenelifthen.sh: line 6: 1pwd: command not found\n./ifthenelifthen.sh: line 9: 2pwd: command not found\n/apps/linux-shell-test\n4st command return 0\n[root@aliyun-hk1 linux-shell-test]#\n```\n**注意then后面你可以使用不止一条命令，可以像在其他编程语言中一样，列出多条命令。**\n\n#### 使用test判断一个条件是否成立\n我们能不能像其他编程语言一样，判断一个条件是否成立，成立的话执行一个语句，不成立的话执行另外语句？答案是肯定的。我们可以使用if语句结合test命令来实现。test command，如果这个commad成立，则这条test语句返回0，否则返回非0。test命令可以用来做数值比较、字符串比较、文件比较。\n```\n[root@aliyun-hk1 linux-shell-test]# cat iftestthen.sh\n这里就通过test判断两个变量的值是否相等。\n#!/bin/bash\n\nname1=robin\nname2=robin\n\nif test $name1 = $name2\nthen\n   echo \"name1 same as name2\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./iftestthen.sh\nname1 same as name2\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 使用[]判断一个条件是否成立\n如果[]内的条件成立，则退出返回码为0，执行then后面的命令。\n```\n[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh\n#!/bin/bash\nage=18\nif [ $age -gt 18 ]\nthen\n   echo \"age is more than 18\"\nelif [ $age -eq 18 ]\nthen\n   echo \"age is 18\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh\nage is 18\n[root@aliyun-hk1 linux-shell-test]#\n```\n**这里有人提出疑问了，定义一个整形变量不是要使用declare -i吗? 为什么这里不使用了？ 经过测试发现，目前的shell版本已经可以不用申明变量类型了。当然你加了declare也不会报错。**\n\n#### 讲if-else放在一行执行\n```\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 = $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -eq $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ne $num2 ]; then echo \"num1 is same as num2\";fi;\nnum1 is same as num2\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -le $num2 ]; then echo \"num1 is same as num2\";fi;\nnum1 is same as num2\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ge $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -gt $num2 ]; then echo \"num1 is same as num2\";fi;\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### test或[]数值比较用到的参数 \n```\na -eq b  a是否与b相等\na -ge b  a是否大于等于b\na -gt b  a是否大于b\na -le b  a是否小于等于b\na -lt b  a是否小于b\na -ne b  a是否不等于b\n```\n**在shell脚本中如果数值比较如果使用了字符串用的参数，它会进行强制类型转换，这里要注意。**\n\n\n#### test或[]字符串比较用到的参数\n```\nstr1 = str2  str1和str2是否相同\nstr1 != str2 str1和str2是否不同\nstr1 < str2  str1是否比str2小\nstr1 > str2  str1是否比str2大\n-n str1      str1长度是否非0\n-z str1      str1长度是否为0\n```\n**在shell脚本中使用的时候一定要记得给<或<转义，字符串不可以使用数值专用的参数，否则会报错。**\n\n\n#### test或[]文件比较用到的参数\n```\n-d file 检查file是否存在并且式一个目录\n-e file 检查file是否存在\n-f file 检查file是否存在并且式一个文件\n-r file 检查file是否存在并可读\n-s file 检查file是否存在并非空\n-w file 检查file是否存在并且可写\n-x file 检查file是否存在并可执行\n-O file 检查file是否存在并属于当前用户\n-G file 检查file是否存在并且默认组与当前用户相同\nfile1 -nt file2 检查file1是否比file2新\nfile1 -ot file2 检查file1是否比file2旧\n```\n\n#### shell编程if语句的高级用法\n例如if (( $var1 ** > 90 )) 双括号允许你使用高级的数学表达式。\n例如if [[ $USER == r* ]] 双方括号允许你使用高级的字符串表达式。\n**shell 脚本语言对符号的使用很多，这一点让用习惯了python、java、c的同学有点不习惯。所以，我们先挑选熟悉常用的，高级复杂的需要了再学。**\n\n\n#### 下次一我们将会讲解shell for循环的使用。\n敬请期待。","slug":"linux/linux_shell_condition","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdet900420en7k7owc6pu","content":"<p>之前讲过了linux之shell变量，光有变量还不够，对于任何脚本语言或者编程语言来说，变量、条件判断、循环等是必不可少的，shell编程也不例外。今天我就先来讲讲shell条件判断语句。<br><a id=\"more\"></a></p>\n<h4 id=\"条件判断if-else语句\"><a href=\"#条件判断if-else语句\" class=\"headerlink\" title=\"条件判断if-else语句\"></a>条件判断if-else语句</h4><p>许多时候，我们的脚本并不是简单的一路执行下去，而需要做各种条件判断。我们学过C语言或者java中的条件判断，其实shell脚本条件判断跟他们类似。例如c语言，if后面紧跟一个表达式，这个表达式的计算结果如果为True，则执行后面的语句，如果表达式结算结果为False，则不执行后面的语句。<strong>shell的if语句有点不一样，它根据if后面命令执行后的退出状态码判断，如果退出状态码为0，执行then后面的语句，否则不执行then后面的语句。</strong>我们在讲“Linux之shell输入输出重定向”的时候，已经讲个各种退出返回码的含义。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd可以成功执行，退出码为0，所以then后面的命令执行了。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello world&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">pwd后面的icantrun执行报错，退出返回码不为0，所以then后面的命令不执行</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse2.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if icantrun</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello world&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse2.sh</span><br><span class=\"line\">./ifelse2.sh: line 3: icantrun: command not found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-else语句\"><a href=\"#条件判断if-then-else语句\" class=\"headerlink\" title=\"条件判断if-then-else语句\"></a>条件判断if-then-else语句</h4><p>if-then语句类似于c语言中的if语句，则if-then-else相当于c语言中的if-else语句。if-then-else语句中，如果if语句后面的命令退出返回码为0，then后面的命令会执行，这跟普通的if-then一样；如果if语句后面的命令退出返回码不为0，then语句后面的命令不执行，但是执行else后面的语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在用户配置文件中找不到lily，退出返回码不为0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat if-then-else.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if cat /etc/passwd|grep lily</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;lily can found&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo &quot;lily can&apos;t found&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./if-then-else.sh</span><br><span class=\"line\">lily can&apos;t found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-elif-then语句\"><a href=\"#条件判断if-then-elif-then语句\" class=\"headerlink\" title=\"条件判断if-then-elif-then语句\"></a>条件判断if-then-elif-then语句</h4><p>这个其实就是我们常说的if嵌套语句的简化写法，如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh</span><br><span class=\"line\">#/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if iamnotcommand</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;first command return 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;second command return 0&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 ifthenelifthen.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh</span><br><span class=\"line\">./ifthenelifthen.sh: line 3: iamnotcommand: command not found</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">second command return 0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-elif-then-多重嵌套语句\"><a href=\"#条件判断if-then-elif-then-多重嵌套语句\" class=\"headerlink\" title=\"条件判断if-then-elif-then-多重嵌套语句\"></a>条件判断if-then-elif-then-多重嵌套语句</h4><p>如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句，以此类推,只要第一次遇到命令退出返回码为0，执行相邻的then后，后面的命令都不执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh</span><br><span class=\"line\">#/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if iamnotcommand</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;first command return 0&quot;</span><br><span class=\"line\">elif 1pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;second command return 0&quot;</span><br><span class=\"line\">elif 2pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;3st command retrun 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;4st command return 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;5st command return 0&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh</span><br><span class=\"line\">./ifthenelifthen.sh: line 3: iamnotcommand: command not found</span><br><span class=\"line\">./ifthenelifthen.sh: line 6: 1pwd: command not found</span><br><span class=\"line\">./ifthenelifthen.sh: line 9: 2pwd: command not found</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">4st command return 0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意then后面你可以使用不止一条命令，可以像在其他编程语言中一样，列出多条命令。</strong></p>\n<h4 id=\"使用test判断一个条件是否成立\"><a href=\"#使用test判断一个条件是否成立\" class=\"headerlink\" title=\"使用test判断一个条件是否成立\"></a>使用test判断一个条件是否成立</h4><p>我们能不能像其他编程语言一样，判断一个条件是否成立，成立的话执行一个语句，不成立的话执行另外语句？答案是肯定的。我们可以使用if语句结合test命令来实现。test command，如果这个commad成立，则这条test语句返回0，否则返回非0。test命令可以用来做数值比较、字符串比较、文件比较。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat iftestthen.sh</span><br><span class=\"line\">这里就通过test判断两个变量的值是否相等。</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">name1=robin</span><br><span class=\"line\">name2=robin</span><br><span class=\"line\"></span><br><span class=\"line\">if test $name1 = $name2</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;name1 same as name2&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./iftestthen.sh</span><br><span class=\"line\">name1 same as name2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-判断一个条件是否成立\"><a href=\"#使用-判断一个条件是否成立\" class=\"headerlink\" title=\"使用[]判断一个条件是否成立\"></a>使用[]判断一个条件是否成立</h4><p>如果[]内的条件成立，则退出返回码为0，执行then后面的命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">age=18</span><br><span class=\"line\">if [ $age -gt 18 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;age is more than 18&quot;</span><br><span class=\"line\">elif [ $age -eq 18 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;age is 18&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh</span><br><span class=\"line\">age is 18</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里有人提出疑问了，定义一个整形变量不是要使用declare -i吗? 为什么这里不使用了？ 经过测试发现，目前的shell版本已经可以不用申明变量类型了。当然你加了declare也不会报错。</strong></p>\n<h4 id=\"讲if-else放在一行执行\"><a href=\"#讲if-else放在一行执行\" class=\"headerlink\" title=\"讲if-else放在一行执行\"></a>讲if-else放在一行执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 = $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -eq $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ne $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">num1 is same as num2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -le $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">num1 is same as num2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ge $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -gt $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"test或-数值比较用到的参数\"><a href=\"#test或-数值比较用到的参数\" class=\"headerlink\" title=\"test或[]数值比较用到的参数\"></a>test或[]数值比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a -eq b  a是否与b相等</span><br><span class=\"line\">a -ge b  a是否大于等于b</span><br><span class=\"line\">a -gt b  a是否大于b</span><br><span class=\"line\">a -le b  a是否小于等于b</span><br><span class=\"line\">a -lt b  a是否小于b</span><br><span class=\"line\">a -ne b  a是否不等于b</span><br></pre></td></tr></table></figure>\n<p><strong>在shell脚本中如果数值比较如果使用了字符串用的参数，它会进行强制类型转换，这里要注意。</strong></p>\n<h4 id=\"test或-字符串比较用到的参数\"><a href=\"#test或-字符串比较用到的参数\" class=\"headerlink\" title=\"test或[]字符串比较用到的参数\"></a>test或[]字符串比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = str2  str1和str2是否相同</span><br><span class=\"line\">str1 != str2 str1和str2是否不同</span><br><span class=\"line\">str1 &lt; str2  str1是否比str2小</span><br><span class=\"line\">str1 &gt; str2  str1是否比str2大</span><br><span class=\"line\">-n str1      str1长度是否非0</span><br><span class=\"line\">-z str1      str1长度是否为0</span><br></pre></td></tr></table></figure>\n<p><strong>在shell脚本中使用的时候一定要记得给&lt;或&lt;转义，字符串不可以使用数值专用的参数，否则会报错。</strong></p>\n<h4 id=\"test或-文件比较用到的参数\"><a href=\"#test或-文件比较用到的参数\" class=\"headerlink\" title=\"test或[]文件比较用到的参数\"></a>test或[]文件比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d file 检查file是否存在并且式一个目录</span><br><span class=\"line\">-e file 检查file是否存在</span><br><span class=\"line\">-f file 检查file是否存在并且式一个文件</span><br><span class=\"line\">-r file 检查file是否存在并可读</span><br><span class=\"line\">-s file 检查file是否存在并非空</span><br><span class=\"line\">-w file 检查file是否存在并且可写</span><br><span class=\"line\">-x file 检查file是否存在并可执行</span><br><span class=\"line\">-O file 检查file是否存在并属于当前用户</span><br><span class=\"line\">-G file 检查file是否存在并且默认组与当前用户相同</span><br><span class=\"line\">file1 -nt file2 检查file1是否比file2新</span><br><span class=\"line\">file1 -ot file2 检查file1是否比file2旧</span><br></pre></td></tr></table></figure>\n<h4 id=\"shell编程if语句的高级用法\"><a href=\"#shell编程if语句的高级用法\" class=\"headerlink\" title=\"shell编程if语句的高级用法\"></a>shell编程if语句的高级用法</h4><p>例如if (( $var1 <strong> &gt; 90 )) 双括号允许你使用高级的数学表达式。<br>例如if [[ $USER == r* ]] 双方括号允许你使用高级的字符串表达式。\n</strong>shell 脚本语言对符号的使用很多，这一点让用习惯了python、java、c的同学有点不习惯。所以，我们先挑选熟悉常用的，高级复杂的需要了再学。**</p>\n<h4 id=\"下次一我们将会讲解shell-for循环的使用。\"><a href=\"#下次一我们将会讲解shell-for循环的使用。\" class=\"headerlink\" title=\"下次一我们将会讲解shell for循环的使用。\"></a>下次一我们将会讲解shell for循环的使用。</h4><p>敬请期待。</p>\n","site":{"data":{}},"excerpt":"<p>之前讲过了linux之shell变量，光有变量还不够，对于任何脚本语言或者编程语言来说，变量、条件判断、循环等是必不可少的，shell编程也不例外。今天我就先来讲讲shell条件判断语句。<br>","more":"</p>\n<h4 id=\"条件判断if-else语句\"><a href=\"#条件判断if-else语句\" class=\"headerlink\" title=\"条件判断if-else语句\"></a>条件判断if-else语句</h4><p>许多时候，我们的脚本并不是简单的一路执行下去，而需要做各种条件判断。我们学过C语言或者java中的条件判断，其实shell脚本条件判断跟他们类似。例如c语言，if后面紧跟一个表达式，这个表达式的计算结果如果为True，则执行后面的语句，如果表达式结算结果为False，则不执行后面的语句。<strong>shell的if语句有点不一样，它根据if后面命令执行后的退出状态码判断，如果退出状态码为0，执行then后面的语句，否则不执行then后面的语句。</strong>我们在讲“Linux之shell输入输出重定向”的时候，已经讲个各种退出返回码的含义。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd可以成功执行，退出码为0，所以then后面的命令执行了。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello world&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">pwd后面的icantrun执行报错，退出返回码不为0，所以then后面的命令不执行</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse2.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if icantrun</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello world&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse2.sh</span><br><span class=\"line\">./ifelse2.sh: line 3: icantrun: command not found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-else语句\"><a href=\"#条件判断if-then-else语句\" class=\"headerlink\" title=\"条件判断if-then-else语句\"></a>条件判断if-then-else语句</h4><p>if-then语句类似于c语言中的if语句，则if-then-else相当于c语言中的if-else语句。if-then-else语句中，如果if语句后面的命令退出返回码为0，then后面的命令会执行，这跟普通的if-then一样；如果if语句后面的命令退出返回码不为0，then语句后面的命令不执行，但是执行else后面的语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在用户配置文件中找不到lily，退出返回码不为0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat if-then-else.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if cat /etc/passwd|grep lily</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;lily can found&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo &quot;lily can&apos;t found&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./if-then-else.sh</span><br><span class=\"line\">lily can&apos;t found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-elif-then语句\"><a href=\"#条件判断if-then-elif-then语句\" class=\"headerlink\" title=\"条件判断if-then-elif-then语句\"></a>条件判断if-then-elif-then语句</h4><p>这个其实就是我们常说的if嵌套语句的简化写法，如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh</span><br><span class=\"line\">#/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if iamnotcommand</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;first command return 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;second command return 0&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 ifthenelifthen.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh</span><br><span class=\"line\">./ifthenelifthen.sh: line 3: iamnotcommand: command not found</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">second command return 0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"条件判断if-then-elif-then-多重嵌套语句\"><a href=\"#条件判断if-then-elif-then-多重嵌套语句\" class=\"headerlink\" title=\"条件判断if-then-elif-then-多重嵌套语句\"></a>条件判断if-then-elif-then-多重嵌套语句</h4><p>如果if后面的命令退出返回码不为0，不执行相邻的then语句，再如果elif后面的命令退出返回码为0，则执相邻的then语句，以此类推,只要第一次遇到命令退出返回码为0，执行相邻的then后，后面的命令都不执行了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifthenelifthen.sh</span><br><span class=\"line\">#/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if iamnotcommand</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;first command return 0&quot;</span><br><span class=\"line\">elif 1pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;second command return 0&quot;</span><br><span class=\"line\">elif 2pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;3st command retrun 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;4st command return 0&quot;</span><br><span class=\"line\">elif pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo &quot;5st command return 0&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifthenelifthen.sh</span><br><span class=\"line\">./ifthenelifthen.sh: line 3: iamnotcommand: command not found</span><br><span class=\"line\">./ifthenelifthen.sh: line 6: 1pwd: command not found</span><br><span class=\"line\">./ifthenelifthen.sh: line 9: 2pwd: command not found</span><br><span class=\"line\">/apps/linux-shell-test</span><br><span class=\"line\">4st command return 0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意then后面你可以使用不止一条命令，可以像在其他编程语言中一样，列出多条命令。</strong></p>\n<h4 id=\"使用test判断一个条件是否成立\"><a href=\"#使用test判断一个条件是否成立\" class=\"headerlink\" title=\"使用test判断一个条件是否成立\"></a>使用test判断一个条件是否成立</h4><p>我们能不能像其他编程语言一样，判断一个条件是否成立，成立的话执行一个语句，不成立的话执行另外语句？答案是肯定的。我们可以使用if语句结合test命令来实现。test command，如果这个commad成立，则这条test语句返回0，否则返回非0。test命令可以用来做数值比较、字符串比较、文件比较。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat iftestthen.sh</span><br><span class=\"line\">这里就通过test判断两个变量的值是否相等。</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">name1=robin</span><br><span class=\"line\">name2=robin</span><br><span class=\"line\"></span><br><span class=\"line\">if test $name1 = $name2</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;name1 same as name2&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./iftestthen.sh</span><br><span class=\"line\">name1 same as name2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-判断一个条件是否成立\"><a href=\"#使用-判断一个条件是否成立\" class=\"headerlink\" title=\"使用[]判断一个条件是否成立\"></a>使用[]判断一个条件是否成立</h4><p>如果[]内的条件成立，则退出返回码为0，执行then后面的命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ifelse.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">age=18</span><br><span class=\"line\">if [ $age -gt 18 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;age is more than 18&quot;</span><br><span class=\"line\">elif [ $age -eq 18 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;age is 18&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./ifelse.sh</span><br><span class=\"line\">age is 18</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里有人提出疑问了，定义一个整形变量不是要使用declare -i吗? 为什么这里不使用了？ 经过测试发现，目前的shell版本已经可以不用申明变量类型了。当然你加了declare也不会报错。</strong></p>\n<h4 id=\"讲if-else放在一行执行\"><a href=\"#讲if-else放在一行执行\" class=\"headerlink\" title=\"讲if-else放在一行执行\"></a>讲if-else放在一行执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 = $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -eq $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ne $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">num1 is same as num2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -le $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">num1 is same as num2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -ge $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# num1=1; num2=2; if [ $num1 -gt $num2 ]; then echo &quot;num1 is same as num2&quot;;fi;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"test或-数值比较用到的参数\"><a href=\"#test或-数值比较用到的参数\" class=\"headerlink\" title=\"test或[]数值比较用到的参数\"></a>test或[]数值比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a -eq b  a是否与b相等</span><br><span class=\"line\">a -ge b  a是否大于等于b</span><br><span class=\"line\">a -gt b  a是否大于b</span><br><span class=\"line\">a -le b  a是否小于等于b</span><br><span class=\"line\">a -lt b  a是否小于b</span><br><span class=\"line\">a -ne b  a是否不等于b</span><br></pre></td></tr></table></figure>\n<p><strong>在shell脚本中如果数值比较如果使用了字符串用的参数，它会进行强制类型转换，这里要注意。</strong></p>\n<h4 id=\"test或-字符串比较用到的参数\"><a href=\"#test或-字符串比较用到的参数\" class=\"headerlink\" title=\"test或[]字符串比较用到的参数\"></a>test或[]字符串比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = str2  str1和str2是否相同</span><br><span class=\"line\">str1 != str2 str1和str2是否不同</span><br><span class=\"line\">str1 &lt; str2  str1是否比str2小</span><br><span class=\"line\">str1 &gt; str2  str1是否比str2大</span><br><span class=\"line\">-n str1      str1长度是否非0</span><br><span class=\"line\">-z str1      str1长度是否为0</span><br></pre></td></tr></table></figure>\n<p><strong>在shell脚本中使用的时候一定要记得给&lt;或&lt;转义，字符串不可以使用数值专用的参数，否则会报错。</strong></p>\n<h4 id=\"test或-文件比较用到的参数\"><a href=\"#test或-文件比较用到的参数\" class=\"headerlink\" title=\"test或[]文件比较用到的参数\"></a>test或[]文件比较用到的参数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d file 检查file是否存在并且式一个目录</span><br><span class=\"line\">-e file 检查file是否存在</span><br><span class=\"line\">-f file 检查file是否存在并且式一个文件</span><br><span class=\"line\">-r file 检查file是否存在并可读</span><br><span class=\"line\">-s file 检查file是否存在并非空</span><br><span class=\"line\">-w file 检查file是否存在并且可写</span><br><span class=\"line\">-x file 检查file是否存在并可执行</span><br><span class=\"line\">-O file 检查file是否存在并属于当前用户</span><br><span class=\"line\">-G file 检查file是否存在并且默认组与当前用户相同</span><br><span class=\"line\">file1 -nt file2 检查file1是否比file2新</span><br><span class=\"line\">file1 -ot file2 检查file1是否比file2旧</span><br></pre></td></tr></table></figure>\n<h4 id=\"shell编程if语句的高级用法\"><a href=\"#shell编程if语句的高级用法\" class=\"headerlink\" title=\"shell编程if语句的高级用法\"></a>shell编程if语句的高级用法</h4><p>例如if (( $var1 <strong> &gt; 90 )) 双括号允许你使用高级的数学表达式。<br>例如if [[ $USER == r* ]] 双方括号允许你使用高级的字符串表达式。\n</strong>shell 脚本语言对符号的使用很多，这一点让用习惯了python、java、c的同学有点不习惯。所以，我们先挑选熟悉常用的，高级复杂的需要了再学。**</p>\n<h4 id=\"下次一我们将会讲解shell-for循环的使用。\"><a href=\"#下次一我们将会讲解shell-for循环的使用。\" class=\"headerlink\" title=\"下次一我们将会讲解shell for循环的使用。\"></a>下次一我们将会讲解shell for循环的使用。</h4><p>敬请期待。</p>"},{"title":"Linux之shell循环","date":"2020-03-17T23:00:00.000Z","_content":"\n讲完了shell的变量和条件判断后，今天再来讲讲循环。就像c语言或者java一样，循环在所有的编程语言或脚本语言中必不可少，shell自然也是。\n<!--more-->\n\n#### 1.for循环\n假设你学过c语言后者java，循环的概念我就不废话了。for循环假设列表中的值都是用空格分开的，因此列表中的值如果有空格，用双引号包起来。\n##### 1.1 for 循环中list中都是常量\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nfor abc in hello world nihao zhongguo\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# chmod 755 for.sh\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is nihao\nthe next one is zhongguo\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.2 for 循环中list是一个字符串\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nlist1=\"ni hao hello world\"\nfor abc in $list1\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is ni\nthe next one is hao\nthe next one is hello\nthe next one is world\n```\n\n##### 1.3 for 循环中list是从文件读取的\n```\n[root@aliyun-hk1 linux-shell-test]# cat ./for.sh\n#!/bin/bash\n\nlist1=\"ni hao hello world\"\nfile=\"fortest.txt\"\nfor abc in $(cat $file)\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is ni\nthe next one is hao\nthe next one is I\nthe next one is am\nthe next one is robin\n```\n\n##### 1.4 for循环中使用非默认的分隔符\n因为有个特殊的环境变量IFS,它定义了bash shell用作字符分隔的一系列字符。默认的情况下，bash shell分隔符为分别为空格、制表符和换行符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nfile=\"fortest.txt\"\nIFS=$'\\n'\nfor abc in $(cat $file)\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is ni\nthe next one is hao\nthe next one is I\nthe next one is am\nthe next one is robin h h li\n[root@aliyun-hk1 linux-shell-test]#\n```\n** 在shell编程中一般为了后续继续使用默认分隔符，一般先临时备份默认分隔符，IFS.OLD=$IFS;IFS=$'\\n';IFS=$IFS.OLD 保证后续脚本能在默认和非默认分隔符之间快速切换。**\n\n##### 1.5 for循环使用c语言的分格\n```\n[root@aliyun-hk1 linux-shell-test]# cat forc.sh\n#!/bin/bash\n\nfor (( i=1; i<=9; i++ ))\ndo\n   echo the next one is $i\ndone\n[root@aliyun-hk1 linux-shell-test]# ./forc.sh\nthe next one is 1\nthe next one is 2\nthe next one is 3\nthe next one is 4\nthe next one is 5\nthe next one is 6\nthe next one is 7\nthe next one is 8\nthe next one is 9\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 2.while循环\nwhile循环其实是if-else和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0，这组命令就反复执行。while循环写不好，很容易造成死循环。\n##### 2.1 使用一个测试命令的while循环\n```\n一个测试命令是最常见的方式。\n[root@aliyun-hk1 linux-shell-test]# cat test-while.sh\n#!/bin/bash\nvar1=5\nwhile [ $var1 -gt 0 ]\ndo\n    echo $var1\n    var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# chmod 755 test-while.sh\n[root@aliyun-hk1 linux-shell-test]# ./test-while.sh\n5\n4\n3\n2\n1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 2.2 使用多个测试命令的while循环\n```\n多个测试命令的时候，只有最后一个测试命令退出码用来判单循环是否继续执行，前面的测试命令忽略。\n[root@aliyun-hk1 linux-shell-test]# cat test-while.sh\n#!/bin/bash\nvar1=5\nwhile echo $var1\n      [ $var1 -ge 0 ]\ndo\n    echo $var1\n    var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# ./test-while.sh\n5\n5\n4\n4\n3\n3\n2\n2\n1\n1\n0\n0\n-1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 3.until循环\nuntil循环其实碰巧跟while循环相反，只要测试命令的退出返回码非0，就一直执行后面的一组命令，直到退出返回码为0，循环才结束。\n```\n[root@aliyun-hk1 linux-shell-test]# cat test-until.sh\n#!/bin/bash\n\nvar1=5\nuntil [ $var1 -eq 0 ]\ndo\n   echo $var1\n   var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# ./test-until.sh\n5\n4\n3\n2\n1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 4.循环读取多行内容\n通过jenkins调用shell并执行ansible脚本的时候，经常需要传递参数到shell。常规的做法可以，把一组内容组装到一个变量中，并且使用换行符作为分隔符，然后传给shell之后，再进行拆分并使用。\n```\n[root@aliyun-hk1 linux-shell-test]#  var1=`echo -en 'name=robin\\nage=21'`\n[root@aliyun-hk1 linux-shell-test]# echo \"$var1\"\nname=robin\nage=21\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\ninput1=$1\nIFS=$'\\n'\ndeclare -A arr\nfor a1 in $input1\ndo\n   #echo $a1\n   left1=${a1%=*}\n   right1=${a1#*=}\n   arr[\"$left1\"]=$right1\ndone\nname=${arr[name]}\necho \"name:$name\"\nage=${arr[age]}\necho \"age:$age\"\n[root@aliyun-hk1 linux-shell-test]# ./for.sh \"$var1\"\nname:robin\nage:21\n[root@aliyun-hk1 linux-shell-test]#\n```\n**这里的变量var1使用的时候，一定要用双引号包起来，因为变量里有特殊字符，换行符。我们现在需要特殊字符正常解析，当然要使用双引号。**\n","source":"_posts/linux/linux_shell_for.md","raw":"---\ntitle: Linux之shell循环\ndate: 2020-03-17 23:00:00\ntags: shell\ncategories: linux\n---\n\n讲完了shell的变量和条件判断后，今天再来讲讲循环。就像c语言或者java一样，循环在所有的编程语言或脚本语言中必不可少，shell自然也是。\n<!--more-->\n\n#### 1.for循环\n假设你学过c语言后者java，循环的概念我就不废话了。for循环假设列表中的值都是用空格分开的，因此列表中的值如果有空格，用双引号包起来。\n##### 1.1 for 循环中list中都是常量\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nfor abc in hello world nihao zhongguo\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# chmod 755 for.sh\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is nihao\nthe next one is zhongguo\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.2 for 循环中list是一个字符串\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nlist1=\"ni hao hello world\"\nfor abc in $list1\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is ni\nthe next one is hao\nthe next one is hello\nthe next one is world\n```\n\n##### 1.3 for 循环中list是从文件读取的\n```\n[root@aliyun-hk1 linux-shell-test]# cat ./for.sh\n#!/bin/bash\n\nlist1=\"ni hao hello world\"\nfile=\"fortest.txt\"\nfor abc in $(cat $file)\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is ni\nthe next one is hao\nthe next one is I\nthe next one is am\nthe next one is robin\n```\n\n##### 1.4 for循环中使用非默认的分隔符\n因为有个特殊的环境变量IFS,它定义了bash shell用作字符分隔的一系列字符。默认的情况下，bash shell分隔符为分别为空格、制表符和换行符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\nfile=\"fortest.txt\"\nIFS=$'\\n'\nfor abc in $(cat $file)\ndo\n   echo the next one is $abc\ndone\n[root@aliyun-hk1 linux-shell-test]# ./for.sh\nthe next one is hello\nthe next one is world\nthe next one is ni\nthe next one is hao\nthe next one is I\nthe next one is am\nthe next one is robin h h li\n[root@aliyun-hk1 linux-shell-test]#\n```\n** 在shell编程中一般为了后续继续使用默认分隔符，一般先临时备份默认分隔符，IFS.OLD=$IFS;IFS=$'\\n';IFS=$IFS.OLD 保证后续脚本能在默认和非默认分隔符之间快速切换。**\n\n##### 1.5 for循环使用c语言的分格\n```\n[root@aliyun-hk1 linux-shell-test]# cat forc.sh\n#!/bin/bash\n\nfor (( i=1; i<=9; i++ ))\ndo\n   echo the next one is $i\ndone\n[root@aliyun-hk1 linux-shell-test]# ./forc.sh\nthe next one is 1\nthe next one is 2\nthe next one is 3\nthe next one is 4\nthe next one is 5\nthe next one is 6\nthe next one is 7\nthe next one is 8\nthe next one is 9\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 2.while循环\nwhile循环其实是if-else和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0，这组命令就反复执行。while循环写不好，很容易造成死循环。\n##### 2.1 使用一个测试命令的while循环\n```\n一个测试命令是最常见的方式。\n[root@aliyun-hk1 linux-shell-test]# cat test-while.sh\n#!/bin/bash\nvar1=5\nwhile [ $var1 -gt 0 ]\ndo\n    echo $var1\n    var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# chmod 755 test-while.sh\n[root@aliyun-hk1 linux-shell-test]# ./test-while.sh\n5\n4\n3\n2\n1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 2.2 使用多个测试命令的while循环\n```\n多个测试命令的时候，只有最后一个测试命令退出码用来判单循环是否继续执行，前面的测试命令忽略。\n[root@aliyun-hk1 linux-shell-test]# cat test-while.sh\n#!/bin/bash\nvar1=5\nwhile echo $var1\n      [ $var1 -ge 0 ]\ndo\n    echo $var1\n    var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# ./test-while.sh\n5\n5\n4\n4\n3\n3\n2\n2\n1\n1\n0\n0\n-1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 3.until循环\nuntil循环其实碰巧跟while循环相反，只要测试命令的退出返回码非0，就一直执行后面的一组命令，直到退出返回码为0，循环才结束。\n```\n[root@aliyun-hk1 linux-shell-test]# cat test-until.sh\n#!/bin/bash\n\nvar1=5\nuntil [ $var1 -eq 0 ]\ndo\n   echo $var1\n   var1=$[ $var1 -1 ]\ndone\n[root@aliyun-hk1 linux-shell-test]# ./test-until.sh\n5\n4\n3\n2\n1\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 4.循环读取多行内容\n通过jenkins调用shell并执行ansible脚本的时候，经常需要传递参数到shell。常规的做法可以，把一组内容组装到一个变量中，并且使用换行符作为分隔符，然后传给shell之后，再进行拆分并使用。\n```\n[root@aliyun-hk1 linux-shell-test]#  var1=`echo -en 'name=robin\\nage=21'`\n[root@aliyun-hk1 linux-shell-test]# echo \"$var1\"\nname=robin\nage=21\n[root@aliyun-hk1 linux-shell-test]# cat for.sh\n#!/bin/bash\n\ninput1=$1\nIFS=$'\\n'\ndeclare -A arr\nfor a1 in $input1\ndo\n   #echo $a1\n   left1=${a1%=*}\n   right1=${a1#*=}\n   arr[\"$left1\"]=$right1\ndone\nname=${arr[name]}\necho \"name:$name\"\nage=${arr[age]}\necho \"age:$age\"\n[root@aliyun-hk1 linux-shell-test]# ./for.sh \"$var1\"\nname:robin\nage:21\n[root@aliyun-hk1 linux-shell-test]#\n```\n**这里的变量var1使用的时候，一定要用双引号包起来，因为变量里有特殊字符，换行符。我们现在需要特殊字符正常解析，当然要使用双引号。**\n","slug":"linux/linux_shell_for","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdetb00460en7ceq0pxc3","content":"<p>讲完了shell的变量和条件判断后，今天再来讲讲循环。就像c语言或者java一样，循环在所有的编程语言或脚本语言中必不可少，shell自然也是。<br><a id=\"more\"></a></p>\n<h4 id=\"1-for循环\"><a href=\"#1-for循环\" class=\"headerlink\" title=\"1.for循环\"></a>1.for循环</h4><p>假设你学过c语言后者java，循环的概念我就不废话了。for循环假设列表中的值都是用空格分开的，因此列表中的值如果有空格，用双引号包起来。</p>\n<h5 id=\"1-1-for-循环中list中都是常量\"><a href=\"#1-1-for-循环中list中都是常量\" class=\"headerlink\" title=\"1.1 for 循环中list中都是常量\"></a>1.1 for 循环中list中都是常量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">for abc in hello world nihao zhongguo</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 for.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is nihao</span><br><span class=\"line\">the next one is zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-for-循环中list是一个字符串\"><a href=\"#1-2-for-循环中list是一个字符串\" class=\"headerlink\" title=\"1.2 for 循环中list是一个字符串\"></a>1.2 for 循环中list是一个字符串</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">list1=&quot;ni hao hello world&quot;</span><br><span class=\"line\">for abc in $list1</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-3-for-循环中list是从文件读取的\"><a href=\"#1-3-for-循环中list是从文件读取的\" class=\"headerlink\" title=\"1.3 for 循环中list是从文件读取的\"></a>1.3 for 循环中list是从文件读取的</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ./for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">list1=&quot;ni hao hello world&quot;</span><br><span class=\"line\">file=&quot;fortest.txt&quot;</span><br><span class=\"line\">for abc in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is I</span><br><span class=\"line\">the next one is am</span><br><span class=\"line\">the next one is robin</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-4-for循环中使用非默认的分隔符\"><a href=\"#1-4-for循环中使用非默认的分隔符\" class=\"headerlink\" title=\"1.4 for循环中使用非默认的分隔符\"></a>1.4 for循环中使用非默认的分隔符</h5><p>因为有个特殊的环境变量IFS,它定义了bash shell用作字符分隔的一系列字符。默认的情况下，bash shell分隔符为分别为空格、制表符和换行符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">file=&quot;fortest.txt&quot;</span><br><span class=\"line\">IFS=$&apos;\\n&apos;</span><br><span class=\"line\">for abc in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is I</span><br><span class=\"line\">the next one is am</span><br><span class=\"line\">the next one is robin h h li</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong> 在shell编程中一般为了后续继续使用默认分隔符，一般先临时备份默认分隔符，IFS.OLD=$IFS;IFS=$’\\n’;IFS=$IFS.OLD 保证后续脚本能在默认和非默认分隔符之间快速切换。</strong></p>\n<h5 id=\"1-5-for循环使用c语言的分格\"><a href=\"#1-5-for循环使用c语言的分格\" class=\"headerlink\" title=\"1.5 for循环使用c语言的分格\"></a>1.5 for循环使用c语言的分格</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat forc.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">for (( i=1; i&lt;=9; i++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $i</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./forc.sh</span><br><span class=\"line\">the next one is 1</span><br><span class=\"line\">the next one is 2</span><br><span class=\"line\">the next one is 3</span><br><span class=\"line\">the next one is 4</span><br><span class=\"line\">the next one is 5</span><br><span class=\"line\">the next one is 6</span><br><span class=\"line\">the next one is 7</span><br><span class=\"line\">the next one is 8</span><br><span class=\"line\">the next one is 9</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-while循环\"><a href=\"#2-while循环\" class=\"headerlink\" title=\"2.while循环\"></a>2.while循环</h4><p>while循环其实是if-else和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0，这组命令就反复执行。while循环写不好，很容易造成死循环。</p>\n<h5 id=\"2-1-使用一个测试命令的while循环\"><a href=\"#2-1-使用一个测试命令的while循环\" class=\"headerlink\" title=\"2.1 使用一个测试命令的while循环\"></a>2.1 使用一个测试命令的while循环</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个测试命令是最常见的方式。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-while.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">var1=5</span><br><span class=\"line\">while [ $var1 -gt 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo $var1</span><br><span class=\"line\">    var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 test-while.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-while.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-使用多个测试命令的while循环\"><a href=\"#2-2-使用多个测试命令的while循环\" class=\"headerlink\" title=\"2.2 使用多个测试命令的while循环\"></a>2.2 使用多个测试命令的while循环</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个测试命令的时候，只有最后一个测试命令退出码用来判单循环是否继续执行，前面的测试命令忽略。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-while.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">var1=5</span><br><span class=\"line\">while echo $var1</span><br><span class=\"line\">      [ $var1 -ge 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo $var1</span><br><span class=\"line\">    var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-while.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">-1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-until循环\"><a href=\"#3-until循环\" class=\"headerlink\" title=\"3.until循环\"></a>3.until循环</h4><p>until循环其实碰巧跟while循环相反，只要测试命令的退出返回码非0，就一直执行后面的一组命令，直到退出返回码为0，循环才结束。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-until.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">var1=5</span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $var1</span><br><span class=\"line\">   var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-until.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-循环读取多行内容\"><a href=\"#4-循环读取多行内容\" class=\"headerlink\" title=\"4.循环读取多行内容\"></a>4.循环读取多行内容</h4><p>通过jenkins调用shell并执行ansible脚本的时候，经常需要传递参数到shell。常规的做法可以，把一组内容组装到一个变量中，并且使用换行符作为分隔符，然后传给shell之后，再进行拆分并使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#  var1=`echo -en &apos;name=robin\\nage=21&apos;`</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &quot;$var1&quot;</span><br><span class=\"line\">name=robin</span><br><span class=\"line\">age=21</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">input1=$1</span><br><span class=\"line\">IFS=$&apos;\\n&apos;</span><br><span class=\"line\">declare -A arr</span><br><span class=\"line\">for a1 in $input1</span><br><span class=\"line\">do</span><br><span class=\"line\">   #echo $a1</span><br><span class=\"line\">   left1=$&#123;a1%=*&#125;</span><br><span class=\"line\">   right1=$&#123;a1#*=&#125;</span><br><span class=\"line\">   arr[&quot;$left1&quot;]=$right1</span><br><span class=\"line\">done</span><br><span class=\"line\">name=$&#123;arr[name]&#125;</span><br><span class=\"line\">echo &quot;name:$name&quot;</span><br><span class=\"line\">age=$&#123;arr[age]&#125;</span><br><span class=\"line\">echo &quot;age:$age&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh &quot;$var1&quot;</span><br><span class=\"line\">name:robin</span><br><span class=\"line\">age:21</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里的变量var1使用的时候，一定要用双引号包起来，因为变量里有特殊字符，换行符。我们现在需要特殊字符正常解析，当然要使用双引号。</strong></p>\n","site":{"data":{}},"excerpt":"<p>讲完了shell的变量和条件判断后，今天再来讲讲循环。就像c语言或者java一样，循环在所有的编程语言或脚本语言中必不可少，shell自然也是。<br>","more":"</p>\n<h4 id=\"1-for循环\"><a href=\"#1-for循环\" class=\"headerlink\" title=\"1.for循环\"></a>1.for循环</h4><p>假设你学过c语言后者java，循环的概念我就不废话了。for循环假设列表中的值都是用空格分开的，因此列表中的值如果有空格，用双引号包起来。</p>\n<h5 id=\"1-1-for-循环中list中都是常量\"><a href=\"#1-1-for-循环中list中都是常量\" class=\"headerlink\" title=\"1.1 for 循环中list中都是常量\"></a>1.1 for 循环中list中都是常量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">for abc in hello world nihao zhongguo</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 for.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is nihao</span><br><span class=\"line\">the next one is zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-for-循环中list是一个字符串\"><a href=\"#1-2-for-循环中list是一个字符串\" class=\"headerlink\" title=\"1.2 for 循环中list是一个字符串\"></a>1.2 for 循环中list是一个字符串</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">list1=&quot;ni hao hello world&quot;</span><br><span class=\"line\">for abc in $list1</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-3-for-循环中list是从文件读取的\"><a href=\"#1-3-for-循环中list是从文件读取的\" class=\"headerlink\" title=\"1.3 for 循环中list是从文件读取的\"></a>1.3 for 循环中list是从文件读取的</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat ./for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">list1=&quot;ni hao hello world&quot;</span><br><span class=\"line\">file=&quot;fortest.txt&quot;</span><br><span class=\"line\">for abc in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is I</span><br><span class=\"line\">the next one is am</span><br><span class=\"line\">the next one is robin</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-4-for循环中使用非默认的分隔符\"><a href=\"#1-4-for循环中使用非默认的分隔符\" class=\"headerlink\" title=\"1.4 for循环中使用非默认的分隔符\"></a>1.4 for循环中使用非默认的分隔符</h5><p>因为有个特殊的环境变量IFS,它定义了bash shell用作字符分隔的一系列字符。默认的情况下，bash shell分隔符为分别为空格、制表符和换行符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">file=&quot;fortest.txt&quot;</span><br><span class=\"line\">IFS=$&apos;\\n&apos;</span><br><span class=\"line\">for abc in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $abc</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh</span><br><span class=\"line\">the next one is hello</span><br><span class=\"line\">the next one is world</span><br><span class=\"line\">the next one is ni</span><br><span class=\"line\">the next one is hao</span><br><span class=\"line\">the next one is I</span><br><span class=\"line\">the next one is am</span><br><span class=\"line\">the next one is robin h h li</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong> 在shell编程中一般为了后续继续使用默认分隔符，一般先临时备份默认分隔符，IFS.OLD=$IFS;IFS=$’\\n’;IFS=$IFS.OLD 保证后续脚本能在默认和非默认分隔符之间快速切换。</strong></p>\n<h5 id=\"1-5-for循环使用c语言的分格\"><a href=\"#1-5-for循环使用c语言的分格\" class=\"headerlink\" title=\"1.5 for循环使用c语言的分格\"></a>1.5 for循环使用c语言的分格</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat forc.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">for (( i=1; i&lt;=9; i++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo the next one is $i</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./forc.sh</span><br><span class=\"line\">the next one is 1</span><br><span class=\"line\">the next one is 2</span><br><span class=\"line\">the next one is 3</span><br><span class=\"line\">the next one is 4</span><br><span class=\"line\">the next one is 5</span><br><span class=\"line\">the next one is 6</span><br><span class=\"line\">the next one is 7</span><br><span class=\"line\">the next one is 8</span><br><span class=\"line\">the next one is 9</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-while循环\"><a href=\"#2-while循环\" class=\"headerlink\" title=\"2.while循环\"></a>2.while循环</h4><p>while循环其实是if-else和for循环的混杂体。while命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码0，这组命令就反复执行。while循环写不好，很容易造成死循环。</p>\n<h5 id=\"2-1-使用一个测试命令的while循环\"><a href=\"#2-1-使用一个测试命令的while循环\" class=\"headerlink\" title=\"2.1 使用一个测试命令的while循环\"></a>2.1 使用一个测试命令的while循环</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一个测试命令是最常见的方式。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-while.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">var1=5</span><br><span class=\"line\">while [ $var1 -gt 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo $var1</span><br><span class=\"line\">    var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# chmod 755 test-while.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-while.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-2-使用多个测试命令的while循环\"><a href=\"#2-2-使用多个测试命令的while循环\" class=\"headerlink\" title=\"2.2 使用多个测试命令的while循环\"></a>2.2 使用多个测试命令的while循环</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个测试命令的时候，只有最后一个测试命令退出码用来判单循环是否继续执行，前面的测试命令忽略。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-while.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">var1=5</span><br><span class=\"line\">while echo $var1</span><br><span class=\"line\">      [ $var1 -ge 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo $var1</span><br><span class=\"line\">    var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-while.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br><span class=\"line\">-1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-until循环\"><a href=\"#3-until循环\" class=\"headerlink\" title=\"3.until循环\"></a>3.until循环</h4><p>until循环其实碰巧跟while循环相反，只要测试命令的退出返回码非0，就一直执行后面的一组命令，直到退出返回码为0，循环才结束。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test-until.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">var1=5</span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">   echo $var1</span><br><span class=\"line\">   var1=$[ $var1 -1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test-until.sh</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-循环读取多行内容\"><a href=\"#4-循环读取多行内容\" class=\"headerlink\" title=\"4.循环读取多行内容\"></a>4.循环读取多行内容</h4><p>通过jenkins调用shell并执行ansible脚本的时候，经常需要传递参数到shell。常规的做法可以，把一组内容组装到一个变量中，并且使用换行符作为分隔符，然后传给shell之后，再进行拆分并使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#  var1=`echo -en &apos;name=robin\\nage=21&apos;`</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &quot;$var1&quot;</span><br><span class=\"line\">name=robin</span><br><span class=\"line\">age=21</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat for.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">input1=$1</span><br><span class=\"line\">IFS=$&apos;\\n&apos;</span><br><span class=\"line\">declare -A arr</span><br><span class=\"line\">for a1 in $input1</span><br><span class=\"line\">do</span><br><span class=\"line\">   #echo $a1</span><br><span class=\"line\">   left1=$&#123;a1%=*&#125;</span><br><span class=\"line\">   right1=$&#123;a1#*=&#125;</span><br><span class=\"line\">   arr[&quot;$left1&quot;]=$right1</span><br><span class=\"line\">done</span><br><span class=\"line\">name=$&#123;arr[name]&#125;</span><br><span class=\"line\">echo &quot;name:$name&quot;</span><br><span class=\"line\">age=$&#123;arr[age]&#125;</span><br><span class=\"line\">echo &quot;age:$age&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./for.sh &quot;$var1&quot;</span><br><span class=\"line\">name:robin</span><br><span class=\"line\">age:21</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里的变量var1使用的时候，一定要用双引号包起来，因为变量里有特殊字符，换行符。我们现在需要特殊字符正常解析，当然要使用双引号。</strong></p>"},{"title":"Linux之shell用户输入","date":"2020-03-19T23:00:00.000Z","_content":"\n讲完了shell的变量、条件判断和循环后，今天再来讲以下如何处理用户的输入。\n<!--more-->\n\n#### 1.1命令行参数\n我们编写shell脚本的时候，可能有些是需要用户传递参数进去的，命令行参数是最常用的方式。$0是可以获取程序名，$1获取第一个参数，$2获取第二个参数，以此类推，不同的参数用空格分隔，如果参数本身包含空格，必须使用单引号或双引号包起来。直接上示例:\n\n##### 1.1.1参数本身没有空格的话，加不加引号无所谓\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho $(basename $0)\necho $0\necho $1\necho $2\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 1 2 3\nshell-input.sh\n./shell-input.sh\n1\n2\n```\n\n##### 1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\n```\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh \"hello world\" \"nihao zhongguo\"\nshell-input.sh\n./shell-input.sh\nhello world\nnihao zhongguo\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh hello world nihao zhongguo\nshell-input.sh\n./shell-input.sh\nhello\nworld\n```\n\n##### 1.1.3检查参数是否为空\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\nif [ -n \"$1\" ]\nthen\n  echo $(basename $0)\n  echo $0\n  echo $1\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10\nshell-input.sh\n./shell-input.sh\n10\n[root@aliyun-hk1 linux-shell-test]#\n```\n*-z判断变量的值,如果为空返回0，否则返回1；-n判断变量的值，如果为空返回1，否则返回0，使用[]的时候，变量用双引号包起来*\n\n##### 1.1.4检查参数的个数\n```\n先打印变量的个数，如果变量个数大于0，输出它。\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$#\"\n\nif [ \"$#\" -gt 0 ]\nthen\n  echo $(basename $0)\n  echo $0\n  echo $1\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\n0\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 11\n2\nshell-input.sh\n./shell-input.sh\n10\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.1.5 抓取所有的参数值\n抓取所有参数，并且当作一个整体处理，使用$*\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$*\"\ncount1=0\n\nfor a in \"$*\"\ndo\n  echo \"$a\"\n  count1=$[ $count1 +1 ]\n  echo \"$count1\"\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello\n10 20 hello\n10 20 hello\n1\n```\n\n抓取所有参数，并且把每个参数分开处理，使用$@\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$@\"\ncount1=0\n\nfor a in \"$@\"\ndo\n  count1=$[ $count1 +1 ]\n  echo \"$count1\"\n  echo \"$a\"\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello\n10 20 hello\n1\n10\n2\n20\n3\nhello\n```\n\n##### 1.1.6 移动参数变量\n使用shift是遍历参数的一个简单好用的办法，默认情况下它会将每个参数变量向左移动一个位置，移动后变量$3变为$2，$2变为$1,$1被丢弃，$0不变。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\ncount1=1\nwhile [ -n \"$1\" ]\ndo\n  echo \"parameter #$count1 is $1\"\n  count1=$[ $count1 + 1 ]\n  shift\ndone\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 30\nparameter #1 is 10\nparameter #2 is 20\nparameter #3 is 30\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 1.2获取用户输入\nshell脚本运行时，可能有时候需要用户临时输入参数，继续后面的操作。接下来，我们就来讲讲获取用户输入的多种方式。\n##### 1.2.1 基本的读取\n使用read name读取输入到name，使用read -s password读取输入到password并且不shell上隐藏输入。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho -n \"please input your name:\"\nread name\necho -n \"please input your password:\"\nread -s password\necho \"\"\necho \"your user name is $name, password is $password\"\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nplease input your name:robin\nplease input your password:\nyour user name is robin, password is nihao\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n##### 1.2.2 设置等待用户超时时间\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\nif read -t 5 -p \"please input name\" name\nthen\n   echo \"hello $name\"\nelse\n   echo\n   echo \"sorry fo timeout\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nplease input name\nsorry fo timeout\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n##### 1.2.3 从文件读取参数\n最后再讲讲如何从文件读入参数，并直接来使用。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\ncount=1\ncat test | while read line\ndo\n  echo \"Line $count: $line\"\n  count=$[ $count + 1 ]\ndone\n\necho ”finish read the file\"\n[root@aliyun-hk1 linux-shell-test]# vim test\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nLine 1: 10\nLine 2: 20\nLine 3: hello\nfinish read the file\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n\n#### 1.3 参数标准化\n在linux世界里，对于传递给shell程序的选项，已经有了某种程序的保准含义。我们在自己编写shell脚本时，也可以参考该标准。\n```\n-a 显示所有对象\n-c 生成一个计数器\n-d 一定一个目录\n-e 扩展一个对象\n-f 指定读入数据的文件\n-h 显示命令的帮助信息\n-i 忽略文本的大小写\n-l 显示输出的长格式版本\n-n 使用非交互模式\n-o 将所有输出重定向到指定的文件\n-q 以安静模式运行\n-r 递归的处理目录和文件\n-s 以安静模式运行\n-v 生成详细输出\n-x 排除某个对象\n-y 对所有问题回答yes\n```","source":"_posts/linux/linux_shell_input.md","raw":"---\ntitle: Linux之shell用户输入\ndate: 2020-03-19 23:00:00\ntags: shell\ncategories: linux\n---\n\n讲完了shell的变量、条件判断和循环后，今天再来讲以下如何处理用户的输入。\n<!--more-->\n\n#### 1.1命令行参数\n我们编写shell脚本的时候，可能有些是需要用户传递参数进去的，命令行参数是最常用的方式。$0是可以获取程序名，$1获取第一个参数，$2获取第二个参数，以此类推，不同的参数用空格分隔，如果参数本身包含空格，必须使用单引号或双引号包起来。直接上示例:\n\n##### 1.1.1参数本身没有空格的话，加不加引号无所谓\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho $(basename $0)\necho $0\necho $1\necho $2\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 1 2 3\nshell-input.sh\n./shell-input.sh\n1\n2\n```\n\n##### 1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\n```\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh \"hello world\" \"nihao zhongguo\"\nshell-input.sh\n./shell-input.sh\nhello world\nnihao zhongguo\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh hello world nihao zhongguo\nshell-input.sh\n./shell-input.sh\nhello\nworld\n```\n\n##### 1.1.3检查参数是否为空\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\nif [ -n \"$1\" ]\nthen\n  echo $(basename $0)\n  echo $0\n  echo $1\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10\nshell-input.sh\n./shell-input.sh\n10\n[root@aliyun-hk1 linux-shell-test]#\n```\n*-z判断变量的值,如果为空返回0，否则返回1；-n判断变量的值，如果为空返回1，否则返回0，使用[]的时候，变量用双引号包起来*\n\n##### 1.1.4检查参数的个数\n```\n先打印变量的个数，如果变量个数大于0，输出它。\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$#\"\n\nif [ \"$#\" -gt 0 ]\nthen\n  echo $(basename $0)\n  echo $0\n  echo $1\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\n0\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 11\n2\nshell-input.sh\n./shell-input.sh\n10\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.1.5 抓取所有的参数值\n抓取所有参数，并且当作一个整体处理，使用$*\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$*\"\ncount1=0\n\nfor a in \"$*\"\ndo\n  echo \"$a\"\n  count1=$[ $count1 +1 ]\n  echo \"$count1\"\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello\n10 20 hello\n10 20 hello\n1\n```\n\n抓取所有参数，并且把每个参数分开处理，使用$@\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho \"$@\"\ncount1=0\n\nfor a in \"$@\"\ndo\n  count1=$[ $count1 +1 ]\n  echo \"$count1\"\n  echo \"$a\"\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello\n10 20 hello\n1\n10\n2\n20\n3\nhello\n```\n\n##### 1.1.6 移动参数变量\n使用shift是遍历参数的一个简单好用的办法，默认情况下它会将每个参数变量向左移动一个位置，移动后变量$3变为$2，$2变为$1,$1被丢弃，$0不变。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\ncount1=1\nwhile [ -n \"$1\" ]\ndo\n  echo \"parameter #$count1 is $1\"\n  count1=$[ $count1 + 1 ]\n  shift\ndone\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 30\nparameter #1 is 10\nparameter #2 is 20\nparameter #3 is 30\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 1.2获取用户输入\nshell脚本运行时，可能有时候需要用户临时输入参数，继续后面的操作。接下来，我们就来讲讲获取用户输入的多种方式。\n##### 1.2.1 基本的读取\n使用read name读取输入到name，使用read -s password读取输入到password并且不shell上隐藏输入。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\necho -n \"please input your name:\"\nread name\necho -n \"please input your password:\"\nread -s password\necho \"\"\necho \"your user name is $name, password is $password\"\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nplease input your name:robin\nplease input your password:\nyour user name is robin, password is nihao\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n##### 1.2.2 设置等待用户超时时间\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\nif read -t 5 -p \"please input name\" name\nthen\n   echo \"hello $name\"\nelse\n   echo\n   echo \"sorry fo timeout\"\nfi\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nplease input name\nsorry fo timeout\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n##### 1.2.3 从文件读取参数\n最后再讲讲如何从文件读入参数，并直接来使用。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n\ncount=1\ncat test | while read line\ndo\n  echo \"Line $count: $line\"\n  count=$[ $count + 1 ]\ndone\n\necho ”finish read the file\"\n[root@aliyun-hk1 linux-shell-test]# vim test\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nLine 1: 10\nLine 2: 20\nLine 3: hello\nfinish read the file\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n\n#### 1.3 参数标准化\n在linux世界里，对于传递给shell程序的选项，已经有了某种程序的保准含义。我们在自己编写shell脚本时，也可以参考该标准。\n```\n-a 显示所有对象\n-c 生成一个计数器\n-d 一定一个目录\n-e 扩展一个对象\n-f 指定读入数据的文件\n-h 显示命令的帮助信息\n-i 忽略文本的大小写\n-l 显示输出的长格式版本\n-n 使用非交互模式\n-o 将所有输出重定向到指定的文件\n-q 以安静模式运行\n-r 递归的处理目录和文件\n-s 以安静模式运行\n-v 生成详细输出\n-x 排除某个对象\n-y 对所有问题回答yes\n```","slug":"linux/linux_shell_input","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdetd00490en7jq3gtjxs","content":"<p>讲完了shell的变量、条件判断和循环后，今天再来讲以下如何处理用户的输入。<br><a id=\"more\"></a></p>\n<h4 id=\"1-1命令行参数\"><a href=\"#1-1命令行参数\" class=\"headerlink\" title=\"1.1命令行参数\"></a>1.1命令行参数</h4><p>我们编写shell脚本的时候，可能有些是需要用户传递参数进去的，命令行参数是最常用的方式。$0是可以获取程序名，$1获取第一个参数，$2获取第二个参数，以此类推，不同的参数用空格分隔，如果参数本身包含空格，必须使用单引号或双引号包起来。直接上示例:</p>\n<h5 id=\"1-1-1参数本身没有空格的话，加不加引号无所谓\"><a href=\"#1-1-1参数本身没有空格的话，加不加引号无所谓\" class=\"headerlink\" title=\"1.1.1参数本身没有空格的话，加不加引号无所谓\"></a>1.1.1参数本身没有空格的话，加不加引号无所谓</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo $(basename $0)</span><br><span class=\"line\">echo $0</span><br><span class=\"line\">echo $1</span><br><span class=\"line\">echo $2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 1 2 3</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\"><a href=\"#1-1-2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\" class=\"headerlink\" title=\"1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\"></a>1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh &quot;hello world&quot; &quot;nihao zhongguo&quot;</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">hello world</span><br><span class=\"line\">nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh hello world nihao zhongguo</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-3检查参数是否为空\"><a href=\"#1-1-3检查参数是否为空\" class=\"headerlink\" title=\"1.1.3检查参数是否为空\"></a>1.1.3检查参数是否为空</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -n &quot;$1&quot; ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo $(basename $0)</span><br><span class=\"line\">  echo $0</span><br><span class=\"line\">  echo $1</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">10</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<p><em>-z判断变量的值,如果为空返回0，否则返回1；-n判断变量的值，如果为空返回1，否则返回0，使用[]的时候，变量用双引号包起来</em></p>\n<h5 id=\"1-1-4检查参数的个数\"><a href=\"#1-1-4检查参数的个数\" class=\"headerlink\" title=\"1.1.4检查参数的个数\"></a>1.1.4检查参数的个数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先打印变量的个数，如果变量个数大于0，输出它。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ &quot;$#&quot; -gt 0 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo $(basename $0)</span><br><span class=\"line\">  echo $0</span><br><span class=\"line\">  echo $1</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 11</span><br><span class=\"line\">2</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">10</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-5-抓取所有的参数值\"><a href=\"#1-1-5-抓取所有的参数值\" class=\"headerlink\" title=\"1.1.5 抓取所有的参数值\"></a>1.1.5 抓取所有的参数值</h5><p>抓取所有参数，并且当作一个整体处理，使用$*<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$*&quot;</span><br><span class=\"line\">count1=0</span><br><span class=\"line\"></span><br><span class=\"line\">for a in &quot;$*&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;$a&quot;</span><br><span class=\"line\">  count1=$[ $count1 +1 ]</span><br><span class=\"line\">  echo &quot;$count1&quot;</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>抓取所有参数，并且把每个参数分开处理，使用$@<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$@&quot;</span><br><span class=\"line\">count1=0</span><br><span class=\"line\"></span><br><span class=\"line\">for a in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">  count1=$[ $count1 +1 ]</span><br><span class=\"line\">  echo &quot;$count1&quot;</span><br><span class=\"line\">  echo &quot;$a&quot;</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">1</span><br><span class=\"line\">10</span><br><span class=\"line\">2</span><br><span class=\"line\">20</span><br><span class=\"line\">3</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-6-移动参数变量\"><a href=\"#1-1-6-移动参数变量\" class=\"headerlink\" title=\"1.1.6 移动参数变量\"></a>1.1.6 移动参数变量</h5><p>使用shift是遍历参数的一个简单好用的办法，默认情况下它会将每个参数变量向左移动一个位置，移动后变量$3变为$2，$2变为$1,$1被丢弃，$0不变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">count1=1</span><br><span class=\"line\">while [ -n &quot;$1&quot; ]</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;parameter #$count1 is $1&quot;</span><br><span class=\"line\">  count1=$[ $count1 + 1 ]</span><br><span class=\"line\">  shift</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 30</span><br><span class=\"line\">parameter #1 is 10</span><br><span class=\"line\">parameter #2 is 20</span><br><span class=\"line\">parameter #3 is 30</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-2获取用户输入\"><a href=\"#1-2获取用户输入\" class=\"headerlink\" title=\"1.2获取用户输入\"></a>1.2获取用户输入</h4><p>shell脚本运行时，可能有时候需要用户临时输入参数，继续后面的操作。接下来，我们就来讲讲获取用户输入的多种方式。</p>\n<h5 id=\"1-2-1-基本的读取\"><a href=\"#1-2-1-基本的读取\" class=\"headerlink\" title=\"1.2.1 基本的读取\"></a>1.2.1 基本的读取</h5><p>使用read name读取输入到name，使用read -s password读取输入到password并且不shell上隐藏输入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo -n &quot;please input your name:&quot;</span><br><span class=\"line\">read name</span><br><span class=\"line\">echo -n &quot;please input your password:&quot;</span><br><span class=\"line\">read -s password</span><br><span class=\"line\">echo &quot;&quot;</span><br><span class=\"line\">echo &quot;your user name is $name, password is $password&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">please input your name:robin</span><br><span class=\"line\">please input your password:</span><br><span class=\"line\">your user name is robin, password is nihao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-2-设置等待用户超时时间\"><a href=\"#1-2-2-设置等待用户超时时间\" class=\"headerlink\" title=\"1.2.2 设置等待用户超时时间\"></a>1.2.2 设置等待用户超时时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if read -t 5 -p &quot;please input name&quot; name</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello $name&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo</span><br><span class=\"line\">   echo &quot;sorry fo timeout&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">please input name</span><br><span class=\"line\">sorry fo timeout</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-3-从文件读取参数\"><a href=\"#1-2-3-从文件读取参数\" class=\"headerlink\" title=\"1.2.3 从文件读取参数\"></a>1.2.3 从文件读取参数</h5><p>最后再讲讲如何从文件读入参数，并直接来使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">cat test | while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;Line $count: $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo ”finish read the file&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# vim test</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">Line 1: 10</span><br><span class=\"line\">Line 2: 20</span><br><span class=\"line\">Line 3: hello</span><br><span class=\"line\">finish read the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-3-参数标准化\"><a href=\"#1-3-参数标准化\" class=\"headerlink\" title=\"1.3 参数标准化\"></a>1.3 参数标准化</h4><p>在linux世界里，对于传递给shell程序的选项，已经有了某种程序的保准含义。我们在自己编写shell脚本时，也可以参考该标准。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 显示所有对象</span><br><span class=\"line\">-c 生成一个计数器</span><br><span class=\"line\">-d 一定一个目录</span><br><span class=\"line\">-e 扩展一个对象</span><br><span class=\"line\">-f 指定读入数据的文件</span><br><span class=\"line\">-h 显示命令的帮助信息</span><br><span class=\"line\">-i 忽略文本的大小写</span><br><span class=\"line\">-l 显示输出的长格式版本</span><br><span class=\"line\">-n 使用非交互模式</span><br><span class=\"line\">-o 将所有输出重定向到指定的文件</span><br><span class=\"line\">-q 以安静模式运行</span><br><span class=\"line\">-r 递归的处理目录和文件</span><br><span class=\"line\">-s 以安静模式运行</span><br><span class=\"line\">-v 生成详细输出</span><br><span class=\"line\">-x 排除某个对象</span><br><span class=\"line\">-y 对所有问题回答yes</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>讲完了shell的变量、条件判断和循环后，今天再来讲以下如何处理用户的输入。<br>","more":"</p>\n<h4 id=\"1-1命令行参数\"><a href=\"#1-1命令行参数\" class=\"headerlink\" title=\"1.1命令行参数\"></a>1.1命令行参数</h4><p>我们编写shell脚本的时候，可能有些是需要用户传递参数进去的，命令行参数是最常用的方式。$0是可以获取程序名，$1获取第一个参数，$2获取第二个参数，以此类推，不同的参数用空格分隔，如果参数本身包含空格，必须使用单引号或双引号包起来。直接上示例:</p>\n<h5 id=\"1-1-1参数本身没有空格的话，加不加引号无所谓\"><a href=\"#1-1-1参数本身没有空格的话，加不加引号无所谓\" class=\"headerlink\" title=\"1.1.1参数本身没有空格的话，加不加引号无所谓\"></a>1.1.1参数本身没有空格的话，加不加引号无所谓</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo $(basename $0)</span><br><span class=\"line\">echo $0</span><br><span class=\"line\">echo $1</span><br><span class=\"line\">echo $2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 1 2 3</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\"><a href=\"#1-1-2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\" class=\"headerlink\" title=\"1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对\"></a>1.1.2参数本身有空格，不加引号的话，会被当做多个变量处理，用引号包起来才对</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh &quot;hello world&quot; &quot;nihao zhongguo&quot;</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">hello world</span><br><span class=\"line\">nihao zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh hello world nihao zhongguo</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-3检查参数是否为空\"><a href=\"#1-1-3检查参数是否为空\" class=\"headerlink\" title=\"1.1.3检查参数是否为空\"></a>1.1.3检查参数是否为空</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -n &quot;$1&quot; ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo $(basename $0)</span><br><span class=\"line\">  echo $0</span><br><span class=\"line\">  echo $1</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">10</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<p><em>-z判断变量的值,如果为空返回0，否则返回1；-n判断变量的值，如果为空返回1，否则返回0，使用[]的时候，变量用双引号包起来</em></p>\n<h5 id=\"1-1-4检查参数的个数\"><a href=\"#1-1-4检查参数的个数\" class=\"headerlink\" title=\"1.1.4检查参数的个数\"></a>1.1.4检查参数的个数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先打印变量的个数，如果变量个数大于0，输出它。</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$#&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ &quot;$#&quot; -gt 0 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo $(basename $0)</span><br><span class=\"line\">  echo $0</span><br><span class=\"line\">  echo $1</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 11</span><br><span class=\"line\">2</span><br><span class=\"line\">shell-input.sh</span><br><span class=\"line\">./shell-input.sh</span><br><span class=\"line\">10</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-1-5-抓取所有的参数值\"><a href=\"#1-1-5-抓取所有的参数值\" class=\"headerlink\" title=\"1.1.5 抓取所有的参数值\"></a>1.1.5 抓取所有的参数值</h5><p>抓取所有参数，并且当作一个整体处理，使用$*<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$*&quot;</span><br><span class=\"line\">count1=0</span><br><span class=\"line\"></span><br><span class=\"line\">for a in &quot;$*&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;$a&quot;</span><br><span class=\"line\">  count1=$[ $count1 +1 ]</span><br><span class=\"line\">  echo &quot;$count1&quot;</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<p>抓取所有参数，并且把每个参数分开处理，使用$@<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;$@&quot;</span><br><span class=\"line\">count1=0</span><br><span class=\"line\"></span><br><span class=\"line\">for a in &quot;$@&quot;</span><br><span class=\"line\">do</span><br><span class=\"line\">  count1=$[ $count1 +1 ]</span><br><span class=\"line\">  echo &quot;$count1&quot;</span><br><span class=\"line\">  echo &quot;$a&quot;</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 hello</span><br><span class=\"line\">10 20 hello</span><br><span class=\"line\">1</span><br><span class=\"line\">10</span><br><span class=\"line\">2</span><br><span class=\"line\">20</span><br><span class=\"line\">3</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-1-6-移动参数变量\"><a href=\"#1-1-6-移动参数变量\" class=\"headerlink\" title=\"1.1.6 移动参数变量\"></a>1.1.6 移动参数变量</h5><p>使用shift是遍历参数的一个简单好用的办法，默认情况下它会将每个参数变量向左移动一个位置，移动后变量$3变为$2，$2变为$1,$1被丢弃，$0不变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">count1=1</span><br><span class=\"line\">while [ -n &quot;$1&quot; ]</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;parameter #$count1 is $1&quot;</span><br><span class=\"line\">  count1=$[ $count1 + 1 ]</span><br><span class=\"line\">  shift</span><br><span class=\"line\">done</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh 10 20 30</span><br><span class=\"line\">parameter #1 is 10</span><br><span class=\"line\">parameter #2 is 20</span><br><span class=\"line\">parameter #3 is 30</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-2获取用户输入\"><a href=\"#1-2获取用户输入\" class=\"headerlink\" title=\"1.2获取用户输入\"></a>1.2获取用户输入</h4><p>shell脚本运行时，可能有时候需要用户临时输入参数，继续后面的操作。接下来，我们就来讲讲获取用户输入的多种方式。</p>\n<h5 id=\"1-2-1-基本的读取\"><a href=\"#1-2-1-基本的读取\" class=\"headerlink\" title=\"1.2.1 基本的读取\"></a>1.2.1 基本的读取</h5><p>使用read name读取输入到name，使用read -s password读取输入到password并且不shell上隐藏输入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo -n &quot;please input your name:&quot;</span><br><span class=\"line\">read name</span><br><span class=\"line\">echo -n &quot;please input your password:&quot;</span><br><span class=\"line\">read -s password</span><br><span class=\"line\">echo &quot;&quot;</span><br><span class=\"line\">echo &quot;your user name is $name, password is $password&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">please input your name:robin</span><br><span class=\"line\">please input your password:</span><br><span class=\"line\">your user name is robin, password is nihao</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-2-设置等待用户超时时间\"><a href=\"#1-2-2-设置等待用户超时时间\" class=\"headerlink\" title=\"1.2.2 设置等待用户超时时间\"></a>1.2.2 设置等待用户超时时间</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">if read -t 5 -p &quot;please input name&quot; name</span><br><span class=\"line\">then</span><br><span class=\"line\">   echo &quot;hello $name&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">   echo</span><br><span class=\"line\">   echo &quot;sorry fo timeout&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">please input name</span><br><span class=\"line\">sorry fo timeout</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-3-从文件读取参数\"><a href=\"#1-2-3-从文件读取参数\" class=\"headerlink\" title=\"1.2.3 从文件读取参数\"></a>1.2.3 从文件读取参数</h5><p>最后再讲讲如何从文件读入参数，并直接来使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">cat test | while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;Line $count: $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo ”finish read the file&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# vim test</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">Line 1: 10</span><br><span class=\"line\">Line 2: 20</span><br><span class=\"line\">Line 3: hello</span><br><span class=\"line\">finish read the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-3-参数标准化\"><a href=\"#1-3-参数标准化\" class=\"headerlink\" title=\"1.3 参数标准化\"></a>1.3 参数标准化</h4><p>在linux世界里，对于传递给shell程序的选项，已经有了某种程序的保准含义。我们在自己编写shell脚本时，也可以参考该标准。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 显示所有对象</span><br><span class=\"line\">-c 生成一个计数器</span><br><span class=\"line\">-d 一定一个目录</span><br><span class=\"line\">-e 扩展一个对象</span><br><span class=\"line\">-f 指定读入数据的文件</span><br><span class=\"line\">-h 显示命令的帮助信息</span><br><span class=\"line\">-i 忽略文本的大小写</span><br><span class=\"line\">-l 显示输出的长格式版本</span><br><span class=\"line\">-n 使用非交互模式</span><br><span class=\"line\">-o 将所有输出重定向到指定的文件</span><br><span class=\"line\">-q 以安静模式运行</span><br><span class=\"line\">-r 递归的处理目录和文件</span><br><span class=\"line\">-s 以安静模式运行</span><br><span class=\"line\">-v 生成详细输出</span><br><span class=\"line\">-x 排除某个对象</span><br><span class=\"line\">-y 对所有问题回答yes</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之shell输出数据","date":"2020-03-21T23:00:00.000Z","_content":"\n讲完了如何处理用户的输入，接下来我在讲讲对应的shell输出数据。\n<!--more-->\n\n#### 1.1 理解输入和输出\n至此你应该已经知道两种显示脚本输出的方式，在屏幕上显示输出或将输出重定向到文件。这两种方式，要么什么都显示出来，要么都不显示。但有时需要将一部分显示到频幕上，另一部分保存到文件。学习了如何处理输入输出后，就能帮助你将脚本输出放到正确的位置。\n\n##### 1.1.1 标准文件描述符\nlinux系统将每个对象都当作文件处理，这包括输入和输出的进程。Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。\n文件描述符      | 缩写  |描述 |对应位置\n--------------  | ----- |-----|----\n0  | STDIN      |标准输入|键盘\n1  | STDOUT     |标准输出|屏幕\n2  | STDERR     |标准错误|屏幕\n*这三个特殊文件描述符会处理脚本的输入和输出。shell用他们将shell默认的输入和输出导向响应的位置。*\n\n#### 1.2 交互式shell输出重新向\n输出重定向，主要是将STDOUT和STDERR的数据重新指向到非默认的位置，下来来几个示例。使用2>将标准错误输出写入到一个文件，使用1>将标准输出写入到另外一个文件。\n\n##### 1.2.1 将STDERR重定向到一个文件\n这个时候如果有标准输出，则会显示在屏幕上。\n```\n[root@aliyun-hk1 linux-shell-test]# ls hello 2> hello.log\n[root@aliyun-hk1 linux-shell-test]# cat hello.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  2> rss1.log\nrs1.out\n[root@aliyun-hk1 linux-shell-test]# cat rss1.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#​\n```\n\n##### 1.2.2 将STDERR和STDOUT的分别重定向到不同的文件\n```\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello 2>hello.log 1>rs1.log\n[root@aliyun-hk1 linux-shell-test]# cat hello.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# cat rs1.log\nrs1.out\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.2.3 将STDERR和STDOUT的重定向到同一个文件\n```\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  &> rss1.log\n[root@aliyun-hk1 linux-shell-test]# cat rss1.log\nls: cannot access hello: No such file or directory\nrs1.out\n```\n\n#### 1.3 shell脚本输出重定向\n默认情况下，shell脚本运行的时候，Linux会将STDERR导向STDOUT，而且会显示在屏幕上。如果运行时重定向了STDERR，脚本中的所有导入STDERR的文本都会被重定向。\n##### 1.3.1 临时重定向\n运行shell脚本时通过传入参数的方式实现。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh\n#!/bin/bash\n\necho \"this is a error\" >&2\necho \"this is a normail output\"\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh\nthis is a error\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh 2> test9\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test9\nthis is a error\n[root@aliyun-hk1 linux-shell-test]#\n```\n*脚本内部临时在需要的位置定义一个标准错误输出，外部调用这个shell脚本的时候，直接使用交互式重定向符号。*\n\n##### 1.3.2 永久重定向\n在shell脚本内部直接实现，可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh\n#!/bin/bash\n\nexec 1>test_stdout\nexec 2>test_stderr\necho \"this is a normail output\"\nls testt\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh\n[root@aliyun-hk1 linux-shell-test]# cat test_stdout\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test_stderr\nls: cannot access testt: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#\n```\n*标准输出被重定向到了test_stdout,标准错误输出重定向到了test_stderr*\n\n#### 1.4 shell脚本输入重定向\n正常情况下，shell脚本会从键盘接收STDINT，通俗地说键盘输入内容会直接到标准输入。如果我们使用了输入重定向后，就会告诉shell不从键盘接收标准输入，而是从文件或者其他地方接收输入。这种操作，其实是Linux系统管理员的一项日常任务，例如从日志中读取数据并处理。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n#read input from file testfile\nexec 0< testfile\ncount=1\n\nwhile read line\ndo\n  echo \"Line number $count is $line\"\n  count=$[ $count + 1]\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nLine number 1 is hello\nLine number 2 is world\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 1.5 shell脚本非标准重定向\nLinux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。我们这里来讲讲如何定义并使用3-8的文件描述符，这个需求有时候可能很迫切，例如程序调试期间。\n##### 1.5.1 创建输出文件描述符\n使用exec命令来给输出分配非标准的描述符，然后在后面重定向某些输出到这个文件描述符即可。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output1.sh\n#!/bin/bash\n\nexec 3>test3out\n\necho \"this is a normail output\"\necho \"this is should been to the file\" >&3\n[root@aliyun-hk1 linux-shell-test]# ./shell-output1.sh\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test3out\nthis is should been to the file\n[root@aliyun-hk1 linux-shell-test]#\n```\n##### 1.5.2 重定向文件描述符\n可能由于业务需求，需要将非标准的文件描述符重定向到标准文件描述符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output2.sh\n#!/bin/bash                                             \n                                                        \nexec 3>&1                                               \nexec 1>test4out                                         \n                                                        \necho \"this is should been to the file\" >&3              \necho \"this is a normail output\"                         \n                                                        \nexec 1>&3                                               \necho \"this is from 1\"                                   \n[root@aliyun-hk1 linux-shell-test]# ./shell-output2.sh  \nthis is should been to the file                         \nthis is from 1                                          \n[root@aliyun-hk1 linux-shell-test]# cat test4out        \nthis is a normail output                                \n[root@aliyun-hk1 linux-shell-test]#                     \n```\n*第一个exec将文件描述符3重定向到了文件描述符1，但是文件描述符1的默认输出位置是屏幕。第二个exec将文件描述符1重定向到文件，所以文件描述符1的内容就不会在显示屏上打印了，但是文件描述符3仍然指向文件描述符1原来的位置，也就是显示器。第三个exec又将文件描述符1重定向到文件描述符3，即也是输出到屏幕。每种文件描述符本身可以重定向，重定向以后一直有效，除非再次重定向。*\n\n重定向文件描述符，除了在shell脚本内部可以实现，在shell脚本运行的时候，也可以通过参数方式修改。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output3.sh\n#!/bin/bash\n\necho \"this is should been to the file\" >&3\necho \"this is should been to the file2\" >&2\necho \"this is a normail output\"\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3>&1 2>&1\nthis is should been to the file\nthis is should been to the file2\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3>&1>>shellout10 2>&1>shellout10\nthis is should been to the file\n[root@aliyun-hk1 linux-shell-test]# cat shellout10\nthis is a normail output\ne file2\n[root@aliyun-hk1 linux-shell-test]#\n```\n*这样的参数，只是修改了文件描述符3和文件描述符2的输出方式，文件描述符1的输出方式继续保持。*\n\n##### 1.5.3 创建输入文件描述符\n我们可以用和重定向输出文件描述符同样的办法，重新向输入文件描述符。重定向之前，可以先将STDIN文件描述符保存到另外一个自定义的文件描述符，然后在读完文件后再将STDIN恢复到它原来的位置。\n\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n#read input from file testfile\n\nexec 6<&0\nexec 0<testfile\n\ncount=1\nwhile read line\ndo\n  echo \"line $count is $line\"\n  count=$[ $count + 1 ]\ndone\n\nexec 0<&6\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nline 1 is hello\nline 2 is world\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n#### 1.6 阻止命令输出\n有时候可能不想显示脚本的任何输出，可以将STDERR重定向到一个叫做/dev/null的文件。\n```\n[root@aliyun-hk1 linux-shell-test]# ls -alt > /dev/null\n[root@aliyun-hk1 linux-shell-test]# cat /dev/null\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n有时候想快速清空一个很大的日志文件，可以在输出重定向中，将/dev/null以覆盖的方式输出到某个文件，由于/dev/null是空的，所以文件会被清空。\n```\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# cat /dev/null > testfile\n[root@aliyun-hk1 linux-shell-test]# cat testfile\n[root@aliyun-hk1 linux-shell-test]#\n```\n更加简单快速清空文件的办法。\n```\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\nnihao\nzhongguo\n[root@aliyun-hk1 linux-shell-test]# >testfile\n[root@aliyun-hk1 linux-shell-test]# cat testfile\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n#### 1.7 使用tee命令同时多出输出\n有时候你想在显示器显示log，也想让文件保存下，你不用将输出重定向两次，只要使用特殊的命令tee即可。\n```\n默认是覆盖写入文件\n[root@aliyun-hk1 linux-shell-test]# date| tee testfile\nMon Mar 23 23:42:53 CST 2020\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nMon Mar 23 23:42:53 CST 2020\n[root@aliyun-hk1 linux-shell-test]#\n\n使用非默认的追加写入\n[root@aliyun-hk1 linux-shell-test]# date| tee -a testfile\nMon Mar 23 23:43:51 CST 2020\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nMon Mar 23 23:42:53 CST 2020\nMon Mar 23 23:43:51 CST 2020\n[root@aliyun-hk1 linux-shell-test]#\n```","source":"_posts/linux/linux_shell_output.md","raw":"---\ntitle: Linux之shell输出数据\ndate: 2020-03-21 23:00:00\ntags: shell\ncategories: linux\n---\n\n讲完了如何处理用户的输入，接下来我在讲讲对应的shell输出数据。\n<!--more-->\n\n#### 1.1 理解输入和输出\n至此你应该已经知道两种显示脚本输出的方式，在屏幕上显示输出或将输出重定向到文件。这两种方式，要么什么都显示出来，要么都不显示。但有时需要将一部分显示到频幕上，另一部分保存到文件。学习了如何处理输入输出后，就能帮助你将脚本输出放到正确的位置。\n\n##### 1.1.1 标准文件描述符\nlinux系统将每个对象都当作文件处理，这包括输入和输出的进程。Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。\n文件描述符      | 缩写  |描述 |对应位置\n--------------  | ----- |-----|----\n0  | STDIN      |标准输入|键盘\n1  | STDOUT     |标准输出|屏幕\n2  | STDERR     |标准错误|屏幕\n*这三个特殊文件描述符会处理脚本的输入和输出。shell用他们将shell默认的输入和输出导向响应的位置。*\n\n#### 1.2 交互式shell输出重新向\n输出重定向，主要是将STDOUT和STDERR的数据重新指向到非默认的位置，下来来几个示例。使用2>将标准错误输出写入到一个文件，使用1>将标准输出写入到另外一个文件。\n\n##### 1.2.1 将STDERR重定向到一个文件\n这个时候如果有标准输出，则会显示在屏幕上。\n```\n[root@aliyun-hk1 linux-shell-test]# ls hello 2> hello.log\n[root@aliyun-hk1 linux-shell-test]# cat hello.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  2> rss1.log\nrs1.out\n[root@aliyun-hk1 linux-shell-test]# cat rss1.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#​\n```\n\n##### 1.2.2 将STDERR和STDOUT的分别重定向到不同的文件\n```\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello 2>hello.log 1>rs1.log\n[root@aliyun-hk1 linux-shell-test]# cat hello.log\nls: cannot access hello: No such file or directory\n[root@aliyun-hk1 linux-shell-test]# cat rs1.log\nrs1.out\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 1.2.3 将STDERR和STDOUT的重定向到同一个文件\n```\n[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  &> rss1.log\n[root@aliyun-hk1 linux-shell-test]# cat rss1.log\nls: cannot access hello: No such file or directory\nrs1.out\n```\n\n#### 1.3 shell脚本输出重定向\n默认情况下，shell脚本运行的时候，Linux会将STDERR导向STDOUT，而且会显示在屏幕上。如果运行时重定向了STDERR，脚本中的所有导入STDERR的文本都会被重定向。\n##### 1.3.1 临时重定向\n运行shell脚本时通过传入参数的方式实现。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh\n#!/bin/bash\n\necho \"this is a error\" >&2\necho \"this is a normail output\"\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh\nthis is a error\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh 2> test9\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test9\nthis is a error\n[root@aliyun-hk1 linux-shell-test]#\n```\n*脚本内部临时在需要的位置定义一个标准错误输出，外部调用这个shell脚本的时候，直接使用交互式重定向符号。*\n\n##### 1.3.2 永久重定向\n在shell脚本内部直接实现，可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh\n#!/bin/bash\n\nexec 1>test_stdout\nexec 2>test_stderr\necho \"this is a normail output\"\nls testt\n[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh\n[root@aliyun-hk1 linux-shell-test]# cat test_stdout\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test_stderr\nls: cannot access testt: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#\n```\n*标准输出被重定向到了test_stdout,标准错误输出重定向到了test_stderr*\n\n#### 1.4 shell脚本输入重定向\n正常情况下，shell脚本会从键盘接收STDINT，通俗地说键盘输入内容会直接到标准输入。如果我们使用了输入重定向后，就会告诉shell不从键盘接收标准输入，而是从文件或者其他地方接收输入。这种操作，其实是Linux系统管理员的一项日常任务，例如从日志中读取数据并处理。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n#read input from file testfile\nexec 0< testfile\ncount=1\n\nwhile read line\ndo\n  echo \"Line number $count is $line\"\n  count=$[ $count + 1]\ndone\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nLine number 1 is hello\nLine number 2 is world\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### 1.5 shell脚本非标准重定向\nLinux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。我们这里来讲讲如何定义并使用3-8的文件描述符，这个需求有时候可能很迫切，例如程序调试期间。\n##### 1.5.1 创建输出文件描述符\n使用exec命令来给输出分配非标准的描述符，然后在后面重定向某些输出到这个文件描述符即可。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output1.sh\n#!/bin/bash\n\nexec 3>test3out\n\necho \"this is a normail output\"\necho \"this is should been to the file\" >&3\n[root@aliyun-hk1 linux-shell-test]# ./shell-output1.sh\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# cat test3out\nthis is should been to the file\n[root@aliyun-hk1 linux-shell-test]#\n```\n##### 1.5.2 重定向文件描述符\n可能由于业务需求，需要将非标准的文件描述符重定向到标准文件描述符。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output2.sh\n#!/bin/bash                                             \n                                                        \nexec 3>&1                                               \nexec 1>test4out                                         \n                                                        \necho \"this is should been to the file\" >&3              \necho \"this is a normail output\"                         \n                                                        \nexec 1>&3                                               \necho \"this is from 1\"                                   \n[root@aliyun-hk1 linux-shell-test]# ./shell-output2.sh  \nthis is should been to the file                         \nthis is from 1                                          \n[root@aliyun-hk1 linux-shell-test]# cat test4out        \nthis is a normail output                                \n[root@aliyun-hk1 linux-shell-test]#                     \n```\n*第一个exec将文件描述符3重定向到了文件描述符1，但是文件描述符1的默认输出位置是屏幕。第二个exec将文件描述符1重定向到文件，所以文件描述符1的内容就不会在显示屏上打印了，但是文件描述符3仍然指向文件描述符1原来的位置，也就是显示器。第三个exec又将文件描述符1重定向到文件描述符3，即也是输出到屏幕。每种文件描述符本身可以重定向，重定向以后一直有效，除非再次重定向。*\n\n重定向文件描述符，除了在shell脚本内部可以实现，在shell脚本运行的时候，也可以通过参数方式修改。\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-output3.sh\n#!/bin/bash\n\necho \"this is should been to the file\" >&3\necho \"this is should been to the file2\" >&2\necho \"this is a normail output\"\n\n[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3>&1 2>&1\nthis is should been to the file\nthis is should been to the file2\nthis is a normail output\n[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3>&1>>shellout10 2>&1>shellout10\nthis is should been to the file\n[root@aliyun-hk1 linux-shell-test]# cat shellout10\nthis is a normail output\ne file2\n[root@aliyun-hk1 linux-shell-test]#\n```\n*这样的参数，只是修改了文件描述符3和文件描述符2的输出方式，文件描述符1的输出方式继续保持。*\n\n##### 1.5.3 创建输入文件描述符\n我们可以用和重定向输出文件描述符同样的办法，重新向输入文件描述符。重定向之前，可以先将STDIN文件描述符保存到另外一个自定义的文件描述符，然后在读完文件后再将STDIN恢复到它原来的位置。\n\n```\n[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh\n#!/bin/bash\n#read input from file testfile\n\nexec 6<&0\nexec 0<testfile\n\ncount=1\nwhile read line\ndo\n  echo \"line $count is $line\"\n  count=$[ $count + 1 ]\ndone\n\nexec 0<&6\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh\nline 1 is hello\nline 2 is world\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n#### 1.6 阻止命令输出\n有时候可能不想显示脚本的任何输出，可以将STDERR重定向到一个叫做/dev/null的文件。\n```\n[root@aliyun-hk1 linux-shell-test]# ls -alt > /dev/null\n[root@aliyun-hk1 linux-shell-test]# cat /dev/null\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n有时候想快速清空一个很大的日志文件，可以在输出重定向中，将/dev/null以覆盖的方式输出到某个文件，由于/dev/null是空的，所以文件会被清空。\n```\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\n[root@aliyun-hk1 linux-shell-test]# cat /dev/null > testfile\n[root@aliyun-hk1 linux-shell-test]# cat testfile\n[root@aliyun-hk1 linux-shell-test]#\n```\n更加简单快速清空文件的办法。\n```\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nhello\nworld\nnihao\nzhongguo\n[root@aliyun-hk1 linux-shell-test]# >testfile\n[root@aliyun-hk1 linux-shell-test]# cat testfile\n[root@aliyun-hk1 linux-shell-test]#\n\n```\n\n#### 1.7 使用tee命令同时多出输出\n有时候你想在显示器显示log，也想让文件保存下，你不用将输出重定向两次，只要使用特殊的命令tee即可。\n```\n默认是覆盖写入文件\n[root@aliyun-hk1 linux-shell-test]# date| tee testfile\nMon Mar 23 23:42:53 CST 2020\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nMon Mar 23 23:42:53 CST 2020\n[root@aliyun-hk1 linux-shell-test]#\n\n使用非默认的追加写入\n[root@aliyun-hk1 linux-shell-test]# date| tee -a testfile\nMon Mar 23 23:43:51 CST 2020\n[root@aliyun-hk1 linux-shell-test]# cat testfile\nMon Mar 23 23:42:53 CST 2020\nMon Mar 23 23:43:51 CST 2020\n[root@aliyun-hk1 linux-shell-test]#\n```","slug":"linux/linux_shell_output","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdetg004c0en7iwtua6ty","content":"<p>讲完了如何处理用户的输入，接下来我在讲讲对应的shell输出数据。<br><a id=\"more\"></a></p>\n<h4 id=\"1-1-理解输入和输出\"><a href=\"#1-1-理解输入和输出\" class=\"headerlink\" title=\"1.1 理解输入和输出\"></a>1.1 理解输入和输出</h4><p>至此你应该已经知道两种显示脚本输出的方式，在屏幕上显示输出或将输出重定向到文件。这两种方式，要么什么都显示出来，要么都不显示。但有时需要将一部分显示到频幕上，另一部分保存到文件。学习了如何处理输入输出后，就能帮助你将脚本输出放到正确的位置。</p>\n<h5 id=\"1-1-1-标准文件描述符\"><a href=\"#1-1-1-标准文件描述符\" class=\"headerlink\" title=\"1.1.1 标准文件描述符\"></a>1.1.1 标准文件描述符</h5><p>linux系统将每个对象都当作文件处理，这包括输入和输出的进程。Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。<br>文件描述符      | 缩写  |描述 |对应位置<br>————–  | —– |—–|—-<br>0  | STDIN      |标准输入|键盘<br>1  | STDOUT     |标准输出|屏幕<br>2  | STDERR     |标准错误|屏幕<br><em>这三个特殊文件描述符会处理脚本的输入和输出。shell用他们将shell默认的输入和输出导向响应的位置。</em></p>\n<h4 id=\"1-2-交互式shell输出重新向\"><a href=\"#1-2-交互式shell输出重新向\" class=\"headerlink\" title=\"1.2 交互式shell输出重新向\"></a>1.2 交互式shell输出重新向</h4><p>输出重定向，主要是将STDOUT和STDERR的数据重新指向到非默认的位置，下来来几个示例。使用2&gt;将标准错误输出写入到一个文件，使用1&gt;将标准输出写入到另外一个文件。</p>\n<h5 id=\"1-2-1-将STDERR重定向到一个文件\"><a href=\"#1-2-1-将STDERR重定向到一个文件\" class=\"headerlink\" title=\"1.2.1 将STDERR重定向到一个文件\"></a>1.2.1 将STDERR重定向到一个文件</h5><p>这个时候如果有标准输出，则会显示在屏幕上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls hello 2&gt; hello.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  2&gt; rss1.log</span><br><span class=\"line\">rs1.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rss1.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#​</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-2-将STDERR和STDOUT的分别重定向到不同的文件\"><a href=\"#1-2-2-将STDERR和STDOUT的分别重定向到不同的文件\" class=\"headerlink\" title=\"1.2.2 将STDERR和STDOUT的分别重定向到不同的文件\"></a>1.2.2 将STDERR和STDOUT的分别重定向到不同的文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello 2&gt;hello.log 1&gt;rs1.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs1.log</span><br><span class=\"line\">rs1.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-3-将STDERR和STDOUT的重定向到同一个文件\"><a href=\"#1-2-3-将STDERR和STDOUT的重定向到同一个文件\" class=\"headerlink\" title=\"1.2.3 将STDERR和STDOUT的重定向到同一个文件\"></a>1.2.3 将STDERR和STDOUT的重定向到同一个文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  &amp;&gt; rss1.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rss1.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">rs1.out</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-shell脚本输出重定向\"><a href=\"#1-3-shell脚本输出重定向\" class=\"headerlink\" title=\"1.3 shell脚本输出重定向\"></a>1.3 shell脚本输出重定向</h4><p>默认情况下，shell脚本运行的时候，Linux会将STDERR导向STDOUT，而且会显示在屏幕上。如果运行时重定向了STDERR，脚本中的所有导入STDERR的文本都会被重定向。</p>\n<h5 id=\"1-3-1-临时重定向\"><a href=\"#1-3-1-临时重定向\" class=\"headerlink\" title=\"1.3.1 临时重定向\"></a>1.3.1 临时重定向</h5><p>运行shell脚本时通过传入参数的方式实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is a error&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh</span><br><span class=\"line\">this is a error</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh 2&gt; test9</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test9</span><br><span class=\"line\">this is a error</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>脚本内部临时在需要的位置定义一个标准错误输出，外部调用这个shell脚本的时候，直接使用交互式重定向符号。</em></p>\n<h5 id=\"1-3-2-永久重定向\"><a href=\"#1-3-2-永久重定向\" class=\"headerlink\" title=\"1.3.2 永久重定向\"></a>1.3.2 永久重定向</h5><p>在shell脚本内部直接实现，可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;test_stdout</span><br><span class=\"line\">exec 2&gt;test_stderr</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">ls testt</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_stdout</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_stderr</span><br><span class=\"line\">ls: cannot access testt: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>标准输出被重定向到了test_stdout,标准错误输出重定向到了test_stderr</em></p>\n<h4 id=\"1-4-shell脚本输入重定向\"><a href=\"#1-4-shell脚本输入重定向\" class=\"headerlink\" title=\"1.4 shell脚本输入重定向\"></a>1.4 shell脚本输入重定向</h4><p>正常情况下，shell脚本会从键盘接收STDINT，通俗地说键盘输入内容会直接到标准输入。如果我们使用了输入重定向后，就会告诉shell不从键盘接收标准输入，而是从文件或者其他地方接收输入。这种操作，其实是Linux系统管理员的一项日常任务，例如从日志中读取数据并处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#read input from file testfile</span><br><span class=\"line\">exec 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"></span><br><span class=\"line\">while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;Line number $count is $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">Line number 1 is hello</span><br><span class=\"line\">Line number 2 is world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-shell脚本非标准重定向\"><a href=\"#1-5-shell脚本非标准重定向\" class=\"headerlink\" title=\"1.5 shell脚本非标准重定向\"></a>1.5 shell脚本非标准重定向</h4><p>Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。我们这里来讲讲如何定义并使用3-8的文件描述符，这个需求有时候可能很迫切，例如程序调试期间。</p>\n<h5 id=\"1-5-1-创建输出文件描述符\"><a href=\"#1-5-1-创建输出文件描述符\" class=\"headerlink\" title=\"1.5.1 创建输出文件描述符\"></a>1.5.1 创建输出文件描述符</h5><p>使用exec命令来给输出分配非标准的描述符，然后在后面重定向某些输出到这个文件描述符即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output1.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;test3out</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output1.sh</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test3out</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-5-2-重定向文件描述符\"><a href=\"#1-5-2-重定向文件描述符\" class=\"headerlink\" title=\"1.5.2 重定向文件描述符\"></a>1.5.2 重定向文件描述符</h5><p>可能由于业务需求，需要将非标准的文件描述符重定向到标准文件描述符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output2.sh</span><br><span class=\"line\">#!/bin/bash                                             </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">exec 3&gt;&amp;1                                               </span><br><span class=\"line\">exec 1&gt;test4out                                         </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3              </span><br><span class=\"line\">echo &quot;this is a normail output&quot;                         </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">exec 1&gt;&amp;3                                               </span><br><span class=\"line\">echo &quot;this is from 1&quot;                                   </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output2.sh  </span><br><span class=\"line\">this is should been to the file                         </span><br><span class=\"line\">this is from 1                                          </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test4out        </span><br><span class=\"line\">this is a normail output                                </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>第一个exec将文件描述符3重定向到了文件描述符1，但是文件描述符1的默认输出位置是屏幕。第二个exec将文件描述符1重定向到文件，所以文件描述符1的内容就不会在显示屏上打印了，但是文件描述符3仍然指向文件描述符1原来的位置，也就是显示器。第三个exec又将文件描述符1重定向到文件描述符3，即也是输出到屏幕。每种文件描述符本身可以重定向，重定向以后一直有效，除非再次重定向。</em></p>\n<p>重定向文件描述符，除了在shell脚本内部可以实现，在shell脚本运行的时候，也可以通过参数方式修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output3.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3</span><br><span class=\"line\">echo &quot;this is should been to the file2&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3&gt;&amp;1 2&gt;&amp;1</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">this is should been to the file2</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3&gt;&amp;1&gt;&gt;shellout10 2&gt;&amp;1&gt;shellout10</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shellout10</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">e file2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>这样的参数，只是修改了文件描述符3和文件描述符2的输出方式，文件描述符1的输出方式继续保持。</em></p>\n<h5 id=\"1-5-3-创建输入文件描述符\"><a href=\"#1-5-3-创建输入文件描述符\" class=\"headerlink\" title=\"1.5.3 创建输入文件描述符\"></a>1.5.3 创建输入文件描述符</h5><p>我们可以用和重定向输出文件描述符同样的办法，重新向输入文件描述符。重定向之前，可以先将STDIN文件描述符保存到另外一个自定义的文件描述符，然后在读完文件后再将STDIN恢复到它原来的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#read input from file testfile</span><br><span class=\"line\"></span><br><span class=\"line\">exec 6&lt;&amp;0</span><br><span class=\"line\">exec 0&lt;testfile</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;line $count is $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">exec 0&lt;&amp;6</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">line 1 is hello</span><br><span class=\"line\">line 2 is world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-6-阻止命令输出\"><a href=\"#1-6-阻止命令输出\" class=\"headerlink\" title=\"1.6 阻止命令输出\"></a>1.6 阻止命令输出</h4><p>有时候可能不想显示脚本的任何输出，可以将STDERR重定向到一个叫做/dev/null的文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls -alt &gt; /dev/null</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /dev/null</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>有时候想快速清空一个很大的日志文件，可以在输出重定向中，将/dev/null以覆盖的方式输出到某个文件，由于/dev/null是空的，所以文件会被清空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /dev/null &gt; testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>更加简单快速清空文件的办法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">nihao</span><br><span class=\"line\">zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# &gt;testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-7-使用tee命令同时多出输出\"><a href=\"#1-7-使用tee命令同时多出输出\" class=\"headerlink\" title=\"1.7 使用tee命令同时多出输出\"></a>1.7 使用tee命令同时多出输出</h4><p>有时候你想在显示器显示log，也想让文件保存下，你不用将输出重定向两次，只要使用特殊的命令tee即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认是覆盖写入文件</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# date| tee testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">使用非默认的追加写入</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# date| tee -a testfile</span><br><span class=\"line\">Mon Mar 23 23:43:51 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">Mon Mar 23 23:43:51 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>讲完了如何处理用户的输入，接下来我在讲讲对应的shell输出数据。<br>","more":"</p>\n<h4 id=\"1-1-理解输入和输出\"><a href=\"#1-1-理解输入和输出\" class=\"headerlink\" title=\"1.1 理解输入和输出\"></a>1.1 理解输入和输出</h4><p>至此你应该已经知道两种显示脚本输出的方式，在屏幕上显示输出或将输出重定向到文件。这两种方式，要么什么都显示出来，要么都不显示。但有时需要将一部分显示到频幕上，另一部分保存到文件。学习了如何处理输入输出后，就能帮助你将脚本输出放到正确的位置。</p>\n<h5 id=\"1-1-1-标准文件描述符\"><a href=\"#1-1-1-标准文件描述符\" class=\"headerlink\" title=\"1.1.1 标准文件描述符\"></a>1.1.1 标准文件描述符</h5><p>linux系统将每个对象都当作文件处理，这包括输入和输出的进程。Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。<br>文件描述符      | 缩写  |描述 |对应位置<br>————–  | —– |—–|—-<br>0  | STDIN      |标准输入|键盘<br>1  | STDOUT     |标准输出|屏幕<br>2  | STDERR     |标准错误|屏幕<br><em>这三个特殊文件描述符会处理脚本的输入和输出。shell用他们将shell默认的输入和输出导向响应的位置。</em></p>\n<h4 id=\"1-2-交互式shell输出重新向\"><a href=\"#1-2-交互式shell输出重新向\" class=\"headerlink\" title=\"1.2 交互式shell输出重新向\"></a>1.2 交互式shell输出重新向</h4><p>输出重定向，主要是将STDOUT和STDERR的数据重新指向到非默认的位置，下来来几个示例。使用2&gt;将标准错误输出写入到一个文件，使用1&gt;将标准输出写入到另外一个文件。</p>\n<h5 id=\"1-2-1-将STDERR重定向到一个文件\"><a href=\"#1-2-1-将STDERR重定向到一个文件\" class=\"headerlink\" title=\"1.2.1 将STDERR重定向到一个文件\"></a>1.2.1 将STDERR重定向到一个文件</h5><p>这个时候如果有标准输出，则会显示在屏幕上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls hello 2&gt; hello.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  2&gt; rss1.log</span><br><span class=\"line\">rs1.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rss1.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#​</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-2-2-将STDERR和STDOUT的分别重定向到不同的文件\"><a href=\"#1-2-2-将STDERR和STDOUT的分别重定向到不同的文件\" class=\"headerlink\" title=\"1.2.2 将STDERR和STDOUT的分别重定向到不同的文件\"></a>1.2.2 将STDERR和STDOUT的分别重定向到不同的文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello 2&gt;hello.log 1&gt;rs1.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat hello.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs1.log</span><br><span class=\"line\">rs1.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-2-3-将STDERR和STDOUT的重定向到同一个文件\"><a href=\"#1-2-3-将STDERR和STDOUT的重定向到同一个文件\" class=\"headerlink\" title=\"1.2.3 将STDERR和STDOUT的重定向到同一个文件\"></a>1.2.3 将STDERR和STDOUT的重定向到同一个文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls rs1.out hello  &amp;&gt; rss1.log</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rss1.log</span><br><span class=\"line\">ls: cannot access hello: No such file or directory</span><br><span class=\"line\">rs1.out</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-shell脚本输出重定向\"><a href=\"#1-3-shell脚本输出重定向\" class=\"headerlink\" title=\"1.3 shell脚本输出重定向\"></a>1.3 shell脚本输出重定向</h4><p>默认情况下，shell脚本运行的时候，Linux会将STDERR导向STDOUT，而且会显示在屏幕上。如果运行时重定向了STDERR，脚本中的所有导入STDERR的文本都会被重定向。</p>\n<h5 id=\"1-3-1-临时重定向\"><a href=\"#1-3-1-临时重定向\" class=\"headerlink\" title=\"1.3.1 临时重定向\"></a>1.3.1 临时重定向</h5><p>运行shell脚本时通过传入参数的方式实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is a error&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh</span><br><span class=\"line\">this is a error</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh 2&gt; test9</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test9</span><br><span class=\"line\">this is a error</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>脚本内部临时在需要的位置定义一个标准错误输出，外部调用这个shell脚本的时候，直接使用交互式重定向符号。</em></p>\n<h5 id=\"1-3-2-永久重定向\"><a href=\"#1-3-2-永久重定向\" class=\"headerlink\" title=\"1.3.2 永久重定向\"></a>1.3.2 永久重定向</h5><p>在shell脚本内部直接实现，可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;test_stdout</span><br><span class=\"line\">exec 2&gt;test_stderr</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">ls testt</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output.sh</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_stdout</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_stderr</span><br><span class=\"line\">ls: cannot access testt: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>标准输出被重定向到了test_stdout,标准错误输出重定向到了test_stderr</em></p>\n<h4 id=\"1-4-shell脚本输入重定向\"><a href=\"#1-4-shell脚本输入重定向\" class=\"headerlink\" title=\"1.4 shell脚本输入重定向\"></a>1.4 shell脚本输入重定向</h4><p>正常情况下，shell脚本会从键盘接收STDINT，通俗地说键盘输入内容会直接到标准输入。如果我们使用了输入重定向后，就会告诉shell不从键盘接收标准输入，而是从文件或者其他地方接收输入。这种操作，其实是Linux系统管理员的一项日常任务，例如从日志中读取数据并处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#read input from file testfile</span><br><span class=\"line\">exec 0&lt; testfile</span><br><span class=\"line\">count=1</span><br><span class=\"line\"></span><br><span class=\"line\">while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;Line number $count is $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">Line number 1 is hello</span><br><span class=\"line\">Line number 2 is world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-shell脚本非标准重定向\"><a href=\"#1-5-shell脚本非标准重定向\" class=\"headerlink\" title=\"1.5 shell脚本非标准重定向\"></a>1.5 shell脚本非标准重定向</h4><p>Linux系统本来支持9中文件描述符，出于特殊目的，bash shell只保留了前3个文件描述符(0,1,2)。我们这里来讲讲如何定义并使用3-8的文件描述符，这个需求有时候可能很迫切，例如程序调试期间。</p>\n<h5 id=\"1-5-1-创建输出文件描述符\"><a href=\"#1-5-1-创建输出文件描述符\" class=\"headerlink\" title=\"1.5.1 创建输出文件描述符\"></a>1.5.1 创建输出文件描述符</h5><p>使用exec命令来给输出分配非标准的描述符，然后在后面重定向某些输出到这个文件描述符即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output1.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;test3out</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output1.sh</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test3out</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"1-5-2-重定向文件描述符\"><a href=\"#1-5-2-重定向文件描述符\" class=\"headerlink\" title=\"1.5.2 重定向文件描述符\"></a>1.5.2 重定向文件描述符</h5><p>可能由于业务需求，需要将非标准的文件描述符重定向到标准文件描述符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output2.sh</span><br><span class=\"line\">#!/bin/bash                                             </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">exec 3&gt;&amp;1                                               </span><br><span class=\"line\">exec 1&gt;test4out                                         </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3              </span><br><span class=\"line\">echo &quot;this is a normail output&quot;                         </span><br><span class=\"line\">                                                        </span><br><span class=\"line\">exec 1&gt;&amp;3                                               </span><br><span class=\"line\">echo &quot;this is from 1&quot;                                   </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output2.sh  </span><br><span class=\"line\">this is should been to the file                         </span><br><span class=\"line\">this is from 1                                          </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test4out        </span><br><span class=\"line\">this is a normail output                                </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>第一个exec将文件描述符3重定向到了文件描述符1，但是文件描述符1的默认输出位置是屏幕。第二个exec将文件描述符1重定向到文件，所以文件描述符1的内容就不会在显示屏上打印了，但是文件描述符3仍然指向文件描述符1原来的位置，也就是显示器。第三个exec又将文件描述符1重定向到文件描述符3，即也是输出到屏幕。每种文件描述符本身可以重定向，重定向以后一直有效，除非再次重定向。</em></p>\n<p>重定向文件描述符，除了在shell脚本内部可以实现，在shell脚本运行的时候，也可以通过参数方式修改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-output3.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;this is should been to the file&quot; &gt;&amp;3</span><br><span class=\"line\">echo &quot;this is should been to the file2&quot; &gt;&amp;2</span><br><span class=\"line\">echo &quot;this is a normail output&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3&gt;&amp;1 2&gt;&amp;1</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">this is should been to the file2</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-output3.sh 3&gt;&amp;1&gt;&gt;shellout10 2&gt;&amp;1&gt;shellout10</span><br><span class=\"line\">this is should been to the file</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shellout10</span><br><span class=\"line\">this is a normail output</span><br><span class=\"line\">e file2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><em>这样的参数，只是修改了文件描述符3和文件描述符2的输出方式，文件描述符1的输出方式继续保持。</em></p>\n<h5 id=\"1-5-3-创建输入文件描述符\"><a href=\"#1-5-3-创建输入文件描述符\" class=\"headerlink\" title=\"1.5.3 创建输入文件描述符\"></a>1.5.3 创建输入文件描述符</h5><p>我们可以用和重定向输出文件描述符同样的办法，重新向输入文件描述符。重定向之前，可以先将STDIN文件描述符保存到另外一个自定义的文件描述符，然后在读完文件后再将STDIN恢复到它原来的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat shell-input.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#read input from file testfile</span><br><span class=\"line\"></span><br><span class=\"line\">exec 6&lt;&amp;0</span><br><span class=\"line\">exec 0&lt;testfile</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo &quot;line $count is $line&quot;</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">exec 0&lt;&amp;6</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./shell-input.sh</span><br><span class=\"line\">line 1 is hello</span><br><span class=\"line\">line 2 is world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-6-阻止命令输出\"><a href=\"#1-6-阻止命令输出\" class=\"headerlink\" title=\"1.6 阻止命令输出\"></a>1.6 阻止命令输出</h4><p>有时候可能不想显示脚本的任何输出，可以将STDERR重定向到一个叫做/dev/null的文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ls -alt &gt; /dev/null</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /dev/null</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>有时候想快速清空一个很大的日志文件，可以在输出重定向中，将/dev/null以覆盖的方式输出到某个文件，由于/dev/null是空的，所以文件会被清空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat /dev/null &gt; testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>更加简单快速清空文件的办法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br><span class=\"line\">nihao</span><br><span class=\"line\">zhongguo</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# &gt;testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-7-使用tee命令同时多出输出\"><a href=\"#1-7-使用tee命令同时多出输出\" class=\"headerlink\" title=\"1.7 使用tee命令同时多出输出\"></a>1.7 使用tee命令同时多出输出</h4><p>有时候你想在显示器显示log，也想让文件保存下，你不用将输出重定向两次，只要使用特殊的命令tee即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认是覆盖写入文件</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# date| tee testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">使用非默认的追加写入</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# date| tee -a testfile</span><br><span class=\"line\">Mon Mar 23 23:43:51 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat testfile</span><br><span class=\"line\">Mon Mar 23 23:42:53 CST 2020</span><br><span class=\"line\">Mon Mar 23 23:43:51 CST 2020</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>"},{"title":"Linux之shell输入输出重定向","date":"2020-03-15T16:25:25.000Z","_content":"\n之前我们讲解shell的变量、环境变量以及各种命令的时候，命令执行结果输出每次都是显示到屏幕上给用户看，其实还有更多的方式。今天我们就专门讲讲输入和输出重定向。\n<!--more-->\n\n#### 输出重定向\n##### 将命令的标准输出写入文件或黑洞/dev/null\n可以使用>或1>将一个命令的输出**覆盖写入到一个文件**，如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被完全覆盖。\n```\n[root@aliyun-hk1 linux-shell-test]# echo 'hello world' > rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\n[root@aliyun-hk1 linux-shell-test]# echo 'hello world' 1> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n可以使用>>或1>>将一个命令的输出**追加写入到一个文件**,如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被追加过去。\n```\n[root@aliyun-hk1 linux-shell-test]# echo 'hello china' >> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# echo 'hello china' 1>> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\nhello china\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 将命令的标准错误输出写入文件或黑洞/dev/null\n使用 2> 和 2>> 将命令的标准错误输出覆盖写入或追加写入到一个文件,如果命令执行无错误，则输出空字符到文件。\n```\n[root@aliyun-hk1 linux-shell-test]# cat he1.out 2>> rs3.out\n[root@aliyun-hk1 linux-shell-test]# cat rs3.out\ncat: he1.out: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#\n\n[root@aliyun-hk1 linux-shell-test]# cat rs.out 2>> rs4.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# cat rs4.out\n[root@aliyun-hk1 linux-shell-test]#\n[root@aliyun-hk1 linux-shell-test]# echo 'hello' 2> rs.out\nhello\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\n```\n\n#### 输入重定向\n##### 将文件的内容重定向到命令\n可以使用<或0<将一个文件的内容输入到一个命令,此例是将一个文件的内容传递给wc，然后计算文件中字符的行数。\n```\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# wc -l < rs.out\n2\n[root@aliyun-hk1 linux-shell-test]# wc -l 0< rs.out\n2\n```\n\n可以使用<<实现内联输入重定向，不需要通过文件，你只要指定结束符，逐个手动输入数据就可以了。\n```\n[root@aliyun-hk1 linux-shell-test]# wc -l << \"eof\"\n> hell\n> world\n> hi\n> hao\n> eof\n4\n```\n\n#### 输入输出总结\n```\n标准输入(stdin): 代码为0，使用<或<<\n标准输出(stdout): 代码为1，使用>或>>\n标准错误输出(stdout):代码为2,使用2>或2>>\n全部输出到一个文件，使用2>&1\n```\n\n#### shell输出回传码\n用户每次在shell中执行一个命令，shell都会回传一个状态码，0或1，可以通过echo $?获取，0代表执行成功，非0代表执行失败。\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\nhello\n[root@aliyun-hk1 linux-shell-test]# echo $?\n0\n[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n[root@aliyun-hk1 linux-shell-test]# echo $?\n0\n[root@aliyun-hk1 linux-shell-test]# name=robin li\n-bash: li: command not found\n[root@aliyun-hk1 linux-shell-test]# echo $?\n127\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### Linux常见的退出状态码\n```\n0 命令成功退出\n1 一般性未知错误\n2 不适合的shell命令\n126 命令不可执行\n127 没找到命令\n128 无效的退出参数\n130 通过CTRL+C终止的命令\n255 正常范围之外的退出状态码\n```\n\n\n","source":"_posts/linux/linux_shell_output_input.md","raw":"---\ntitle: Linux之shell输入输出重定向\ndate: 2020-03-15 16:25:25\ntags: shell\ncategories: linux\n---\n\n之前我们讲解shell的变量、环境变量以及各种命令的时候，命令执行结果输出每次都是显示到屏幕上给用户看，其实还有更多的方式。今天我们就专门讲讲输入和输出重定向。\n<!--more-->\n\n#### 输出重定向\n##### 将命令的标准输出写入文件或黑洞/dev/null\n可以使用>或1>将一个命令的输出**覆盖写入到一个文件**，如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被完全覆盖。\n```\n[root@aliyun-hk1 linux-shell-test]# echo 'hello world' > rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\n[root@aliyun-hk1 linux-shell-test]# echo 'hello world' 1> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n可以使用>>或1>>将一个命令的输出**追加写入到一个文件**,如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被追加过去。\n```\n[root@aliyun-hk1 linux-shell-test]# echo 'hello china' >> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# echo 'hello china' 1>> rs.out\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\nhello china\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n##### 将命令的标准错误输出写入文件或黑洞/dev/null\n使用 2> 和 2>> 将命令的标准错误输出覆盖写入或追加写入到一个文件,如果命令执行无错误，则输出空字符到文件。\n```\n[root@aliyun-hk1 linux-shell-test]# cat he1.out 2>> rs3.out\n[root@aliyun-hk1 linux-shell-test]# cat rs3.out\ncat: he1.out: No such file or directory\n[root@aliyun-hk1 linux-shell-test]#\n\n[root@aliyun-hk1 linux-shell-test]# cat rs.out 2>> rs4.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# cat rs4.out\n[root@aliyun-hk1 linux-shell-test]#\n[root@aliyun-hk1 linux-shell-test]# echo 'hello' 2> rs.out\nhello\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\n```\n\n#### 输入重定向\n##### 将文件的内容重定向到命令\n可以使用<或0<将一个文件的内容输入到一个命令,此例是将一个文件的内容传递给wc，然后计算文件中字符的行数。\n```\n[root@aliyun-hk1 linux-shell-test]# cat rs.out\nhello world\nhello china\n[root@aliyun-hk1 linux-shell-test]# wc -l < rs.out\n2\n[root@aliyun-hk1 linux-shell-test]# wc -l 0< rs.out\n2\n```\n\n可以使用<<实现内联输入重定向，不需要通过文件，你只要指定结束符，逐个手动输入数据就可以了。\n```\n[root@aliyun-hk1 linux-shell-test]# wc -l << \"eof\"\n> hell\n> world\n> hi\n> hao\n> eof\n4\n```\n\n#### 输入输出总结\n```\n标准输入(stdin): 代码为0，使用<或<<\n标准输出(stdout): 代码为1，使用>或>>\n标准错误输出(stdout):代码为2,使用2>或2>>\n全部输出到一个文件，使用2>&1\n```\n\n#### shell输出回传码\n用户每次在shell中执行一个命令，shell都会回传一个状态码，0或1，可以通过echo $?获取，0代表执行成功，非0代表执行失败。\n```\n[root@aliyun-hk1 linux-shell-test]# echo hello\nhello\n[root@aliyun-hk1 linux-shell-test]# echo $?\n0\n[root@aliyun-hk1 linux-shell-test]# echo hello world\nhello world\n[root@aliyun-hk1 linux-shell-test]# echo $?\n0\n[root@aliyun-hk1 linux-shell-test]# name=robin li\n-bash: li: command not found\n[root@aliyun-hk1 linux-shell-test]# echo $?\n127\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n#### Linux常见的退出状态码\n```\n0 命令成功退出\n1 一般性未知错误\n2 不适合的shell命令\n126 命令不可执行\n127 没找到命令\n128 无效的退出参数\n130 通过CTRL+C终止的命令\n255 正常范围之外的退出状态码\n```\n\n\n","slug":"linux/linux_shell_output_input","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeti004g0en70jxx22l1","content":"<p>之前我们讲解shell的变量、环境变量以及各种命令的时候，命令执行结果输出每次都是显示到屏幕上给用户看，其实还有更多的方式。今天我们就专门讲讲输入和输出重定向。<br><a id=\"more\"></a></p>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><h5 id=\"将命令的标准输出写入文件或黑洞-dev-null\"><a href=\"#将命令的标准输出写入文件或黑洞-dev-null\" class=\"headerlink\" title=\"将命令的标准输出写入文件或黑洞/dev/null\"></a>将命令的标准输出写入文件或黑洞/dev/null</h5><p>可以使用&gt;或1&gt;将一个命令的输出<strong>覆盖写入到一个文件</strong>，如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被完全覆盖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello world&apos; &gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello world&apos; 1&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>可以使用&gt;&gt;或1&gt;&gt;将一个命令的输出<strong>追加写入到一个文件</strong>,如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被追加过去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello china&apos; &gt;&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello china&apos; 1&gt;&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"将命令的标准错误输出写入文件或黑洞-dev-null\"><a href=\"#将命令的标准错误输出写入文件或黑洞-dev-null\" class=\"headerlink\" title=\"将命令的标准错误输出写入文件或黑洞/dev/null\"></a>将命令的标准错误输出写入文件或黑洞/dev/null</h5><p>使用 2&gt; 和 2&gt;&gt; 将命令的标准错误输出覆盖写入或追加写入到一个文件,如果命令执行无错误，则输出空字符到文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat he1.out 2&gt;&gt; rs3.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs3.out</span><br><span class=\"line\">cat: he1.out: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out 2&gt;&gt; rs4.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs4.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello&apos; 2&gt; rs.out</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h4><h5 id=\"将文件的内容重定向到命令\"><a href=\"#将文件的内容重定向到命令\" class=\"headerlink\" title=\"将文件的内容重定向到命令\"></a>将文件的内容重定向到命令</h5><p>可以使用&lt;或0&lt;将一个文件的内容输入到一个命令,此例是将一个文件的内容传递给wc，然后计算文件中字符的行数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l &lt; rs.out</span><br><span class=\"line\">2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l 0&lt; rs.out</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<p>可以使用&lt;&lt;实现内联输入重定向，不需要通过文件，你只要指定结束符，逐个手动输入数据就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l &lt;&lt; &quot;eof&quot;</span><br><span class=\"line\">&gt; hell</span><br><span class=\"line\">&gt; world</span><br><span class=\"line\">&gt; hi</span><br><span class=\"line\">&gt; hao</span><br><span class=\"line\">&gt; eof</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"输入输出总结\"><a href=\"#输入输出总结\" class=\"headerlink\" title=\"输入输出总结\"></a>输入输出总结</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准输入(stdin): 代码为0，使用&lt;或&lt;&lt;</span><br><span class=\"line\">标准输出(stdout): 代码为1，使用&gt;或&gt;&gt;</span><br><span class=\"line\">标准错误输出(stdout):代码为2,使用2&gt;或2&gt;&gt;</span><br><span class=\"line\">全部输出到一个文件，使用2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<h4 id=\"shell输出回传码\"><a href=\"#shell输出回传码\" class=\"headerlink\" title=\"shell输出回传码\"></a>shell输出回传码</h4><p>用户每次在shell中执行一个命令，shell都会回传一个状态码，0或1，可以通过echo $?获取，0代表执行成功，非0代表执行失败。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin li</span><br><span class=\"line\">-bash: li: command not found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Linux常见的退出状态码\"><a href=\"#Linux常见的退出状态码\" class=\"headerlink\" title=\"Linux常见的退出状态码\"></a>Linux常见的退出状态码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 命令成功退出</span><br><span class=\"line\">1 一般性未知错误</span><br><span class=\"line\">2 不适合的shell命令</span><br><span class=\"line\">126 命令不可执行</span><br><span class=\"line\">127 没找到命令</span><br><span class=\"line\">128 无效的退出参数</span><br><span class=\"line\">130 通过CTRL+C终止的命令</span><br><span class=\"line\">255 正常范围之外的退出状态码</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>之前我们讲解shell的变量、环境变量以及各种命令的时候，命令执行结果输出每次都是显示到屏幕上给用户看，其实还有更多的方式。今天我们就专门讲讲输入和输出重定向。<br>","more":"</p>\n<h4 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h4><h5 id=\"将命令的标准输出写入文件或黑洞-dev-null\"><a href=\"#将命令的标准输出写入文件或黑洞-dev-null\" class=\"headerlink\" title=\"将命令的标准输出写入文件或黑洞/dev/null\"></a>将命令的标准输出写入文件或黑洞/dev/null</h5><p>可以使用&gt;或1&gt;将一个命令的输出<strong>覆盖写入到一个文件</strong>，如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被完全覆盖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello world&apos; &gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello world&apos; 1&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p>可以使用&gt;&gt;或1&gt;&gt;将一个命令的输出<strong>追加写入到一个文件</strong>,如果这个文件不存在，系统会自动创建，如果文件已存在，内容会被追加过去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello china&apos; &gt;&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello china&apos; 1&gt;&gt; rs.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"将命令的标准错误输出写入文件或黑洞-dev-null\"><a href=\"#将命令的标准错误输出写入文件或黑洞-dev-null\" class=\"headerlink\" title=\"将命令的标准错误输出写入文件或黑洞/dev/null\"></a>将命令的标准错误输出写入文件或黑洞/dev/null</h5><p>使用 2&gt; 和 2&gt;&gt; 将命令的标准错误输出覆盖写入或追加写入到一个文件,如果命令执行无错误，则输出空字符到文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat he1.out 2&gt;&gt; rs3.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs3.out</span><br><span class=\"line\">cat: he1.out: No such file or directory</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out 2&gt;&gt; rs4.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs4.out</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo &apos;hello&apos; 2&gt; rs.out</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h4><h5 id=\"将文件的内容重定向到命令\"><a href=\"#将文件的内容重定向到命令\" class=\"headerlink\" title=\"将文件的内容重定向到命令\"></a>将文件的内容重定向到命令</h5><p>可以使用&lt;或0&lt;将一个文件的内容输入到一个命令,此例是将一个文件的内容传递给wc，然后计算文件中字符的行数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat rs.out</span><br><span class=\"line\">hello world</span><br><span class=\"line\">hello china</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l &lt; rs.out</span><br><span class=\"line\">2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l 0&lt; rs.out</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<p>可以使用&lt;&lt;实现内联输入重定向，不需要通过文件，你只要指定结束符，逐个手动输入数据就可以了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# wc -l &lt;&lt; &quot;eof&quot;</span><br><span class=\"line\">&gt; hell</span><br><span class=\"line\">&gt; world</span><br><span class=\"line\">&gt; hi</span><br><span class=\"line\">&gt; hao</span><br><span class=\"line\">&gt; eof</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"输入输出总结\"><a href=\"#输入输出总结\" class=\"headerlink\" title=\"输入输出总结\"></a>输入输出总结</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">标准输入(stdin): 代码为0，使用&lt;或&lt;&lt;</span><br><span class=\"line\">标准输出(stdout): 代码为1，使用&gt;或&gt;&gt;</span><br><span class=\"line\">标准错误输出(stdout):代码为2,使用2&gt;或2&gt;&gt;</span><br><span class=\"line\">全部输出到一个文件，使用2&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<h4 id=\"shell输出回传码\"><a href=\"#shell输出回传码\" class=\"headerlink\" title=\"shell输出回传码\"></a>shell输出回传码</h4><p>用户每次在shell中执行一个命令，shell都会回传一个状态码，0或1，可以通过echo $?获取，0代表执行成功，非0代表执行失败。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo hello world</span><br><span class=\"line\">hello world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin li</span><br><span class=\"line\">-bash: li: command not found</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Linux常见的退出状态码\"><a href=\"#Linux常见的退出状态码\" class=\"headerlink\" title=\"Linux常见的退出状态码\"></a>Linux常见的退出状态码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 命令成功退出</span><br><span class=\"line\">1 一般性未知错误</span><br><span class=\"line\">2 不适合的shell命令</span><br><span class=\"line\">126 命令不可执行</span><br><span class=\"line\">127 没找到命令</span><br><span class=\"line\">128 无效的退出参数</span><br><span class=\"line\">130 通过CTRL+C终止的命令</span><br><span class=\"line\">255 正常范围之外的退出状态码</span><br></pre></td></tr></table></figure>"},{"title":"linux shell 常用命令","date":"2019-11-20T07:50:37.000Z","_content":"\n0.最有用的shell命令\n\nxargs\n\ngrep\n\nawk\n\nsed\n\n<!--more-->\n\n1 常用简单命令\n\necho\n\ndate\n\nreboot\n\npoweroff\n\nwget\n\nps\n\ntop\n\npidof\n\nkill\n\nkillall\n\n \n\n2 系统状态检测命令\n\nifconfig\n\nuname -a\n\nuptime\n\nfree -h\n\nwho\n\nhistory\n\nsosreport\n\n \n\n3 工作目录切换\n\npwd\n\ncd - .. / ~\n\nls\n\n \n\n4 文本编辑\n\ncat\n\nmore\n\nless\n\nhead\n\ntail -f\n\ntr\n\nwc\n\nstat\n\ncut\n\ndiff\n\n \n\n5 文件目录管理\n\ntouch\n\nmkdir\n\ncp\n\nmv\n\nrm\n\ndd\n\nfile\n\n \n\n6 打包压缩与搜索命令\n\ntar -zcvf -zxvf\n\ngrep -n -v\n\nfind\n\n \n","source":"_posts/linux/linux_shell_popular_command.md","raw":"---\ntitle: linux shell 常用命令\ndate: 2019-11-20 07:50:37\ntags: shell\ncategories: linux\n---\n\n0.最有用的shell命令\n\nxargs\n\ngrep\n\nawk\n\nsed\n\n<!--more-->\n\n1 常用简单命令\n\necho\n\ndate\n\nreboot\n\npoweroff\n\nwget\n\nps\n\ntop\n\npidof\n\nkill\n\nkillall\n\n \n\n2 系统状态检测命令\n\nifconfig\n\nuname -a\n\nuptime\n\nfree -h\n\nwho\n\nhistory\n\nsosreport\n\n \n\n3 工作目录切换\n\npwd\n\ncd - .. / ~\n\nls\n\n \n\n4 文本编辑\n\ncat\n\nmore\n\nless\n\nhead\n\ntail -f\n\ntr\n\nwc\n\nstat\n\ncut\n\ndiff\n\n \n\n5 文件目录管理\n\ntouch\n\nmkdir\n\ncp\n\nmv\n\nrm\n\ndd\n\nfile\n\n \n\n6 打包压缩与搜索命令\n\ntar -zcvf -zxvf\n\ngrep -n -v\n\nfind\n\n \n","slug":"linux/linux_shell_popular_command","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdets004i0en7qj7ryf0d","content":"<p>0.最有用的shell命令</p>\n<p>xargs</p>\n<p>grep</p>\n<p>awk</p>\n<p>sed</p>\n<a id=\"more\"></a>\n<p>1 常用简单命令</p>\n<p>echo</p>\n<p>date</p>\n<p>reboot</p>\n<p>poweroff</p>\n<p>wget</p>\n<p>ps</p>\n<p>top</p>\n<p>pidof</p>\n<p>kill</p>\n<p>killall</p>\n<p>2 系统状态检测命令</p>\n<p>ifconfig</p>\n<p>uname -a</p>\n<p>uptime</p>\n<p>free -h</p>\n<p>who</p>\n<p>history</p>\n<p>sosreport</p>\n<p>3 工作目录切换</p>\n<p>pwd</p>\n<p>cd - .. / ~</p>\n<p>ls</p>\n<p>4 文本编辑</p>\n<p>cat</p>\n<p>more</p>\n<p>less</p>\n<p>head</p>\n<p>tail -f</p>\n<p>tr</p>\n<p>wc</p>\n<p>stat</p>\n<p>cut</p>\n<p>diff</p>\n<p>5 文件目录管理</p>\n<p>touch</p>\n<p>mkdir</p>\n<p>cp</p>\n<p>mv</p>\n<p>rm</p>\n<p>dd</p>\n<p>file</p>\n<p>6 打包压缩与搜索命令</p>\n<p>tar -zcvf -zxvf</p>\n<p>grep -n -v</p>\n<p>find</p>\n","site":{"data":{}},"excerpt":"<p>0.最有用的shell命令</p>\n<p>xargs</p>\n<p>grep</p>\n<p>awk</p>\n<p>sed</p>","more":"<p>1 常用简单命令</p>\n<p>echo</p>\n<p>date</p>\n<p>reboot</p>\n<p>poweroff</p>\n<p>wget</p>\n<p>ps</p>\n<p>top</p>\n<p>pidof</p>\n<p>kill</p>\n<p>killall</p>\n<p>2 系统状态检测命令</p>\n<p>ifconfig</p>\n<p>uname -a</p>\n<p>uptime</p>\n<p>free -h</p>\n<p>who</p>\n<p>history</p>\n<p>sosreport</p>\n<p>3 工作目录切换</p>\n<p>pwd</p>\n<p>cd - .. / ~</p>\n<p>ls</p>\n<p>4 文本编辑</p>\n<p>cat</p>\n<p>more</p>\n<p>less</p>\n<p>head</p>\n<p>tail -f</p>\n<p>tr</p>\n<p>wc</p>\n<p>stat</p>\n<p>cut</p>\n<p>diff</p>\n<p>5 文件目录管理</p>\n<p>touch</p>\n<p>mkdir</p>\n<p>cp</p>\n<p>mv</p>\n<p>rm</p>\n<p>dd</p>\n<p>file</p>\n<p>6 打包压缩与搜索命令</p>\n<p>tar -zcvf -zxvf</p>\n<p>grep -n -v</p>\n<p>find</p>"},{"title":"Linux之shell变量","date":"2020-03-14T23:00:37.000Z","_content":"\n之前讲过了linux之环境变量，其实环境变量属于最特殊的一种变量。今天我们来讲讲通用的shell变量，就像每种编程语言都有变量的概念一样，shell编程也有变量的概念。Linux变量之所以要叫shell变量，是因为shell是唯一的linux脚本运行环境，也可以简称linux变量。\n<!--more-->\n\n#### 变量的概念\n\n想必大家上大学的时候，都学过了C语言、java语言等，最开始的章节都会学习到**变量的概念**，shell变量的概念类似。借用鸟哥的话，变量就是让一个特定的字符串代表不固定的内容。例如：最开始name=robin，过一会name=lily，那最后nama的值就是lily了。其实变量的真正用途，是给shell脚本中可变的内容提供一个修改的入口，在不同的环境中运行同一个shell脚本的时候，可以通过传参修改变量的值。\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin\n[root@aliyun-hk1 linux-shell-test]# name=lily\n[root@aliyun-hk1 linux-shell-test]# echo $name\nlily\n```\n\n#### 变量的读取\n先试下如何**读取变量的值**。echo $变量名 或 echo ${变量名}​\n```\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 linux-shell-test]# echo ${PATH}\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n```\n\n#### 变量的定义\n由于Linux操作系统管理的需要，已经定义了好多默认的变量，例如之前已经讲过的环境变量PATH，**定义变量**名称的时候一定不要使用这些操作系统已经霸占的名称，否则你会有意想不到的惊喜。变量的名称可以是英文字母和数字，但是不能以数字开头，建议字母仅使用小写字母，与操作系统自带的变量区分开。变量与变量的内容以一个“=”号连接，等号两边不能直接接空格。变量的内容中若有空格，就要使用双引号“”或单引号‘’将变量内容包起来。\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin h h li     \n-bash: h: command not found                               \n[root@aliyun-hk1 linux-shell-test]# name=\"robin h h li\"   \n[root@aliyun-hk1 linux-shell-test]# echo $name            \nrobin h h li                                              \n[root@aliyun-hk1 linux-shell-test]# name='robin h h li2'  \n[root@aliyun-hk1 linux-shell-test]# echo $name            \nrobin h h li2\n```\n\n但是，如果**双引号内部有特殊字符$**，可以保留原本的特性即解析变量。\n```\n[root@aliyun-hk1 linux-shell-test]# name=\"$name\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li2\n[root@aliyun-hk1 linux-shell-test]# name=\"i am $name\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\ni am robin h h li2\n```\n\n如果**单引号内部有特殊字符$**，继续作为普通字符处理。\n```\n[root@aliyun-hk1 linux-shell-test]# name2='$name'\n[root@aliyun-hk1 linux-shell-test]# echo $name2\n$name\n```\n\n**变量的值若是需要执行其他命令**获取，可以使用\\`命令\\`或“$(命令)”，注意那个是键盘左上角的符号而不是单引号。\n```\n[root@aliyun-hk1 linux-shell-test]# version=\"$(uname -a)\"\n[root@aliyun-hk1 linux-shell-test]# echo $version\nLinux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 linux-shell-test]# version2=`uname -a`\n[root@aliyun-hk1 linux-shell-test]# echo $version\nLinux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**变量增加内容，可以使用\"$变量名\"或\"${变量}\"**,为了能跟普通变量的追加有效，最好统一使用引号，如下所示：\n```\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 linux-shell-test]# PATH=$PATH:/apps/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/\n[root@aliyun-hk1 linux-shell-test]# PATH=${PATH}:/apps2/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/\n[root@aliyun-hk1 linux-shell-test]# PATH=\"$PATH\":/apps3/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/\n[root@aliyun-hk1 linux-shell-test]# PATH=\"${PATH}\":/apps4/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/:/apps4/\n```\n\n**取消变量**，使用“unset 变量名”然后通过变量名输出什么都没有了\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin\n[root@aliyun-hk1 linux-shell-test]# unset name\n[root@aliyun-hk1 linux-shell-test]# echo $name\n\n```\n\n**变量内容使用特殊字符，方法1**，使用“\\”，将特殊符号（\\[Enger\\]、$、 \\ 空格符、!等等）变为一般字符。其实就是让特殊符号的特殊作用失效。之前将变量别名的时候，也是同样的道理，使用“\\rm”就会让他的别名失效。\n```\n[root@aliyun-hk1 kernel]# name=\\robin\n[root@aliyun-hk1 kernel]# echo $name\nrobin\n[root@aliyun-hk1 kernel]# name=\\\\robin\n[root@aliyun-hk1 kernel]# echo $name\n\\robin\n[root@aliyun-hk1 kernel]# name=\\$robin\n[root@aliyun-hk1 kernel]# echo $name\n$robin\n[root@aliyun-hk1 linux-shell-test]# name=\\'hello\\ world\\'\n[root@aliyun-hk1 linux-shell-test]# echo $name\n'hello world'\n```\n\n**变量内容使用特殊字符，方法2**，使用‘’号将变量内容包住,但是变量内容不能包含单引号本身。\n```\n[root@aliyun-hk1 linux-shell-test]# name='$/\\ !$%robin'\n[root@aliyun-hk1 linux-shell-test]# echo $name\n$/\\ !$%robin\n```\n\n**变量赋值太长，想换行继续输入**，可以使用\\回车后继续输入，这里其实是将回车符转义让他失去本来的含义。注意前面已经讲过的，单引号会让特殊字符编变为普通字符，双引号会让特殊字符继续保持原有的作用。\n```\n[root@aliyun-hk1 linux-shell-test]# name='robin h h li li huan\\\n> huan very good'\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li li huan\\ huan very good\n[root@aliyun-hk1 linux-shell-test]# name=hello\\\n> world\n[root@aliyun-hk1 linux-shell-test]# echo $name\nhelloworld\n[root@aliyun-hk1 linux-shell-test]# name=\"robin h h li li huan\\\n> huan very good\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li li huanhuan very good\n```\n\n#### 语系变量\n\n**影响显示结果的语系变量**,目前的linux的发行版已经支持了多种语系了，其实不同语系对应不同的编码方式。locale -a查询目前发行版支持的语系，local查询本机已有的语系文件。这个变量呢，可千万不要随意更改，否则你会看到各种乱码。\n```\n[root@aliyun-hk1 ~]# locale -a\naa_DJ\naa_DJ.iso88591\naa_DJ.utf8\naa_ER\naa_ER@saaho\naa_ER.utf8\naa_ER.utf8@saaho\naa_ET\naa_ET.utf8\naf_ZA\n...省略若干行\n\n[root@aliyun-hk1 ~]# locale\nLANG=en_US.UTF-8\nLC_CTYPE=\"en_US.UTF-8\"\nLC_NUMERIC=\"en_US.UTF-8\"\nLC_TIME=\"en_US.UTF-8\"\nLC_COLLATE=\"en_US.UTF-8\"\nLC_MONETARY=\"en_US.UTF-8\"\nLC_MESSAGES=\"en_US.UTF-8\"\nLC_PAPER=\"en_US.UTF-8\"\nLC_NAME=\"en_US.UTF-8\"\nLC_ADDRESS=\"en_US.UTF-8\"\nLC_TELEPHONE=\"en_US.UTF-8\"\nLC_MEASUREMENT=\"en_US.UTF-8\"\nLC_IDENTIFICATION=\"en_US.UTF-8\"\nLC_ALL=\n```\n\n#### 变量的有效范围。\n**变量的有效范围**，我们在前面已经讲过，可以使用export 变量名，让子进程或者子shell可以使用这个变量。普通变量被export后，就变成了用户级的环境变量了。在shell编程的时候，任何变量定义和使用的时候，我们都要搞清楚，他的有效范围。\n\n**如果想让变量在子shell中也可以访问**，使用“export 变量名”,这个在shell编程中很重要！\n```\n[root@aliyun-hk1 linux-shell-test]# cat test_vars.sh\n#!/bin/bash\necho $PATH\necho $name\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n\n[root@aliyun-hk1 linux-shell-test]# export name\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\nrobin\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**如果让export过的变量变成普通变量**，使用declare +x 变量名称\n```\n[root@aliyun-hk1 ~]# name=robin\n[root@aliyun-hk1 ~]# export name\n[root@aliyun-hk1 ~]# export|grep name\ndeclare -x name=\"robin\"\n[root@aliyun-hk1 ~]# declare +x name\n[root@aliyun-hk1 ~]# export|grep name\n[root@aliyun-hk1 ~]#\n```\n\n#### 变量的输入、数组与声明\n\n**变量通过键盘读入**，read或read -s,一个是普通读入方式，一个是加密读入，并且只在当前shell有效。如果想在子shell中使用，需要使用export 变量名。\n```\n[root@aliyun-hk1 ~]# read name\nrobin\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# read -s age\n[root@aliyun-hk1 ~]# echo $age\n12\n```\n\n**申明变量的类型**，变量定义的时候，我没有提到变量类型的概念，因为shell默认变量类型为字符串，通过declare/typeset可以申明变量的类型。\n```\n-i 定义一个整数类型变量，而且经过测试进行数字加减计算并赋值时，被赋值的变量也必须为整数型，即不支持自动类型转换。\n[root@aliyun-hk1 ~]# declare -i age1=20\n[root@aliyun-hk1 ~]# declare -i age2=18\n[root@aliyun-hk1 ~]# declare -i count\n[root@aliyun-hk1 ~]# count=$age1-$age2\n[root@aliyun-hk1 ~]# echo $count\n2\n[root@aliyun-hk1 ~]# count2=$age1-$age2\n[root@aliyun-hk1 ~]# echo $count2\n20-18\n[root@aliyun-hk1 ~]#\n\n-x 将后面的变量变成环境变量，用法跟export一样。\n[root@aliyun-hk1 ~]# declare -x date='2020-03-15'\n[root@aliyun-hk1 ~]# export|grep date\ndeclare -x date=\"2020-03-15\"\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# echo $date\n2020-03-15\n\n-r 将后面的变量变为只读变量\n[root@aliyun-hk1 ~]# declare -r size=big\n[root@aliyun-hk1 ~]# echo $size\nbig\n[root@aliyun-hk1 ~]# size=small\nbash: size: readonly variable\n\n-a 定义一个数组变量\n[root@aliyun-hk1 ~]# declare -a vars\n[root@aliyun-hk1 ~]# echo $vars\n\n[root@aliyun-hk1 ~]# vars[0]=robin\n[root@aliyun-hk1 ~]# echo ${vars[0]}\nrobin\n[root@aliyun-hk1 ~]# vars[1]=lily\n[root@aliyun-hk1 ~]# echo ${vars[1]}\nlily\n[root@aliyun-hk1 ~]# echo $vars\nrobin\n```\n\n#### 字典类型变量\n其实大部分资料都把这种叫做shell的第二种数组，但是我觉得叫它字典最合适了，因为其他编程语言一般都这样叫的。\n```\n定义字典时，可以直接赋值，定义以后也可以继续给字典增加内容，而且只能通过${dic_name[key]}的方式访问。\n[root@aliyun-hk1 opstime.github.io]# declare -A arr_string3[name]=robin\n[root@aliyun-hk1 opstime.github.io]# echo ${arr_string3[name]}\nrobin\n[root@aliyun-hk1 opstime.github.io]# arr_string3[age]=18\n[root@aliyun-hk1 opstime.github.io]# echo ${arr_string3[age]}\n18\n[root@aliyun-hk1 opstime.github.io]#\n```","source":"_posts/linux/linux_shell_vars.md","raw":"---\ntitle: Linux之shell变量\ndate: 2020-03-14 23:00:37\ntags: shell\ncategories: linux\n---\n\n之前讲过了linux之环境变量，其实环境变量属于最特殊的一种变量。今天我们来讲讲通用的shell变量，就像每种编程语言都有变量的概念一样，shell编程也有变量的概念。Linux变量之所以要叫shell变量，是因为shell是唯一的linux脚本运行环境，也可以简称linux变量。\n<!--more-->\n\n#### 变量的概念\n\n想必大家上大学的时候，都学过了C语言、java语言等，最开始的章节都会学习到**变量的概念**，shell变量的概念类似。借用鸟哥的话，变量就是让一个特定的字符串代表不固定的内容。例如：最开始name=robin，过一会name=lily，那最后nama的值就是lily了。其实变量的真正用途，是给shell脚本中可变的内容提供一个修改的入口，在不同的环境中运行同一个shell脚本的时候，可以通过传参修改变量的值。\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin\n[root@aliyun-hk1 linux-shell-test]# name=lily\n[root@aliyun-hk1 linux-shell-test]# echo $name\nlily\n```\n\n#### 变量的读取\n先试下如何**读取变量的值**。echo $变量名 或 echo ${变量名}​\n```\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 linux-shell-test]# echo ${PATH}\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n```\n\n#### 变量的定义\n由于Linux操作系统管理的需要，已经定义了好多默认的变量，例如之前已经讲过的环境变量PATH，**定义变量**名称的时候一定不要使用这些操作系统已经霸占的名称，否则你会有意想不到的惊喜。变量的名称可以是英文字母和数字，但是不能以数字开头，建议字母仅使用小写字母，与操作系统自带的变量区分开。变量与变量的内容以一个“=”号连接，等号两边不能直接接空格。变量的内容中若有空格，就要使用双引号“”或单引号‘’将变量内容包起来。\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin h h li     \n-bash: h: command not found                               \n[root@aliyun-hk1 linux-shell-test]# name=\"robin h h li\"   \n[root@aliyun-hk1 linux-shell-test]# echo $name            \nrobin h h li                                              \n[root@aliyun-hk1 linux-shell-test]# name='robin h h li2'  \n[root@aliyun-hk1 linux-shell-test]# echo $name            \nrobin h h li2\n```\n\n但是，如果**双引号内部有特殊字符$**，可以保留原本的特性即解析变量。\n```\n[root@aliyun-hk1 linux-shell-test]# name=\"$name\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li2\n[root@aliyun-hk1 linux-shell-test]# name=\"i am $name\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\ni am robin h h li2\n```\n\n如果**单引号内部有特殊字符$**，继续作为普通字符处理。\n```\n[root@aliyun-hk1 linux-shell-test]# name2='$name'\n[root@aliyun-hk1 linux-shell-test]# echo $name2\n$name\n```\n\n**变量的值若是需要执行其他命令**获取，可以使用\\`命令\\`或“$(命令)”，注意那个是键盘左上角的符号而不是单引号。\n```\n[root@aliyun-hk1 linux-shell-test]# version=\"$(uname -a)\"\n[root@aliyun-hk1 linux-shell-test]# echo $version\nLinux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 linux-shell-test]# version2=`uname -a`\n[root@aliyun-hk1 linux-shell-test]# echo $version\nLinux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**变量增加内容，可以使用\"$变量名\"或\"${变量}\"**,为了能跟普通变量的追加有效，最好统一使用引号，如下所示：\n```\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n[root@aliyun-hk1 linux-shell-test]# PATH=$PATH:/apps/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/\n[root@aliyun-hk1 linux-shell-test]# PATH=${PATH}:/apps2/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/\n[root@aliyun-hk1 linux-shell-test]# PATH=\"$PATH\":/apps3/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/\n[root@aliyun-hk1 linux-shell-test]# PATH=\"${PATH}\":/apps4/\n[root@aliyun-hk1 linux-shell-test]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/:/apps4/\n```\n\n**取消变量**，使用“unset 变量名”然后通过变量名输出什么都没有了\n```\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin\n[root@aliyun-hk1 linux-shell-test]# unset name\n[root@aliyun-hk1 linux-shell-test]# echo $name\n\n```\n\n**变量内容使用特殊字符，方法1**，使用“\\”，将特殊符号（\\[Enger\\]、$、 \\ 空格符、!等等）变为一般字符。其实就是让特殊符号的特殊作用失效。之前将变量别名的时候，也是同样的道理，使用“\\rm”就会让他的别名失效。\n```\n[root@aliyun-hk1 kernel]# name=\\robin\n[root@aliyun-hk1 kernel]# echo $name\nrobin\n[root@aliyun-hk1 kernel]# name=\\\\robin\n[root@aliyun-hk1 kernel]# echo $name\n\\robin\n[root@aliyun-hk1 kernel]# name=\\$robin\n[root@aliyun-hk1 kernel]# echo $name\n$robin\n[root@aliyun-hk1 linux-shell-test]# name=\\'hello\\ world\\'\n[root@aliyun-hk1 linux-shell-test]# echo $name\n'hello world'\n```\n\n**变量内容使用特殊字符，方法2**，使用‘’号将变量内容包住,但是变量内容不能包含单引号本身。\n```\n[root@aliyun-hk1 linux-shell-test]# name='$/\\ !$%robin'\n[root@aliyun-hk1 linux-shell-test]# echo $name\n$/\\ !$%robin\n```\n\n**变量赋值太长，想换行继续输入**，可以使用\\回车后继续输入，这里其实是将回车符转义让他失去本来的含义。注意前面已经讲过的，单引号会让特殊字符编变为普通字符，双引号会让特殊字符继续保持原有的作用。\n```\n[root@aliyun-hk1 linux-shell-test]# name='robin h h li li huan\\\n> huan very good'\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li li huan\\ huan very good\n[root@aliyun-hk1 linux-shell-test]# name=hello\\\n> world\n[root@aliyun-hk1 linux-shell-test]# echo $name\nhelloworld\n[root@aliyun-hk1 linux-shell-test]# name=\"robin h h li li huan\\\n> huan very good\"\n[root@aliyun-hk1 linux-shell-test]# echo $name\nrobin h h li li huanhuan very good\n```\n\n#### 语系变量\n\n**影响显示结果的语系变量**,目前的linux的发行版已经支持了多种语系了，其实不同语系对应不同的编码方式。locale -a查询目前发行版支持的语系，local查询本机已有的语系文件。这个变量呢，可千万不要随意更改，否则你会看到各种乱码。\n```\n[root@aliyun-hk1 ~]# locale -a\naa_DJ\naa_DJ.iso88591\naa_DJ.utf8\naa_ER\naa_ER@saaho\naa_ER.utf8\naa_ER.utf8@saaho\naa_ET\naa_ET.utf8\naf_ZA\n...省略若干行\n\n[root@aliyun-hk1 ~]# locale\nLANG=en_US.UTF-8\nLC_CTYPE=\"en_US.UTF-8\"\nLC_NUMERIC=\"en_US.UTF-8\"\nLC_TIME=\"en_US.UTF-8\"\nLC_COLLATE=\"en_US.UTF-8\"\nLC_MONETARY=\"en_US.UTF-8\"\nLC_MESSAGES=\"en_US.UTF-8\"\nLC_PAPER=\"en_US.UTF-8\"\nLC_NAME=\"en_US.UTF-8\"\nLC_ADDRESS=\"en_US.UTF-8\"\nLC_TELEPHONE=\"en_US.UTF-8\"\nLC_MEASUREMENT=\"en_US.UTF-8\"\nLC_IDENTIFICATION=\"en_US.UTF-8\"\nLC_ALL=\n```\n\n#### 变量的有效范围。\n**变量的有效范围**，我们在前面已经讲过，可以使用export 变量名，让子进程或者子shell可以使用这个变量。普通变量被export后，就变成了用户级的环境变量了。在shell编程的时候，任何变量定义和使用的时候，我们都要搞清楚，他的有效范围。\n\n**如果想让变量在子shell中也可以访问**，使用“export 变量名”,这个在shell编程中很重要！\n```\n[root@aliyun-hk1 linux-shell-test]# cat test_vars.sh\n#!/bin/bash\necho $PATH\necho $name\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n\n[root@aliyun-hk1 linux-shell-test]# name=robin\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n\n[root@aliyun-hk1 linux-shell-test]# export name\n[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\nrobin\n[root@aliyun-hk1 linux-shell-test]#\n```\n\n**如果让export过的变量变成普通变量**，使用declare +x 变量名称\n```\n[root@aliyun-hk1 ~]# name=robin\n[root@aliyun-hk1 ~]# export name\n[root@aliyun-hk1 ~]# export|grep name\ndeclare -x name=\"robin\"\n[root@aliyun-hk1 ~]# declare +x name\n[root@aliyun-hk1 ~]# export|grep name\n[root@aliyun-hk1 ~]#\n```\n\n#### 变量的输入、数组与声明\n\n**变量通过键盘读入**，read或read -s,一个是普通读入方式，一个是加密读入，并且只在当前shell有效。如果想在子shell中使用，需要使用export 变量名。\n```\n[root@aliyun-hk1 ~]# read name\nrobin\n[root@aliyun-hk1 ~]# echo $name\nrobin\n[root@aliyun-hk1 ~]# read -s age\n[root@aliyun-hk1 ~]# echo $age\n12\n```\n\n**申明变量的类型**，变量定义的时候，我没有提到变量类型的概念，因为shell默认变量类型为字符串，通过declare/typeset可以申明变量的类型。\n```\n-i 定义一个整数类型变量，而且经过测试进行数字加减计算并赋值时，被赋值的变量也必须为整数型，即不支持自动类型转换。\n[root@aliyun-hk1 ~]# declare -i age1=20\n[root@aliyun-hk1 ~]# declare -i age2=18\n[root@aliyun-hk1 ~]# declare -i count\n[root@aliyun-hk1 ~]# count=$age1-$age2\n[root@aliyun-hk1 ~]# echo $count\n2\n[root@aliyun-hk1 ~]# count2=$age1-$age2\n[root@aliyun-hk1 ~]# echo $count2\n20-18\n[root@aliyun-hk1 ~]#\n\n-x 将后面的变量变成环境变量，用法跟export一样。\n[root@aliyun-hk1 ~]# declare -x date='2020-03-15'\n[root@aliyun-hk1 ~]# export|grep date\ndeclare -x date=\"2020-03-15\"\n[root@aliyun-hk1 ~]# bash\n[root@aliyun-hk1 ~]# echo $date\n2020-03-15\n\n-r 将后面的变量变为只读变量\n[root@aliyun-hk1 ~]# declare -r size=big\n[root@aliyun-hk1 ~]# echo $size\nbig\n[root@aliyun-hk1 ~]# size=small\nbash: size: readonly variable\n\n-a 定义一个数组变量\n[root@aliyun-hk1 ~]# declare -a vars\n[root@aliyun-hk1 ~]# echo $vars\n\n[root@aliyun-hk1 ~]# vars[0]=robin\n[root@aliyun-hk1 ~]# echo ${vars[0]}\nrobin\n[root@aliyun-hk1 ~]# vars[1]=lily\n[root@aliyun-hk1 ~]# echo ${vars[1]}\nlily\n[root@aliyun-hk1 ~]# echo $vars\nrobin\n```\n\n#### 字典类型变量\n其实大部分资料都把这种叫做shell的第二种数组，但是我觉得叫它字典最合适了，因为其他编程语言一般都这样叫的。\n```\n定义字典时，可以直接赋值，定义以后也可以继续给字典增加内容，而且只能通过${dic_name[key]}的方式访问。\n[root@aliyun-hk1 opstime.github.io]# declare -A arr_string3[name]=robin\n[root@aliyun-hk1 opstime.github.io]# echo ${arr_string3[name]}\nrobin\n[root@aliyun-hk1 opstime.github.io]# arr_string3[age]=18\n[root@aliyun-hk1 opstime.github.io]# echo ${arr_string3[age]}\n18\n[root@aliyun-hk1 opstime.github.io]#\n```","slug":"linux/linux_shell_vars","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdetu004l0en7j7yv2ffo","content":"<p>之前讲过了linux之环境变量，其实环境变量属于最特殊的一种变量。今天我们来讲讲通用的shell变量，就像每种编程语言都有变量的概念一样，shell编程也有变量的概念。Linux变量之所以要叫shell变量，是因为shell是唯一的linux脚本运行环境，也可以简称linux变量。<br><a id=\"more\"></a></p>\n<h4 id=\"变量的概念\"><a href=\"#变量的概念\" class=\"headerlink\" title=\"变量的概念\"></a>变量的概念</h4><p>想必大家上大学的时候，都学过了C语言、java语言等，最开始的章节都会学习到<strong>变量的概念</strong>，shell变量的概念类似。借用鸟哥的话，变量就是让一个特定的字符串代表不固定的内容。例如：最开始name=robin，过一会name=lily，那最后nama的值就是lily了。其实变量的真正用途，是给shell脚本中可变的内容提供一个修改的入口，在不同的环境中运行同一个shell脚本的时候，可以通过传参修改变量的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=lily</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">lily</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的读取\"><a href=\"#变量的读取\" class=\"headerlink\" title=\"变量的读取\"></a>变量的读取</h4><p>先试下如何<strong>读取变量的值</strong>。echo $变量名 或 echo ${变量名}​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $&#123;PATH&#125;</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h4><p>由于Linux操作系统管理的需要，已经定义了好多默认的变量，例如之前已经讲过的环境变量PATH，<strong>定义变量</strong>名称的时候一定不要使用这些操作系统已经霸占的名称，否则你会有意想不到的惊喜。变量的名称可以是英文字母和数字，但是不能以数字开头，建议字母仅使用小写字母，与操作系统自带的变量区分开。变量与变量的内容以一个“=”号连接，等号两边不能直接接空格。变量的内容中若有空格，就要使用双引号“”或单引号‘’将变量内容包起来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin h h li     </span><br><span class=\"line\">-bash: h: command not found                               </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;robin h h li&quot;   </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name            </span><br><span class=\"line\">robin h h li                                              </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;robin h h li2&apos;  </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name            </span><br><span class=\"line\">robin h h li2</span><br></pre></td></tr></table></figure></p>\n<p>但是，如果<strong>双引号内部有特殊字符$</strong>，可以保留原本的特性即解析变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;$name&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;i am $name&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">i am robin h h li2</span><br></pre></td></tr></table></figure></p>\n<p>如果<strong>单引号内部有特殊字符$</strong>，继续作为普通字符处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name2=&apos;$name&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name2</span><br><span class=\"line\">$name</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量的值若是需要执行其他命令</strong>获取，可以使用`命令`或“$(命令)”，注意那个是键盘左上角的符号而不是单引号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# version=&quot;$(uname -a)&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $version</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# version2=`uname -a`</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $version</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量增加内容，可以使用”$变量名”或”${变量}”</strong>,为了能跟普通变量的追加有效，最好统一使用引号，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=$PATH:/apps/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=$&#123;PATH&#125;:/apps2/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=&quot;$PATH&quot;:/apps3/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=&quot;$&#123;PATH&#125;&quot;:/apps4/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/:/apps4/</span><br></pre></td></tr></table></figure></p>\n<p><strong>取消变量</strong>，使用“unset 变量名”然后通过变量名输出什么都没有了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# unset name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量内容使用特殊字符，方法1</strong>，使用“\\”，将特殊符号（[Enger]、$、 \\ 空格符、!等等）变为一般字符。其实就是让特殊符号的特殊作用失效。之前将变量别名的时候，也是同样的道理，使用“\\rm”就会让他的别名失效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\$robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">$robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=\\&apos;hello\\ world\\&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">&apos;hello world&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量内容使用特殊字符，方法2</strong>，使用‘’号将变量内容包住,但是变量内容不能包含单引号本身。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;$/\\ !$%robin&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">$/\\ !$%robin</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量赋值太长，想换行继续输入</strong>，可以使用\\回车后继续输入，这里其实是将回车符转义让他失去本来的含义。注意前面已经讲过的，单引号会让特殊字符编变为普通字符，双引号会让特殊字符继续保持原有的作用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;robin h h li li huan\\</span><br><span class=\"line\">&gt; huan very good&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li li huan\\ huan very good</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=hello\\</span><br><span class=\"line\">&gt; world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">helloworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;robin h h li li huan\\</span><br><span class=\"line\">&gt; huan very good&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li li huanhuan very good</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"语系变量\"><a href=\"#语系变量\" class=\"headerlink\" title=\"语系变量\"></a>语系变量</h4><p><strong>影响显示结果的语系变量</strong>,目前的linux的发行版已经支持了多种语系了，其实不同语系对应不同的编码方式。locale -a查询目前发行版支持的语系，local查询本机已有的语系文件。这个变量呢，可千万不要随意更改，否则你会看到各种乱码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# locale -a</span><br><span class=\"line\">aa_DJ</span><br><span class=\"line\">aa_DJ.iso88591</span><br><span class=\"line\">aa_DJ.utf8</span><br><span class=\"line\">aa_ER</span><br><span class=\"line\">aa_ER@saaho</span><br><span class=\"line\">aa_ER.utf8</span><br><span class=\"line\">aa_ER.utf8@saaho</span><br><span class=\"line\">aa_ET</span><br><span class=\"line\">aa_ET.utf8</span><br><span class=\"line\">af_ZA</span><br><span class=\"line\">...省略若干行</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 ~]# locale</span><br><span class=\"line\">LANG=en_US.UTF-8</span><br><span class=\"line\">LC_CTYPE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_NUMERIC=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_TIME=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_COLLATE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MONETARY=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MESSAGES=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_PAPER=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_NAME=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_ADDRESS=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_TELEPHONE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MEASUREMENT=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_ALL=</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的有效范围。\"><a href=\"#变量的有效范围。\" class=\"headerlink\" title=\"变量的有效范围。\"></a>变量的有效范围。</h4><p><strong>变量的有效范围</strong>，我们在前面已经讲过，可以使用export 变量名，让子进程或者子shell可以使用这个变量。普通变量被export后，就变成了用户级的环境变量了。在shell编程的时候，任何变量定义和使用的时候，我们都要搞清楚，他的有效范围。</p>\n<p><strong>如果想让变量在子shell中也可以访问</strong>，使用“export 变量名”,这个在shell编程中很重要！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_vars.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $PATH</span><br><span class=\"line\">echo $name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# export name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>如果让export过的变量变成普通变量</strong>，使用declare +x 变量名称<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep name</span><br><span class=\"line\">declare -x name=&quot;robin&quot;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare +x name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep name</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的输入、数组与声明\"><a href=\"#变量的输入、数组与声明\" class=\"headerlink\" title=\"变量的输入、数组与声明\"></a>变量的输入、数组与声明</h4><p><strong>变量通过键盘读入</strong>，read或read -s,一个是普通读入方式，一个是加密读入，并且只在当前shell有效。如果想在子shell中使用，需要使用export 变量名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# read name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# read -s age</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $age</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure></p>\n<p><strong>申明变量的类型</strong>，变量定义的时候，我没有提到变量类型的概念，因为shell默认变量类型为字符串，通过declare/typeset可以申明变量的类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i 定义一个整数类型变量，而且经过测试进行数字加减计算并赋值时，被赋值的变量也必须为整数型，即不支持自动类型转换。</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i age1=20</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i age2=18</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i count</span><br><span class=\"line\">[root@aliyun-hk1 ~]# count=$age1-$age2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $count</span><br><span class=\"line\">2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# count2=$age1-$age2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $count2</span><br><span class=\"line\">20-18</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br><span class=\"line\"></span><br><span class=\"line\">-x 将后面的变量变成环境变量，用法跟export一样。</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -x date=&apos;2020-03-15&apos;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep date</span><br><span class=\"line\">declare -x date=&quot;2020-03-15&quot;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $date</span><br><span class=\"line\">2020-03-15</span><br><span class=\"line\"></span><br><span class=\"line\">-r 将后面的变量变为只读变量</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -r size=big</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $size</span><br><span class=\"line\">big</span><br><span class=\"line\">[root@aliyun-hk1 ~]# size=small</span><br><span class=\"line\">bash: size: readonly variable</span><br><span class=\"line\"></span><br><span class=\"line\">-a 定义一个数组变量</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -a vars</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $vars</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 ~]# vars[0]=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $&#123;vars[0]&#125;</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# vars[1]=lily</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $&#123;vars[1]&#125;</span><br><span class=\"line\">lily</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $vars</span><br><span class=\"line\">robin</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字典类型变量\"><a href=\"#字典类型变量\" class=\"headerlink\" title=\"字典类型变量\"></a>字典类型变量</h4><p>其实大部分资料都把这种叫做shell的第二种数组，但是我觉得叫它字典最合适了，因为其他编程语言一般都这样叫的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义字典时，可以直接赋值，定义以后也可以继续给字典增加内容，而且只能通过$&#123;dic_name[key]&#125;的方式访问。</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# declare -A arr_string3[name]=robin</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# echo $&#123;arr_string3[name]&#125;</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# arr_string3[age]=18</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# echo $&#123;arr_string3[age]&#125;</span><br><span class=\"line\">18</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]#</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>之前讲过了linux之环境变量，其实环境变量属于最特殊的一种变量。今天我们来讲讲通用的shell变量，就像每种编程语言都有变量的概念一样，shell编程也有变量的概念。Linux变量之所以要叫shell变量，是因为shell是唯一的linux脚本运行环境，也可以简称linux变量。<br>","more":"</p>\n<h4 id=\"变量的概念\"><a href=\"#变量的概念\" class=\"headerlink\" title=\"变量的概念\"></a>变量的概念</h4><p>想必大家上大学的时候，都学过了C语言、java语言等，最开始的章节都会学习到<strong>变量的概念</strong>，shell变量的概念类似。借用鸟哥的话，变量就是让一个特定的字符串代表不固定的内容。例如：最开始name=robin，过一会name=lily，那最后nama的值就是lily了。其实变量的真正用途，是给shell脚本中可变的内容提供一个修改的入口，在不同的环境中运行同一个shell脚本的时候，可以通过传参修改变量的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=lily</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">lily</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的读取\"><a href=\"#变量的读取\" class=\"headerlink\" title=\"变量的读取\"></a>变量的读取</h4><p>先试下如何<strong>读取变量的值</strong>。echo $变量名 或 echo ${变量名}​<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $&#123;PATH&#125;</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的定义\"><a href=\"#变量的定义\" class=\"headerlink\" title=\"变量的定义\"></a>变量的定义</h4><p>由于Linux操作系统管理的需要，已经定义了好多默认的变量，例如之前已经讲过的环境变量PATH，<strong>定义变量</strong>名称的时候一定不要使用这些操作系统已经霸占的名称，否则你会有意想不到的惊喜。变量的名称可以是英文字母和数字，但是不能以数字开头，建议字母仅使用小写字母，与操作系统自带的变量区分开。变量与变量的内容以一个“=”号连接，等号两边不能直接接空格。变量的内容中若有空格，就要使用双引号“”或单引号‘’将变量内容包起来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin h h li     </span><br><span class=\"line\">-bash: h: command not found                               </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;robin h h li&quot;   </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name            </span><br><span class=\"line\">robin h h li                                              </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;robin h h li2&apos;  </span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name            </span><br><span class=\"line\">robin h h li2</span><br></pre></td></tr></table></figure></p>\n<p>但是，如果<strong>双引号内部有特殊字符$</strong>，可以保留原本的特性即解析变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;$name&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li2</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;i am $name&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">i am robin h h li2</span><br></pre></td></tr></table></figure></p>\n<p>如果<strong>单引号内部有特殊字符$</strong>，继续作为普通字符处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name2=&apos;$name&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name2</span><br><span class=\"line\">$name</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量的值若是需要执行其他命令</strong>获取，可以使用`命令`或“$(命令)”，注意那个是键盘左上角的符号而不是单引号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# version=&quot;$(uname -a)&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $version</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# version2=`uname -a`</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $version</span><br><span class=\"line\">Linux aliyun-hk1 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量增加内容，可以使用”$变量名”或”${变量}”</strong>,为了能跟普通变量的追加有效，最好统一使用引号，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=$PATH:/apps/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=$&#123;PATH&#125;:/apps2/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=&quot;$PATH&quot;:/apps3/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# PATH=&quot;$&#123;PATH&#125;&quot;:/apps4/</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $PATH</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/apps/:/apps2/:/apps3/:/apps4/</span><br></pre></td></tr></table></figure></p>\n<p><strong>取消变量</strong>，使用“unset 变量名”然后通过变量名输出什么都没有了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# unset name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量内容使用特殊字符，方法1</strong>，使用“\\”，将特殊符号（[Enger]、$、 \\ 空格符、!等等）变为一般字符。其实就是让特殊符号的特殊作用失效。之前将变量别名的时候，也是同样的道理，使用“\\rm”就会让他的别名失效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">\\robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# name=\\$robin</span><br><span class=\"line\">[root@aliyun-hk1 kernel]# echo $name</span><br><span class=\"line\">$robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=\\&apos;hello\\ world\\&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">&apos;hello world&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量内容使用特殊字符，方法2</strong>，使用‘’号将变量内容包住,但是变量内容不能包含单引号本身。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;$/\\ !$%robin&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">$/\\ !$%robin</span><br></pre></td></tr></table></figure></p>\n<p><strong>变量赋值太长，想换行继续输入</strong>，可以使用\\回车后继续输入，这里其实是将回车符转义让他失去本来的含义。注意前面已经讲过的，单引号会让特殊字符编变为普通字符，双引号会让特殊字符继续保持原有的作用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&apos;robin h h li li huan\\</span><br><span class=\"line\">&gt; huan very good&apos;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li li huan\\ huan very good</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=hello\\</span><br><span class=\"line\">&gt; world</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">helloworld</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=&quot;robin h h li li huan\\</span><br><span class=\"line\">&gt; huan very good&quot;</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# echo $name</span><br><span class=\"line\">robin h h li li huanhuan very good</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"语系变量\"><a href=\"#语系变量\" class=\"headerlink\" title=\"语系变量\"></a>语系变量</h4><p><strong>影响显示结果的语系变量</strong>,目前的linux的发行版已经支持了多种语系了，其实不同语系对应不同的编码方式。locale -a查询目前发行版支持的语系，local查询本机已有的语系文件。这个变量呢，可千万不要随意更改，否则你会看到各种乱码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# locale -a</span><br><span class=\"line\">aa_DJ</span><br><span class=\"line\">aa_DJ.iso88591</span><br><span class=\"line\">aa_DJ.utf8</span><br><span class=\"line\">aa_ER</span><br><span class=\"line\">aa_ER@saaho</span><br><span class=\"line\">aa_ER.utf8</span><br><span class=\"line\">aa_ER.utf8@saaho</span><br><span class=\"line\">aa_ET</span><br><span class=\"line\">aa_ET.utf8</span><br><span class=\"line\">af_ZA</span><br><span class=\"line\">...省略若干行</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 ~]# locale</span><br><span class=\"line\">LANG=en_US.UTF-8</span><br><span class=\"line\">LC_CTYPE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_NUMERIC=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_TIME=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_COLLATE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MONETARY=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MESSAGES=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_PAPER=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_NAME=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_ADDRESS=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_TELEPHONE=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_MEASUREMENT=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;</span><br><span class=\"line\">LC_ALL=</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的有效范围。\"><a href=\"#变量的有效范围。\" class=\"headerlink\" title=\"变量的有效范围。\"></a>变量的有效范围。</h4><p><strong>变量的有效范围</strong>，我们在前面已经讲过，可以使用export 变量名，让子进程或者子shell可以使用这个变量。普通变量被export后，就变成了用户级的环境变量了。在shell编程的时候，任何变量定义和使用的时候，我们都要搞清楚，他的有效范围。</p>\n<p><strong>如果想让变量在子shell中也可以访问</strong>，使用“export 变量名”,这个在shell编程中很重要！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# cat test_vars.sh</span><br><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo $PATH</span><br><span class=\"line\">echo $name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# export name</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]# ./test_vars.sh</span><br><span class=\"line\">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 linux-shell-test]#</span><br></pre></td></tr></table></figure></p>\n<p><strong>如果让export过的变量变成普通变量</strong>，使用declare +x 变量名称<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# name=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep name</span><br><span class=\"line\">declare -x name=&quot;robin&quot;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare +x name</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep name</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量的输入、数组与声明\"><a href=\"#变量的输入、数组与声明\" class=\"headerlink\" title=\"变量的输入、数组与声明\"></a>变量的输入、数组与声明</h4><p><strong>变量通过键盘读入</strong>，read或read -s,一个是普通读入方式，一个是加密读入，并且只在当前shell有效。如果想在子shell中使用，需要使用export 变量名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun-hk1 ~]# read name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $name</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# read -s age</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $age</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure></p>\n<p><strong>申明变量的类型</strong>，变量定义的时候，我没有提到变量类型的概念，因为shell默认变量类型为字符串，通过declare/typeset可以申明变量的类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i 定义一个整数类型变量，而且经过测试进行数字加减计算并赋值时，被赋值的变量也必须为整数型，即不支持自动类型转换。</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i age1=20</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i age2=18</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -i count</span><br><span class=\"line\">[root@aliyun-hk1 ~]# count=$age1-$age2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $count</span><br><span class=\"line\">2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# count2=$age1-$age2</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $count2</span><br><span class=\"line\">20-18</span><br><span class=\"line\">[root@aliyun-hk1 ~]#</span><br><span class=\"line\"></span><br><span class=\"line\">-x 将后面的变量变成环境变量，用法跟export一样。</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -x date=&apos;2020-03-15&apos;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# export|grep date</span><br><span class=\"line\">declare -x date=&quot;2020-03-15&quot;</span><br><span class=\"line\">[root@aliyun-hk1 ~]# bash</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $date</span><br><span class=\"line\">2020-03-15</span><br><span class=\"line\"></span><br><span class=\"line\">-r 将后面的变量变为只读变量</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -r size=big</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $size</span><br><span class=\"line\">big</span><br><span class=\"line\">[root@aliyun-hk1 ~]# size=small</span><br><span class=\"line\">bash: size: readonly variable</span><br><span class=\"line\"></span><br><span class=\"line\">-a 定义一个数组变量</span><br><span class=\"line\">[root@aliyun-hk1 ~]# declare -a vars</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $vars</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun-hk1 ~]# vars[0]=robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $&#123;vars[0]&#125;</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 ~]# vars[1]=lily</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $&#123;vars[1]&#125;</span><br><span class=\"line\">lily</span><br><span class=\"line\">[root@aliyun-hk1 ~]# echo $vars</span><br><span class=\"line\">robin</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字典类型变量\"><a href=\"#字典类型变量\" class=\"headerlink\" title=\"字典类型变量\"></a>字典类型变量</h4><p>其实大部分资料都把这种叫做shell的第二种数组，但是我觉得叫它字典最合适了，因为其他编程语言一般都这样叫的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义字典时，可以直接赋值，定义以后也可以继续给字典增加内容，而且只能通过$&#123;dic_name[key]&#125;的方式访问。</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# declare -A arr_string3[name]=robin</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# echo $&#123;arr_string3[name]&#125;</span><br><span class=\"line\">robin</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# arr_string3[age]=18</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]# echo $&#123;arr_string3[age]&#125;</span><br><span class=\"line\">18</span><br><span class=\"line\">[root@aliyun-hk1 opstime.github.io]#</span><br></pre></td></tr></table></figure></p>"},{"title":"使用ansible管理Redhat8服务器","date":"2020-02-04T23:59:37.000Z","_content":"\nredhat7默认安装了python，天生就支持ansible管理，什么都不用做。\nredhat8默认不安装python，因此无法通过python去管理，直接上解决方案。\ndnf install python3 -y\nalternatives --set python /usr/bin/python3\nyum install python3-libselinux_x86_64\n\n<!--more-->","source":"_posts/linux/linux_support_ansible.md","raw":"---\ntitle: 使用ansible管理Redhat8服务器\ndate: 2020-02-04 23:59:37\ntags: ansible\ncategories: linux\n---\n\nredhat7默认安装了python，天生就支持ansible管理，什么都不用做。\nredhat8默认不安装python，因此无法通过python去管理，直接上解决方案。\ndnf install python3 -y\nalternatives --set python /usr/bin/python3\nyum install python3-libselinux_x86_64\n\n<!--more-->","slug":"linux/linux_support_ansible","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdetw004o0en7l6x9wses","content":"<p>redhat7默认安装了python，天生就支持ansible管理，什么都不用做。<br>redhat8默认不安装python，因此无法通过python去管理，直接上解决方案。<br>dnf install python3 -y<br>alternatives –set python /usr/bin/python3<br>yum install python3-libselinux_x86_64</p>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>redhat7默认安装了python，天生就支持ansible管理，什么都不用做。<br>redhat8默认不安装python，因此无法通过python去管理，直接上解决方案。<br>dnf install python3 -y<br>alternatives –set python /usr/bin/python3<br>yum install python3-libselinux_x86_64</p>","more":""},{"title":"ddns of ipv6","date":"2019-03-21T18:58:37.000Z","_content":"\n如果你家的路由器已经get到了ipv6地址，并且你家的电脑也获取了有效的ipv6地址，在广域网的设备可以访问到。\n那恭喜你，再配合我这个ddns，你可以完美地把你家的电脑当服务器使用。具体教程，稍后再补充。\n\nddns的python实现脚本在这里：\nhttps://github.com/byygyy/ddns_ipv6\n","source":"_posts/network/ddns_ipv6.md","raw":"---\ntitle: ddns of ipv6\ndate: 2019-03-21 18:58:37\ntags: ipv6\ncategories: network\n---\n\n如果你家的路由器已经get到了ipv6地址，并且你家的电脑也获取了有效的ipv6地址，在广域网的设备可以访问到。\n那恭喜你，再配合我这个ddns，你可以完美地把你家的电脑当服务器使用。具体教程，稍后再补充。\n\nddns的python实现脚本在这里：\nhttps://github.com/byygyy/ddns_ipv6\n","slug":"network/ddns_ipv6","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdety004r0en7xa7at3kb","content":"<p>如果你家的路由器已经get到了ipv6地址，并且你家的电脑也获取了有效的ipv6地址，在广域网的设备可以访问到。<br>那恭喜你，再配合我这个ddns，你可以完美地把你家的电脑当服务器使用。具体教程，稍后再补充。</p>\n<p>ddns的python实现脚本在这里：<br><a href=\"https://github.com/byygyy/ddns_ipv6\" target=\"_blank\" rel=\"noopener\">https://github.com/byygyy/ddns_ipv6</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你家的路由器已经get到了ipv6地址，并且你家的电脑也获取了有效的ipv6地址，在广域网的设备可以访问到。<br>那恭喜你，再配合我这个ddns，你可以完美地把你家的电脑当服务器使用。具体教程，稍后再补充。</p>\n<p>ddns的python实现脚本在这里：<br><a href=\"https://github.com/byygyy/ddns_ipv6\" target=\"_blank\" rel=\"noopener\">https://github.com/byygyy/ddns_ipv6</a></p>\n"},{"title":"将博客搬至CSDN","date":"2020-02-24T21:37:37.000Z","_content":"\n将博客搬至CSDN","source":"_posts/other/copy-to-csdn.md","raw":"---\ntitle: 将博客搬至CSDN\ndate: 2020-02-24 21:37:37\ntags: other\ncategories: other\n---\n\n将博客搬至CSDN","slug":"other/copy-to-csdn","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeu0004u0en7hr46k90g","content":"<p>将博客搬至CSDN</p>\n","site":{"data":{}},"excerpt":"","more":"<p>将博客搬至CSDN</p>\n"},{"title":"完美实现内网穿透","date":"2019-12-21T22:50:37.000Z","_content":"\n之前写过一个ddns的一个脚本，在局域网服务器上动态获取ipv6地址并绑定到阿里云域名。\n今天再来讲一个内网穿透的实例，因为有些运营商分配的ipv6地址根本不允许公网访问。\n\n<!--more-->\n\n### 什么是内网穿透\n内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了。\n\n### 内网穿透安全吗\n现在服务器被黑的情况,多半是服务器上一些软件/漏洞/端口导致的.你的应用如果放在公网服务器,由于缺少系统安全维护知识,会变得很危险.而用了natapp内网穿透软件之后,将服务器放在本地,暴露给公网的也仅仅是应用层面的一个端口,其他系统上的漏洞/端口都被隐藏起来.从这个层面来说,提高了很多安全性.\n当然,你的应用本身带来的安全性,比如代码本身有漏洞,如果是映射数据库应用,数据库弱密码等,这需要引起重视,排查映射的应用本身安全性即可.\nNatapp本身的隧道传输采用ssl256位加密,这种加密安全性现阶段完全无法破解,natapp隧道的安全性无需考虑。\n\n### 内网穿透可以做什么\n* 1.上文举例的办公软件\n\n* 2.放在家里的树莓派,服务器等,需要远程ssh管理,这样打通服务器的22端口即可远程通过ssh操作服务器了.\n\n* 3.微信/支付宝等本地开发.现在微信/支付宝等应用,需要服务器接收微信/支付宝发送的回调信息,然而在本地开发程序的话,还得实时上传到服务器,以便支持微信/支付宝的回调信息,如果使用了natapp内网穿透软件,将回调地址设置成natapp提供的地址,回调数据立即传递回本地,,这样很方便的在本地就可以实时调试程序,无须再不断上传服务器等繁琐且无意义的步骤.\n\n* 4.一些企业内部数据库,由于安全等原因,不愿意放到云服务器上,可以将数据库放到办公室本地,然后通过natapp的tcp隧道映射,这样既保证安全,又保证公网可以正常访问.\n\n*  5.一些开发板做的监控等信息,每台设备运行一条隧道,可以方便的管理监控各个设备的运行情况.\n\n*  6.一些本地运行的游戏,想和好基友一起联网玩,一条命令运行natapp即可实现联网游戏.\n\n*  7.群辉上运行natapp之后,随时随地在任何地方可以访问到群辉上应用\n\n### 商业又实惠的内网穿透产品\n做个广告，我是这个产品的忠实用户，如果有任何技术问题，可以联系我。\n网址：https://natapp.cn/\n推荐码：2452201F (使用这个推荐码九折优惠)\n\n","source":"_posts/network/natapp.md","raw":"---\ntitle: 完美实现内网穿透\ndate: 2019-12-21 22:50:37\ntags:\n  - nat\n  - internet\ncategories: network\n---\n\n之前写过一个ddns的一个脚本，在局域网服务器上动态获取ipv6地址并绑定到阿里云域名。\n今天再来讲一个内网穿透的实例，因为有些运营商分配的ipv6地址根本不允许公网访问。\n\n<!--more-->\n\n### 什么是内网穿透\n内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了。\n\n### 内网穿透安全吗\n现在服务器被黑的情况,多半是服务器上一些软件/漏洞/端口导致的.你的应用如果放在公网服务器,由于缺少系统安全维护知识,会变得很危险.而用了natapp内网穿透软件之后,将服务器放在本地,暴露给公网的也仅仅是应用层面的一个端口,其他系统上的漏洞/端口都被隐藏起来.从这个层面来说,提高了很多安全性.\n当然,你的应用本身带来的安全性,比如代码本身有漏洞,如果是映射数据库应用,数据库弱密码等,这需要引起重视,排查映射的应用本身安全性即可.\nNatapp本身的隧道传输采用ssl256位加密,这种加密安全性现阶段完全无法破解,natapp隧道的安全性无需考虑。\n\n### 内网穿透可以做什么\n* 1.上文举例的办公软件\n\n* 2.放在家里的树莓派,服务器等,需要远程ssh管理,这样打通服务器的22端口即可远程通过ssh操作服务器了.\n\n* 3.微信/支付宝等本地开发.现在微信/支付宝等应用,需要服务器接收微信/支付宝发送的回调信息,然而在本地开发程序的话,还得实时上传到服务器,以便支持微信/支付宝的回调信息,如果使用了natapp内网穿透软件,将回调地址设置成natapp提供的地址,回调数据立即传递回本地,,这样很方便的在本地就可以实时调试程序,无须再不断上传服务器等繁琐且无意义的步骤.\n\n* 4.一些企业内部数据库,由于安全等原因,不愿意放到云服务器上,可以将数据库放到办公室本地,然后通过natapp的tcp隧道映射,这样既保证安全,又保证公网可以正常访问.\n\n*  5.一些开发板做的监控等信息,每台设备运行一条隧道,可以方便的管理监控各个设备的运行情况.\n\n*  6.一些本地运行的游戏,想和好基友一起联网玩,一条命令运行natapp即可实现联网游戏.\n\n*  7.群辉上运行natapp之后,随时随地在任何地方可以访问到群辉上应用\n\n### 商业又实惠的内网穿透产品\n做个广告，我是这个产品的忠实用户，如果有任何技术问题，可以联系我。\n网址：https://natapp.cn/\n推荐码：2452201F (使用这个推荐码九折优惠)\n\n","slug":"network/natapp","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeu2004z0en7msscnxtx","content":"<p>之前写过一个ddns的一个脚本，在局域网服务器上动态获取ipv6地址并绑定到阿里云域名。<br>今天再来讲一个内网穿透的实例，因为有些运营商分配的ipv6地址根本不允许公网访问。</p>\n<a id=\"more\"></a>\n<h3 id=\"什么是内网穿透\"><a href=\"#什么是内网穿透\" class=\"headerlink\" title=\"什么是内网穿透\"></a>什么是内网穿透</h3><p>内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了。</p>\n<h3 id=\"内网穿透安全吗\"><a href=\"#内网穿透安全吗\" class=\"headerlink\" title=\"内网穿透安全吗\"></a>内网穿透安全吗</h3><p>现在服务器被黑的情况,多半是服务器上一些软件/漏洞/端口导致的.你的应用如果放在公网服务器,由于缺少系统安全维护知识,会变得很危险.而用了natapp内网穿透软件之后,将服务器放在本地,暴露给公网的也仅仅是应用层面的一个端口,其他系统上的漏洞/端口都被隐藏起来.从这个层面来说,提高了很多安全性.<br>当然,你的应用本身带来的安全性,比如代码本身有漏洞,如果是映射数据库应用,数据库弱密码等,这需要引起重视,排查映射的应用本身安全性即可.<br>Natapp本身的隧道传输采用ssl256位加密,这种加密安全性现阶段完全无法破解,natapp隧道的安全性无需考虑。</p>\n<h3 id=\"内网穿透可以做什么\"><a href=\"#内网穿透可以做什么\" class=\"headerlink\" title=\"内网穿透可以做什么\"></a>内网穿透可以做什么</h3><ul>\n<li><p>1.上文举例的办公软件</p>\n</li>\n<li><p>2.放在家里的树莓派,服务器等,需要远程ssh管理,这样打通服务器的22端口即可远程通过ssh操作服务器了.</p>\n</li>\n<li><p>3.微信/支付宝等本地开发.现在微信/支付宝等应用,需要服务器接收微信/支付宝发送的回调信息,然而在本地开发程序的话,还得实时上传到服务器,以便支持微信/支付宝的回调信息,如果使用了natapp内网穿透软件,将回调地址设置成natapp提供的地址,回调数据立即传递回本地,,这样很方便的在本地就可以实时调试程序,无须再不断上传服务器等繁琐且无意义的步骤.</p>\n</li>\n<li><p>4.一些企业内部数据库,由于安全等原因,不愿意放到云服务器上,可以将数据库放到办公室本地,然后通过natapp的tcp隧道映射,这样既保证安全,又保证公网可以正常访问.</p>\n</li>\n<li><p>5.一些开发板做的监控等信息,每台设备运行一条隧道,可以方便的管理监控各个设备的运行情况.</p>\n</li>\n<li><p>6.一些本地运行的游戏,想和好基友一起联网玩,一条命令运行natapp即可实现联网游戏.</p>\n</li>\n<li><p>7.群辉上运行natapp之后,随时随地在任何地方可以访问到群辉上应用</p>\n</li>\n</ul>\n<h3 id=\"商业又实惠的内网穿透产品\"><a href=\"#商业又实惠的内网穿透产品\" class=\"headerlink\" title=\"商业又实惠的内网穿透产品\"></a>商业又实惠的内网穿透产品</h3><p>做个广告，我是这个产品的忠实用户，如果有任何技术问题，可以联系我。<br>网址：<a href=\"https://natapp.cn/\" target=\"_blank\" rel=\"noopener\">https://natapp.cn/</a><br>推荐码：2452201F (使用这个推荐码九折优惠)</p>\n","site":{"data":{}},"excerpt":"<p>之前写过一个ddns的一个脚本，在局域网服务器上动态获取ipv6地址并绑定到阿里云域名。<br>今天再来讲一个内网穿透的实例，因为有些运营商分配的ipv6地址根本不允许公网访问。</p>","more":"<h3 id=\"什么是内网穿透\"><a href=\"#什么是内网穿透\" class=\"headerlink\" title=\"什么是内网穿透\"></a>什么是内网穿透</h3><p>内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了。</p>\n<h3 id=\"内网穿透安全吗\"><a href=\"#内网穿透安全吗\" class=\"headerlink\" title=\"内网穿透安全吗\"></a>内网穿透安全吗</h3><p>现在服务器被黑的情况,多半是服务器上一些软件/漏洞/端口导致的.你的应用如果放在公网服务器,由于缺少系统安全维护知识,会变得很危险.而用了natapp内网穿透软件之后,将服务器放在本地,暴露给公网的也仅仅是应用层面的一个端口,其他系统上的漏洞/端口都被隐藏起来.从这个层面来说,提高了很多安全性.<br>当然,你的应用本身带来的安全性,比如代码本身有漏洞,如果是映射数据库应用,数据库弱密码等,这需要引起重视,排查映射的应用本身安全性即可.<br>Natapp本身的隧道传输采用ssl256位加密,这种加密安全性现阶段完全无法破解,natapp隧道的安全性无需考虑。</p>\n<h3 id=\"内网穿透可以做什么\"><a href=\"#内网穿透可以做什么\" class=\"headerlink\" title=\"内网穿透可以做什么\"></a>内网穿透可以做什么</h3><ul>\n<li><p>1.上文举例的办公软件</p>\n</li>\n<li><p>2.放在家里的树莓派,服务器等,需要远程ssh管理,这样打通服务器的22端口即可远程通过ssh操作服务器了.</p>\n</li>\n<li><p>3.微信/支付宝等本地开发.现在微信/支付宝等应用,需要服务器接收微信/支付宝发送的回调信息,然而在本地开发程序的话,还得实时上传到服务器,以便支持微信/支付宝的回调信息,如果使用了natapp内网穿透软件,将回调地址设置成natapp提供的地址,回调数据立即传递回本地,,这样很方便的在本地就可以实时调试程序,无须再不断上传服务器等繁琐且无意义的步骤.</p>\n</li>\n<li><p>4.一些企业内部数据库,由于安全等原因,不愿意放到云服务器上,可以将数据库放到办公室本地,然后通过natapp的tcp隧道映射,这样既保证安全,又保证公网可以正常访问.</p>\n</li>\n<li><p>5.一些开发板做的监控等信息,每台设备运行一条隧道,可以方便的管理监控各个设备的运行情况.</p>\n</li>\n<li><p>6.一些本地运行的游戏,想和好基友一起联网玩,一条命令运行natapp即可实现联网游戏.</p>\n</li>\n<li><p>7.群辉上运行natapp之后,随时随地在任何地方可以访问到群辉上应用</p>\n</li>\n</ul>\n<h3 id=\"商业又实惠的内网穿透产品\"><a href=\"#商业又实惠的内网穿透产品\" class=\"headerlink\" title=\"商业又实惠的内网穿透产品\"></a>商业又实惠的内网穿透产品</h3><p>做个广告，我是这个产品的忠实用户，如果有任何技术问题，可以联系我。<br>网址：<a href=\"https://natapp.cn/\" target=\"_blank\" rel=\"noopener\">https://natapp.cn/</a><br>推荐码：2452201F (使用这个推荐码九折优惠)</p>"},{"title":"做得更少，然后执着","date":"2019-03-14T22:54:37.000Z","_content":"\n方法：做得更少，然后执着\n\n李翔及其团队\n\n工作方法\n\n《金融时报》介绍了学者莫腾·汉森的新书《玩转工作》（Great at Work）。汉森在书中提出了一个工作理念：“少即是多”带来优势的前提是，你必须专注在自己选择的“少”上面。“如果你不执着地投入，你就不会比那些做更多事情的人有优势”。\n\n<!--more-->\n\n汉森举了一个历史上的例子，1911年探险家罗尔德·阿蒙森（Roald Amundsen）和罗伯特·斯科特（Robert Falcon Scott）关于谁先到达南极的竞赛。斯科特团队有更多的钱和更大团队，交通工具包括机动雪橇、小马和狗。但是斯科特的方法过于复杂，他自己也不止一次说起过自己的“混乱的船队”，不同的团队要在不同的时间出发。而阿蒙森团队选择的交通方式非常简单：狗拉雪橇。所以，他就专注在找到最好的狗、最好的训练狗拉雪橇的人，然后获得最好的训练。“阿蒙森选择了一种方法，娴熟地掌握了它。他做得更少，然后执着地投入其中。”最后阿蒙森赢得了这场比赛，斯科特成为探险历史上的一个悲剧英雄。\n\n除了这个历史故事，汉森还研究了5000个人的表现，发现那些采用“做得更少，然后执着”策略的人，要比其他人的得分高出25%。\n\n除此之外，汉森还有几个重要的发现：首先是，要警惕“激情”。很多人把对工作的激情视为成功的一个关键，但是，激情可能导致人们走错路和精疲力尽。工作热情必须跟一个简单清晰的目标联系在一起。\n\n其次，既要担心合作太少，也要担心合作太多。过多的看上去“有帮助”的外部意见，反而会分散团队的注意力。\n\n以上就是新书《玩转工作》中对于工作的一些看法。\n\n讲述：郑磊\n\n| 周一到周日，每天零点更新，全年无间断 |\n","source":"_posts/other/do-less-going-on.md","raw":"---\ntitle: 做得更少，然后执着\ndate: 2019-03-14 22:54:37\ntags: other\ncategories: other\n---\n\n方法：做得更少，然后执着\n\n李翔及其团队\n\n工作方法\n\n《金融时报》介绍了学者莫腾·汉森的新书《玩转工作》（Great at Work）。汉森在书中提出了一个工作理念：“少即是多”带来优势的前提是，你必须专注在自己选择的“少”上面。“如果你不执着地投入，你就不会比那些做更多事情的人有优势”。\n\n<!--more-->\n\n汉森举了一个历史上的例子，1911年探险家罗尔德·阿蒙森（Roald Amundsen）和罗伯特·斯科特（Robert Falcon Scott）关于谁先到达南极的竞赛。斯科特团队有更多的钱和更大团队，交通工具包括机动雪橇、小马和狗。但是斯科特的方法过于复杂，他自己也不止一次说起过自己的“混乱的船队”，不同的团队要在不同的时间出发。而阿蒙森团队选择的交通方式非常简单：狗拉雪橇。所以，他就专注在找到最好的狗、最好的训练狗拉雪橇的人，然后获得最好的训练。“阿蒙森选择了一种方法，娴熟地掌握了它。他做得更少，然后执着地投入其中。”最后阿蒙森赢得了这场比赛，斯科特成为探险历史上的一个悲剧英雄。\n\n除了这个历史故事，汉森还研究了5000个人的表现，发现那些采用“做得更少，然后执着”策略的人，要比其他人的得分高出25%。\n\n除此之外，汉森还有几个重要的发现：首先是，要警惕“激情”。很多人把对工作的激情视为成功的一个关键，但是，激情可能导致人们走错路和精疲力尽。工作热情必须跟一个简单清晰的目标联系在一起。\n\n其次，既要担心合作太少，也要担心合作太多。过多的看上去“有帮助”的外部意见，反而会分散团队的注意力。\n\n以上就是新书《玩转工作》中对于工作的一些看法。\n\n讲述：郑磊\n\n| 周一到周日，每天零点更新，全年无间断 |\n","slug":"other/do-less-going-on","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeu800520en7n7567213","content":"<p>方法：做得更少，然后执着</p>\n<p>李翔及其团队</p>\n<p>工作方法</p>\n<p>《金融时报》介绍了学者莫腾·汉森的新书《玩转工作》（Great at Work）。汉森在书中提出了一个工作理念：“少即是多”带来优势的前提是，你必须专注在自己选择的“少”上面。“如果你不执着地投入，你就不会比那些做更多事情的人有优势”。</p>\n<a id=\"more\"></a>\n<p>汉森举了一个历史上的例子，1911年探险家罗尔德·阿蒙森（Roald Amundsen）和罗伯特·斯科特（Robert Falcon Scott）关于谁先到达南极的竞赛。斯科特团队有更多的钱和更大团队，交通工具包括机动雪橇、小马和狗。但是斯科特的方法过于复杂，他自己也不止一次说起过自己的“混乱的船队”，不同的团队要在不同的时间出发。而阿蒙森团队选择的交通方式非常简单：狗拉雪橇。所以，他就专注在找到最好的狗、最好的训练狗拉雪橇的人，然后获得最好的训练。“阿蒙森选择了一种方法，娴熟地掌握了它。他做得更少，然后执着地投入其中。”最后阿蒙森赢得了这场比赛，斯科特成为探险历史上的一个悲剧英雄。</p>\n<p>除了这个历史故事，汉森还研究了5000个人的表现，发现那些采用“做得更少，然后执着”策略的人，要比其他人的得分高出25%。</p>\n<p>除此之外，汉森还有几个重要的发现：首先是，要警惕“激情”。很多人把对工作的激情视为成功的一个关键，但是，激情可能导致人们走错路和精疲力尽。工作热情必须跟一个简单清晰的目标联系在一起。</p>\n<p>其次，既要担心合作太少，也要担心合作太多。过多的看上去“有帮助”的外部意见，反而会分散团队的注意力。</p>\n<p>以上就是新书《玩转工作》中对于工作的一些看法。</p>\n<p>讲述：郑磊</p>\n<p>| 周一到周日，每天零点更新，全年无间断 |</p>\n","site":{"data":{}},"excerpt":"<p>方法：做得更少，然后执着</p>\n<p>李翔及其团队</p>\n<p>工作方法</p>\n<p>《金融时报》介绍了学者莫腾·汉森的新书《玩转工作》（Great at Work）。汉森在书中提出了一个工作理念：“少即是多”带来优势的前提是，你必须专注在自己选择的“少”上面。“如果你不执着地投入，你就不会比那些做更多事情的人有优势”。</p>","more":"<p>汉森举了一个历史上的例子，1911年探险家罗尔德·阿蒙森（Roald Amundsen）和罗伯特·斯科特（Robert Falcon Scott）关于谁先到达南极的竞赛。斯科特团队有更多的钱和更大团队，交通工具包括机动雪橇、小马和狗。但是斯科特的方法过于复杂，他自己也不止一次说起过自己的“混乱的船队”，不同的团队要在不同的时间出发。而阿蒙森团队选择的交通方式非常简单：狗拉雪橇。所以，他就专注在找到最好的狗、最好的训练狗拉雪橇的人，然后获得最好的训练。“阿蒙森选择了一种方法，娴熟地掌握了它。他做得更少，然后执着地投入其中。”最后阿蒙森赢得了这场比赛，斯科特成为探险历史上的一个悲剧英雄。</p>\n<p>除了这个历史故事，汉森还研究了5000个人的表现，发现那些采用“做得更少，然后执着”策略的人，要比其他人的得分高出25%。</p>\n<p>除此之外，汉森还有几个重要的发现：首先是，要警惕“激情”。很多人把对工作的激情视为成功的一个关键，但是，激情可能导致人们走错路和精疲力尽。工作热情必须跟一个简单清晰的目标联系在一起。</p>\n<p>其次，既要担心合作太少，也要担心合作太多。过多的看上去“有帮助”的外部意见，反而会分散团队的注意力。</p>\n<p>以上就是新书《玩转工作》中对于工作的一些看法。</p>\n<p>讲述：郑磊</p>\n<p>| 周一到周日，每天零点更新，全年无间断 |</p>"},{"title":"Hello World","date":"2019-02-11T00:24:30.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/other/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2019-02-11 00:24:30\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"other/hello-world","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeua00550en7n680os4z","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"MySQL-python 安装","date":"2019-03-17T14:53:37.000Z","_content":"\n#### RedHat or Centos 7.5 of python2.7.5\nyum install python-devel mysql-devel gcc -y\npip install MySQL-python==1.2.5\n\n<!--more-->\n\nrefer to https://www.jianshu.com/p/1d6824a77f1a\n        https://pypi.org/project/MySQL-python/\n\n#### RedHat or Centos 7.5 of python3.6.4\nMySQL-3.23 through 5.5 and Python-2.4 through 2.7 are currently supported. Python-3.0 will be supported in a future release. PyPy is supported.\n","source":"_posts/python/MySQL-python-install.md","raw":"---\ntitle: MySQL-python 安装\ndate: 2019-03-17 14:53:37\ntags: mysql\ncategories: python\n---\n\n#### RedHat or Centos 7.5 of python2.7.5\nyum install python-devel mysql-devel gcc -y\npip install MySQL-python==1.2.5\n\n<!--more-->\n\nrefer to https://www.jianshu.com/p/1d6824a77f1a\n        https://pypi.org/project/MySQL-python/\n\n#### RedHat or Centos 7.5 of python3.6.4\nMySQL-3.23 through 5.5 and Python-2.4 through 2.7 are currently supported. Python-3.0 will be supported in a future release. PyPy is supported.\n","slug":"python/MySQL-python-install","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeuc005a0en7105fr4zc","content":"<h4 id=\"RedHat-or-Centos-7-5-of-python2-7-5\"><a href=\"#RedHat-or-Centos-7-5-of-python2-7-5\" class=\"headerlink\" title=\"RedHat or Centos 7.5 of python2.7.5\"></a>RedHat or Centos 7.5 of python2.7.5</h4><p>yum install python-devel mysql-devel gcc -y<br>pip install MySQL-python==1.2.5</p>\n<a id=\"more\"></a>\n<p>refer to <a href=\"https://www.jianshu.com/p/1d6824a77f1a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1d6824a77f1a</a><br>        <a href=\"https://pypi.org/project/MySQL-python/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/MySQL-python/</a></p>\n<h4 id=\"RedHat-or-Centos-7-5-of-python3-6-4\"><a href=\"#RedHat-or-Centos-7-5-of-python3-6-4\" class=\"headerlink\" title=\"RedHat or Centos 7.5 of python3.6.4\"></a>RedHat or Centos 7.5 of python3.6.4</h4><p>MySQL-3.23 through 5.5 and Python-2.4 through 2.7 are currently supported. Python-3.0 will be supported in a future release. PyPy is supported.</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"RedHat-or-Centos-7-5-of-python2-7-5\"><a href=\"#RedHat-or-Centos-7-5-of-python2-7-5\" class=\"headerlink\" title=\"RedHat or Centos 7.5 of python2.7.5\"></a>RedHat or Centos 7.5 of python2.7.5</h4><p>yum install python-devel mysql-devel gcc -y<br>pip install MySQL-python==1.2.5</p>","more":"<p>refer to <a href=\"https://www.jianshu.com/p/1d6824a77f1a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1d6824a77f1a</a><br>        <a href=\"https://pypi.org/project/MySQL-python/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/MySQL-python/</a></p>\n<h4 id=\"RedHat-or-Centos-7-5-of-python3-6-4\"><a href=\"#RedHat-or-Centos-7-5-of-python3-6-4\" class=\"headerlink\" title=\"RedHat or Centos 7.5 of python3.6.4\"></a>RedHat or Centos 7.5 of python3.6.4</h4><p>MySQL-3.23 through 5.5 and Python-2.4 through 2.7 are currently supported. Python-3.0 will be supported in a future release. PyPy is supported.</p>"},{"title":"python脚本在Linux Redhat7开机启动","date":"2018-12-24T23:16:30.000Z","_content":"\n有时候，python程序需要确保linux server重启的时候可以自动加载。\n\n<!--more-->\n\n````\ncd /usr/lib/systemd/system\ntouch proxy.service\n````\n\n````\n###################################################################\n[Unit]\nDescription=proxy\nAfter=multi-user.target\n \n[Service]\nType=idle\nExecStart=/usr/bin/python /appvol/ProxyServer/proxyserver.py 11081\nPrivateTmp=true\n \n[Install]\nWantedBy=multi-user.target\n````\n````\nsystemctl enable proxy\nsystemctl start proxy\n````","source":"_posts/python/python_auto_start.md","raw":"---\ntitle: python脚本在Linux Redhat7开机启动\ndate: 2018-12-24 23:16:30\ntags: linux\ncategories: python\n---\n\n有时候，python程序需要确保linux server重启的时候可以自动加载。\n\n<!--more-->\n\n````\ncd /usr/lib/systemd/system\ntouch proxy.service\n````\n\n````\n###################################################################\n[Unit]\nDescription=proxy\nAfter=multi-user.target\n \n[Service]\nType=idle\nExecStart=/usr/bin/python /appvol/ProxyServer/proxyserver.py 11081\nPrivateTmp=true\n \n[Install]\nWantedBy=multi-user.target\n````\n````\nsystemctl enable proxy\nsystemctl start proxy\n````","slug":"python/python_auto_start","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeue005d0en752k2m039","content":"<p>有时候，python程序需要确保linux server重启的时候可以自动加载。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/lib/systemd/system</span><br><span class=\"line\">touch proxy.service</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">###################################################################</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=proxy</span><br><span class=\"line\">After=multi-user.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=idle</span><br><span class=\"line\">ExecStart=/usr/bin/python /appvol/ProxyServer/proxyserver.py 11081</span><br><span class=\"line\">PrivateTmp=true</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable proxy</span><br><span class=\"line\">systemctl start proxy</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>有时候，python程序需要确保linux server重启的时候可以自动加载。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/lib/systemd/system</span><br><span class=\"line\">touch proxy.service</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">###################################################################</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=proxy</span><br><span class=\"line\">After=multi-user.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=idle</span><br><span class=\"line\">ExecStart=/usr/bin/python /appvol/ProxyServer/proxyserver.py 11081</span><br><span class=\"line\">PrivateTmp=true</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable proxy</span><br><span class=\"line\">systemctl start proxy</span><br></pre></td></tr></table></figure>"},{"title":"python命名标准","date":"2019-02-24T23:24:30.000Z","_content":"python 命名标准，个人开发参考。\n\n<!--more-->\n\n#### 1.package name\n全部小写字母，中间可以由点分隔开，作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2\n\n#### 2.module name\n全部小写字母，如果是多个单词构成，可以用下划线隔开，如dummy_threading.\n\n#### 3.class name\n采用大驼峰法命名，如SplitViewController\n\n#### 4.var name\n全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以用单下划线开头；变量类内部私有变量使用变量名可以双下划线开头。另外，避免使用小写L、大写O和大写I作为变量名。\n\n#### 5.函数名和方法名\n命名同变量命名，如balance_account\n\n#### 6 .常量名\n全部大写字母，如果是由多个单词构成，可以用下划线隔开，如YEAR和 WEEK_OF_MONTH","source":"_posts/python/python_name_standard.md","raw":"---\ntitle: python命名标准\ndate: 2019-02-24 23:24:30\ntags: standard\ncategories: python\n---\npython 命名标准，个人开发参考。\n\n<!--more-->\n\n#### 1.package name\n全部小写字母，中间可以由点分隔开，作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2\n\n#### 2.module name\n全部小写字母，如果是多个单词构成，可以用下划线隔开，如dummy_threading.\n\n#### 3.class name\n采用大驼峰法命名，如SplitViewController\n\n#### 4.var name\n全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以用单下划线开头；变量类内部私有变量使用变量名可以双下划线开头。另外，避免使用小写L、大写O和大写I作为变量名。\n\n#### 5.函数名和方法名\n命名同变量命名，如balance_account\n\n#### 6 .常量名\n全部大写字母，如果是由多个单词构成，可以用下划线隔开，如YEAR和 WEEK_OF_MONTH","slug":"python/python_name_standard","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeuh005h0en7vpna7jyc","content":"<p>python 命名标准，个人开发参考。</p>\n<a id=\"more\"></a>\n<h4 id=\"1-package-name\"><a href=\"#1-package-name\" class=\"headerlink\" title=\"1.package name\"></a>1.package name</h4><p>全部小写字母，中间可以由点分隔开，作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2</p>\n<h4 id=\"2-module-name\"><a href=\"#2-module-name\" class=\"headerlink\" title=\"2.module name\"></a>2.module name</h4><p>全部小写字母，如果是多个单词构成，可以用下划线隔开，如dummy_threading.</p>\n<h4 id=\"3-class-name\"><a href=\"#3-class-name\" class=\"headerlink\" title=\"3.class name\"></a>3.class name</h4><p>采用大驼峰法命名，如SplitViewController</p>\n<h4 id=\"4-var-name\"><a href=\"#4-var-name\" class=\"headerlink\" title=\"4.var name\"></a>4.var name</h4><p>全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以用单下划线开头；变量类内部私有变量使用变量名可以双下划线开头。另外，避免使用小写L、大写O和大写I作为变量名。</p>\n<h4 id=\"5-函数名和方法名\"><a href=\"#5-函数名和方法名\" class=\"headerlink\" title=\"5.函数名和方法名\"></a>5.函数名和方法名</h4><p>命名同变量命名，如balance_account</p>\n<h4 id=\"6-常量名\"><a href=\"#6-常量名\" class=\"headerlink\" title=\"6 .常量名\"></a>6 .常量名</h4><p>全部大写字母，如果是由多个单词构成，可以用下划线隔开，如YEAR和 WEEK_OF_MONTH</p>\n","site":{"data":{}},"excerpt":"<p>python 命名标准，个人开发参考。</p>","more":"<h4 id=\"1-package-name\"><a href=\"#1-package-name\" class=\"headerlink\" title=\"1.package name\"></a>1.package name</h4><p>全部小写字母，中间可以由点分隔开，作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2</p>\n<h4 id=\"2-module-name\"><a href=\"#2-module-name\" class=\"headerlink\" title=\"2.module name\"></a>2.module name</h4><p>全部小写字母，如果是多个单词构成，可以用下划线隔开，如dummy_threading.</p>\n<h4 id=\"3-class-name\"><a href=\"#3-class-name\" class=\"headerlink\" title=\"3.class name\"></a>3.class name</h4><p>采用大驼峰法命名，如SplitViewController</p>\n<h4 id=\"4-var-name\"><a href=\"#4-var-name\" class=\"headerlink\" title=\"4.var name\"></a>4.var name</h4><p>全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以用单下划线开头；变量类内部私有变量使用变量名可以双下划线开头。另外，避免使用小写L、大写O和大写I作为变量名。</p>\n<h4 id=\"5-函数名和方法名\"><a href=\"#5-函数名和方法名\" class=\"headerlink\" title=\"5.函数名和方法名\"></a>5.函数名和方法名</h4><p>命名同变量命名，如balance_account</p>\n<h4 id=\"6-常量名\"><a href=\"#6-常量名\" class=\"headerlink\" title=\"6 .常量名\"></a>6 .常量名</h4><p>全部大写字母，如果是由多个单词构成，可以用下划线隔开，如YEAR和 WEEK_OF_MONTH</p>"},{"title":"python第三方库安装-多种方式","date":"2018-02-26T12:24:30.000Z","_content":"\npip 是python最重要的包管理工具，今天我们来总结下pip第三方包安装的多种方式。\n\n<!--more-->\n\n#### 第一种方式：安装whl文件\n\npip install whatever.whl\n\n#### 第二种方式：安装tar.gz文件\n\n一般是先解压，然后进入目录之后，有setup.py文件\n\n通过命令 python setup.py install安装。\n\n \n#### 第三种方式：pip在线安装\n\npip已经收录了大部分第三方库，https://pypi.org\n\n##### 1、如果机器可以联网：\n\npip install package_name==1.0.0 安装指定版本\n\npip install package_name 安装最新版本\n\n##### 2、如果机器不能联网：\n\n2.1打包已经安装的包（注意：打包的操作系统要跟目标操作系统版本一致）\n\npip list #查看安装的包\n\npip freeze >requirements.txt #将已经安装的包名称写入到文件\n\npip download -r requirements.txt #将文件中的包下载到当前目录\n\n2.2离线情况下安装打包好的包\n\npip install --no-index --find-links=\\usr\\src\\packs\\ mysql-connector 单个安装\n\npip install --no-index --find-links=\\usr\\src\\packs\\ -r requirements.txt 批量安装\n————————————————\n版权声明：本文为CSDN博主「比永远更永远」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/byygyy/article/details/83746726","source":"_posts/python/python_pip_install.md","raw":"---\ntitle: python第三方库安装-多种方式\ndate: 2018-02-26 12:24:30\ntags: pip\ncategories: python\n---\n\npip 是python最重要的包管理工具，今天我们来总结下pip第三方包安装的多种方式。\n\n<!--more-->\n\n#### 第一种方式：安装whl文件\n\npip install whatever.whl\n\n#### 第二种方式：安装tar.gz文件\n\n一般是先解压，然后进入目录之后，有setup.py文件\n\n通过命令 python setup.py install安装。\n\n \n#### 第三种方式：pip在线安装\n\npip已经收录了大部分第三方库，https://pypi.org\n\n##### 1、如果机器可以联网：\n\npip install package_name==1.0.0 安装指定版本\n\npip install package_name 安装最新版本\n\n##### 2、如果机器不能联网：\n\n2.1打包已经安装的包（注意：打包的操作系统要跟目标操作系统版本一致）\n\npip list #查看安装的包\n\npip freeze >requirements.txt #将已经安装的包名称写入到文件\n\npip download -r requirements.txt #将文件中的包下载到当前目录\n\n2.2离线情况下安装打包好的包\n\npip install --no-index --find-links=\\usr\\src\\packs\\ mysql-connector 单个安装\n\npip install --no-index --find-links=\\usr\\src\\packs\\ -r requirements.txt 批量安装\n————————————————\n版权声明：本文为CSDN博主「比永远更永远」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/byygyy/article/details/83746726","slug":"python/python_pip_install","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeul005k0en70ydo69d9","content":"<p>pip 是python最重要的包管理工具，今天我们来总结下pip第三方包安装的多种方式。</p>\n<a id=\"more\"></a>\n<h4 id=\"第一种方式：安装whl文件\"><a href=\"#第一种方式：安装whl文件\" class=\"headerlink\" title=\"第一种方式：安装whl文件\"></a>第一种方式：安装whl文件</h4><p>pip install whatever.whl</p>\n<h4 id=\"第二种方式：安装tar-gz文件\"><a href=\"#第二种方式：安装tar-gz文件\" class=\"headerlink\" title=\"第二种方式：安装tar.gz文件\"></a>第二种方式：安装tar.gz文件</h4><p>一般是先解压，然后进入目录之后，有setup.py文件</p>\n<p>通过命令 python setup.py install安装。</p>\n<h4 id=\"第三种方式：pip在线安装\"><a href=\"#第三种方式：pip在线安装\" class=\"headerlink\" title=\"第三种方式：pip在线安装\"></a>第三种方式：pip在线安装</h4><p>pip已经收录了大部分第三方库，<a href=\"https://pypi.org\" target=\"_blank\" rel=\"noopener\">https://pypi.org</a></p>\n<h5 id=\"1、如果机器可以联网：\"><a href=\"#1、如果机器可以联网：\" class=\"headerlink\" title=\"1、如果机器可以联网：\"></a>1、如果机器可以联网：</h5><p>pip install package_name==1.0.0 安装指定版本</p>\n<p>pip install package_name 安装最新版本</p>\n<h5 id=\"2、如果机器不能联网：\"><a href=\"#2、如果机器不能联网：\" class=\"headerlink\" title=\"2、如果机器不能联网：\"></a>2、如果机器不能联网：</h5><p>2.1打包已经安装的包（注意：打包的操作系统要跟目标操作系统版本一致）</p>\n<p>pip list #查看安装的包</p>\n<p>pip freeze &gt;requirements.txt #将已经安装的包名称写入到文件</p>\n<p>pip download -r requirements.txt #将文件中的包下载到当前目录</p>\n<p>2.2离线情况下安装打包好的包</p>\n<p>pip install –no-index –find-links=\\usr\\src\\packs\\ mysql-connector 单个安装</p>\n<p>pip install –no-index –find-links=\\usr\\src\\packs\\ -r requirements.txt 批量安装<br>————————————————<br>版权声明：本文为CSDN博主「比永远更永远」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/byygyy/article/details/83746726\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/byygyy/article/details/83746726</a></p>\n","site":{"data":{}},"excerpt":"<p>pip 是python最重要的包管理工具，今天我们来总结下pip第三方包安装的多种方式。</p>","more":"<h4 id=\"第一种方式：安装whl文件\"><a href=\"#第一种方式：安装whl文件\" class=\"headerlink\" title=\"第一种方式：安装whl文件\"></a>第一种方式：安装whl文件</h4><p>pip install whatever.whl</p>\n<h4 id=\"第二种方式：安装tar-gz文件\"><a href=\"#第二种方式：安装tar-gz文件\" class=\"headerlink\" title=\"第二种方式：安装tar.gz文件\"></a>第二种方式：安装tar.gz文件</h4><p>一般是先解压，然后进入目录之后，有setup.py文件</p>\n<p>通过命令 python setup.py install安装。</p>\n<h4 id=\"第三种方式：pip在线安装\"><a href=\"#第三种方式：pip在线安装\" class=\"headerlink\" title=\"第三种方式：pip在线安装\"></a>第三种方式：pip在线安装</h4><p>pip已经收录了大部分第三方库，<a href=\"https://pypi.org\" target=\"_blank\" rel=\"noopener\">https://pypi.org</a></p>\n<h5 id=\"1、如果机器可以联网：\"><a href=\"#1、如果机器可以联网：\" class=\"headerlink\" title=\"1、如果机器可以联网：\"></a>1、如果机器可以联网：</h5><p>pip install package_name==1.0.0 安装指定版本</p>\n<p>pip install package_name 安装最新版本</p>\n<h5 id=\"2、如果机器不能联网：\"><a href=\"#2、如果机器不能联网：\" class=\"headerlink\" title=\"2、如果机器不能联网：\"></a>2、如果机器不能联网：</h5><p>2.1打包已经安装的包（注意：打包的操作系统要跟目标操作系统版本一致）</p>\n<p>pip list #查看安装的包</p>\n<p>pip freeze &gt;requirements.txt #将已经安装的包名称写入到文件</p>\n<p>pip download -r requirements.txt #将文件中的包下载到当前目录</p>\n<p>2.2离线情况下安装打包好的包</p>\n<p>pip install –no-index –find-links=\\usr\\src\\packs\\ mysql-connector 单个安装</p>\n<p>pip install –no-index –find-links=\\usr\\src\\packs\\ -r requirements.txt 批量安装<br>————————————————<br>版权声明：本文为CSDN博主「比永远更永远」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/byygyy/article/details/83746726\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/byygyy/article/details/83746726</a></p>"},{"title":"简单而直接的python web框架：web.py","date":"2019-01-22T23:24:30.000Z","_content":"\nweb.py 是一个很优秀很简洁的python web框架，就连腾讯小程序和微信开发的demo文档都爱用web.py举例子，是一个很有学术价值的框架。\n虽然web.py的作者已经去世，他留给后人的经典仍值得我们学习。感谢！\n\n<!--more-->\n\nRefer to：https://www.oschina.net/question/5189_4306\nWeb.py github 地址：https://github.com/webpy/webpy        https://pypi.python.org/pypi/web.py\nWeb.py Cookbook 简体中文版：http://webpy.org/cookbook/index.zh-cn\nweb.py 0.3 新手指南：http://webpy.org/docs/0.3/tutorial.zh-cn\nwebpy 官网文档：http://webpy.org/\nweb.py 十分钟创建简易博客：http://blog.csdn.net/freeking101/article/details/53020728\n一个简单的web.py论坛：http://www.cnblogs.com/russellluo/p/3240564.html","source":"_posts/python/python_web.py.md","raw":"---\ntitle: 简单而直接的python web框架：web.py\ndate: 2019-01-22 23:24:30\ntags: web\ncategories: python\n---\n\nweb.py 是一个很优秀很简洁的python web框架，就连腾讯小程序和微信开发的demo文档都爱用web.py举例子，是一个很有学术价值的框架。\n虽然web.py的作者已经去世，他留给后人的经典仍值得我们学习。感谢！\n\n<!--more-->\n\nRefer to：https://www.oschina.net/question/5189_4306\nWeb.py github 地址：https://github.com/webpy/webpy        https://pypi.python.org/pypi/web.py\nWeb.py Cookbook 简体中文版：http://webpy.org/cookbook/index.zh-cn\nweb.py 0.3 新手指南：http://webpy.org/docs/0.3/tutorial.zh-cn\nwebpy 官网文档：http://webpy.org/\nweb.py 十分钟创建简易博客：http://blog.csdn.net/freeking101/article/details/53020728\n一个简单的web.py论坛：http://www.cnblogs.com/russellluo/p/3240564.html","slug":"python/python_web.py","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeun005n0en7081v4z82","content":"<p>web.py 是一个很优秀很简洁的python web框架，就连腾讯小程序和微信开发的demo文档都爱用web.py举例子，是一个很有学术价值的框架。<br>虽然web.py的作者已经去世，他留给后人的经典仍值得我们学习。感谢！</p>\n<a id=\"more\"></a>\n<p>Refer to：<a href=\"https://www.oschina.net/question/5189_4306\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/question/5189_4306</a><br>Web.py github 地址：<a href=\"https://github.com/webpy/webpy\" target=\"_blank\" rel=\"noopener\">https://github.com/webpy/webpy</a>        <a href=\"https://pypi.python.org/pypi/web.py\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/web.py</a><br>Web.py Cookbook 简体中文版：<a href=\"http://webpy.org/cookbook/index.zh-cn\" target=\"_blank\" rel=\"noopener\">http://webpy.org/cookbook/index.zh-cn</a><br>web.py 0.3 新手指南：<a href=\"http://webpy.org/docs/0.3/tutorial.zh-cn\" target=\"_blank\" rel=\"noopener\">http://webpy.org/docs/0.3/tutorial.zh-cn</a><br>webpy 官网文档：<a href=\"http://webpy.org/\" target=\"_blank\" rel=\"noopener\">http://webpy.org/</a><br>web.py 十分钟创建简易博客：<a href=\"http://blog.csdn.net/freeking101/article/details/53020728\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/freeking101/article/details/53020728</a><br>一个简单的web.py论坛：<a href=\"http://www.cnblogs.com/russellluo/p/3240564.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/russellluo/p/3240564.html</a></p>\n","site":{"data":{}},"excerpt":"<p>web.py 是一个很优秀很简洁的python web框架，就连腾讯小程序和微信开发的demo文档都爱用web.py举例子，是一个很有学术价值的框架。<br>虽然web.py的作者已经去世，他留给后人的经典仍值得我们学习。感谢！</p>","more":"<p>Refer to：<a href=\"https://www.oschina.net/question/5189_4306\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/question/5189_4306</a><br>Web.py github 地址：<a href=\"https://github.com/webpy/webpy\" target=\"_blank\" rel=\"noopener\">https://github.com/webpy/webpy</a>        <a href=\"https://pypi.python.org/pypi/web.py\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/web.py</a><br>Web.py Cookbook 简体中文版：<a href=\"http://webpy.org/cookbook/index.zh-cn\" target=\"_blank\" rel=\"noopener\">http://webpy.org/cookbook/index.zh-cn</a><br>web.py 0.3 新手指南：<a href=\"http://webpy.org/docs/0.3/tutorial.zh-cn\" target=\"_blank\" rel=\"noopener\">http://webpy.org/docs/0.3/tutorial.zh-cn</a><br>webpy 官网文档：<a href=\"http://webpy.org/\" target=\"_blank\" rel=\"noopener\">http://webpy.org/</a><br>web.py 十分钟创建简易博客：<a href=\"http://blog.csdn.net/freeking101/article/details/53020728\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/freeking101/article/details/53020728</a><br>一个简单的web.py论坛：<a href=\"http://www.cnblogs.com/russellluo/p/3240564.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/russellluo/p/3240564.html</a></p>"},{"title":"在sae中运行web.py应用","date":"2019-02-24T23:24:30.000Z","_content":"\nsae 是新浪推出的PaaS业务，可以提供免运维的容器服务，官方网站（ https://www.sinacloud.com/ ）\n假设您已经在本地开发好了web.py 应用，您可以通过github客户端上传代码到sae中新建的python应用中。\n只要web.py应用包含文件index.wsgi，新浪云就会加载我们的应用。\n\n<!--more-->\n```index.wsgi\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# file code.py\nimport sys\nimport os\nimport web\n\nurls = (\"/\", \"Index\",\n        )\napp = web.application(urls, globals())\napplication = app.wsgifunc()\nweb.config.debug = True\n\nclass Index:\n    def __init__(self):\n        pass\n\n    def GET( self ):\n        if session.login == 1:\n            data = index1(session.user)\n            return render_template('index.html', name=data )\n        else:\n            raise web.seeother('/login')\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n其他内容，可以自行参考sae官方文档。https://www.sinacloud.com/doc/sae/python.html","source":"_posts/python/python_web_sea.md","raw":"---\ntitle: 在sae中运行web.py应用\ndate: 2019-02-24 23:24:30\ntags: cloud\ncategories: python\n---\n\nsae 是新浪推出的PaaS业务，可以提供免运维的容器服务，官方网站（ https://www.sinacloud.com/ ）\n假设您已经在本地开发好了web.py 应用，您可以通过github客户端上传代码到sae中新建的python应用中。\n只要web.py应用包含文件index.wsgi，新浪云就会加载我们的应用。\n\n<!--more-->\n```index.wsgi\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# file code.py\nimport sys\nimport os\nimport web\n\nurls = (\"/\", \"Index\",\n        )\napp = web.application(urls, globals())\napplication = app.wsgifunc()\nweb.config.debug = True\n\nclass Index:\n    def __init__(self):\n        pass\n\n    def GET( self ):\n        if session.login == 1:\n            data = index1(session.user)\n            return render_template('index.html', name=data )\n        else:\n            raise web.seeother('/login')\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n其他内容，可以自行参考sae官方文档。https://www.sinacloud.com/doc/sae/python.html","slug":"python/python_web_sea","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeur005r0en72x20e5ir","content":"<p>sae 是新浪推出的PaaS业务，可以提供免运维的容器服务，官方网站（ <a href=\"https://www.sinacloud.com/\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/</a> ）<br>假设您已经在本地开发好了web.py 应用，您可以通过github客户端上传代码到sae中新建的python应用中。<br>只要web.py应用包含文件index.wsgi，新浪云就会加载我们的应用。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"># file code.py</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import os</span><br><span class=\"line\">import web</span><br><span class=\"line\"></span><br><span class=\"line\">urls = (&quot;/&quot;, &quot;Index&quot;,</span><br><span class=\"line\">        )</span><br><span class=\"line\">app = web.application(urls, globals())</span><br><span class=\"line\">application = app.wsgifunc()</span><br><span class=\"line\">web.config.debug = True</span><br><span class=\"line\"></span><br><span class=\"line\">class Index:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">    def GET( self ):</span><br><span class=\"line\">        if session.login == 1:</span><br><span class=\"line\">            data = index1(session.user)</span><br><span class=\"line\">            return render_template(&apos;index.html&apos;, name=data )</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            raise web.seeother(&apos;/login&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>其他内容，可以自行参考sae官方文档。<a href=\"https://www.sinacloud.com/doc/sae/python.html\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/doc/sae/python.html</a></p>\n","site":{"data":{}},"excerpt":"<p>sae 是新浪推出的PaaS业务，可以提供免运维的容器服务，官方网站（ <a href=\"https://www.sinacloud.com/\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/</a> ）<br>假设您已经在本地开发好了web.py 应用，您可以通过github客户端上传代码到sae中新建的python应用中。<br>只要web.py应用包含文件index.wsgi，新浪云就会加载我们的应用。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"># file code.py</span><br><span class=\"line\">import sys</span><br><span class=\"line\">import os</span><br><span class=\"line\">import web</span><br><span class=\"line\"></span><br><span class=\"line\">urls = (&quot;/&quot;, &quot;Index&quot;,</span><br><span class=\"line\">        )</span><br><span class=\"line\">app = web.application(urls, globals())</span><br><span class=\"line\">application = app.wsgifunc()</span><br><span class=\"line\">web.config.debug = True</span><br><span class=\"line\"></span><br><span class=\"line\">class Index:</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">    def GET( self ):</span><br><span class=\"line\">        if session.login == 1:</span><br><span class=\"line\">            data = index1(session.user)</span><br><span class=\"line\">            return render_template(&apos;index.html&apos;, name=data )</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            raise web.seeother(&apos;/login&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>其他内容，可以自行参考sae官方文档。<a href=\"https://www.sinacloud.com/doc/sae/python.html\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/doc/sae/python.html</a></p>"},{"title":"Atom入坑必备插件","date":"2019-03-14T22:54:37.000Z","_content":"\nAtom作为Javascript/CSS/HTML等前端编辑器利器，其强大功能依靠各种插件，以下是笔者在入坑阶段，精挑细选总结出的必不可少的插件，熟悉运用这些插件，一定成吨提高生产效率。安装这些插件只需要在Atom的File ->setting ->install中输入插件名称查到后即可安装：\n<!--more-->\n1.Sync Settings\n搭配github，同步你的atom插件信息，配置信息，让你轻松实现一台电脑配置，多台电脑共享。\n\n2.Emmet\n能够基于Emmet语法产生HTML，做过前段开发的不会不知道这个插件吧。好用到哭。\n\n3.Atom Beautify\n代码格式化工具，可以设置在保存时自动格式化，别提有多方便了。支持html，css，javascript，java，go等等，反正常见的语言基本都支持了。\n\n4.Autocomplete Paths\n自动补全文件路径，这个功能肯定使用嘛，完全避免了路径输入错误带来的bug。\n\n5.Auto close HTML\n自动输入对应的HTML关闭标签，虽然简答但是实用。\n\n6.Minimap\n这个插件不用介绍了吧，从sublime开始，一直使用。从未遗忘。\n\n7.color-picker\n取色器，让你在代码编写去直接打开取色板，拾取颜色。\n\n8.vim-mode\nvim死忠粉必备插件。\n\n9.git-plus\n让你轻松的在编辑器里管理你的git项目，各种常用git功能，信手拈来。\n\n10.file-icons\n很简单，为不同类型的文件添加一个漂亮的小图标，颜控开发者必备。\n\n11.docblockr\n文档化注释，你懂的，团队协作规范注释必备插件。\n\n12.Linter Jshint\n帮助你编写专业的js代码，js开发者必备插件。\n\n作者：incomplete_cat\n来源：CSDN\n原文：https://blog.csdn.net/m13026178198/article/details/52843849\n版权声明：本文为博主原创文章，转载请附上博文链接！\n","source":"_posts/tools/atom_plus_1.md","raw":"---\ntitle: Atom入坑必备插件\ndate: 2019-03-14 22:54:37\ntags: tools\ncategories: tools\n---\n\nAtom作为Javascript/CSS/HTML等前端编辑器利器，其强大功能依靠各种插件，以下是笔者在入坑阶段，精挑细选总结出的必不可少的插件，熟悉运用这些插件，一定成吨提高生产效率。安装这些插件只需要在Atom的File ->setting ->install中输入插件名称查到后即可安装：\n<!--more-->\n1.Sync Settings\n搭配github，同步你的atom插件信息，配置信息，让你轻松实现一台电脑配置，多台电脑共享。\n\n2.Emmet\n能够基于Emmet语法产生HTML，做过前段开发的不会不知道这个插件吧。好用到哭。\n\n3.Atom Beautify\n代码格式化工具，可以设置在保存时自动格式化，别提有多方便了。支持html，css，javascript，java，go等等，反正常见的语言基本都支持了。\n\n4.Autocomplete Paths\n自动补全文件路径，这个功能肯定使用嘛，完全避免了路径输入错误带来的bug。\n\n5.Auto close HTML\n自动输入对应的HTML关闭标签，虽然简答但是实用。\n\n6.Minimap\n这个插件不用介绍了吧，从sublime开始，一直使用。从未遗忘。\n\n7.color-picker\n取色器，让你在代码编写去直接打开取色板，拾取颜色。\n\n8.vim-mode\nvim死忠粉必备插件。\n\n9.git-plus\n让你轻松的在编辑器里管理你的git项目，各种常用git功能，信手拈来。\n\n10.file-icons\n很简单，为不同类型的文件添加一个漂亮的小图标，颜控开发者必备。\n\n11.docblockr\n文档化注释，你懂的，团队协作规范注释必备插件。\n\n12.Linter Jshint\n帮助你编写专业的js代码，js开发者必备插件。\n\n作者：incomplete_cat\n来源：CSDN\n原文：https://blog.csdn.net/m13026178198/article/details/52843849\n版权声明：本文为博主原创文章，转载请附上博文链接！\n","slug":"tools/atom_plus_1","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeuv005u0en7jo0xwltg","content":"<p>Atom作为Javascript/CSS/HTML等前端编辑器利器，其强大功能依靠各种插件，以下是笔者在入坑阶段，精挑细选总结出的必不可少的插件，熟悉运用这些插件，一定成吨提高生产效率。安装这些插件只需要在Atom的File -&gt;setting -&gt;install中输入插件名称查到后即可安装：<br><a id=\"more\"></a><br>1.Sync Settings<br>搭配github，同步你的atom插件信息，配置信息，让你轻松实现一台电脑配置，多台电脑共享。</p>\n<p>2.Emmet<br>能够基于Emmet语法产生HTML，做过前段开发的不会不知道这个插件吧。好用到哭。</p>\n<p>3.Atom Beautify<br>代码格式化工具，可以设置在保存时自动格式化，别提有多方便了。支持html，css，javascript，java，go等等，反正常见的语言基本都支持了。</p>\n<p>4.Autocomplete Paths<br>自动补全文件路径，这个功能肯定使用嘛，完全避免了路径输入错误带来的bug。</p>\n<p>5.Auto close HTML<br>自动输入对应的HTML关闭标签，虽然简答但是实用。</p>\n<p>6.Minimap<br>这个插件不用介绍了吧，从sublime开始，一直使用。从未遗忘。</p>\n<p>7.color-picker<br>取色器，让你在代码编写去直接打开取色板，拾取颜色。</p>\n<p>8.vim-mode<br>vim死忠粉必备插件。</p>\n<p>9.git-plus<br>让你轻松的在编辑器里管理你的git项目，各种常用git功能，信手拈来。</p>\n<p>10.file-icons<br>很简单，为不同类型的文件添加一个漂亮的小图标，颜控开发者必备。</p>\n<p>11.docblockr<br>文档化注释，你懂的，团队协作规范注释必备插件。</p>\n<p>12.Linter Jshint<br>帮助你编写专业的js代码，js开发者必备插件。</p>\n<p>作者：incomplete_cat<br>来源：CSDN<br>原文：<a href=\"https://blog.csdn.net/m13026178198/article/details/52843849\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/m13026178198/article/details/52843849</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>\n","site":{"data":{}},"excerpt":"<p>Atom作为Javascript/CSS/HTML等前端编辑器利器，其强大功能依靠各种插件，以下是笔者在入坑阶段，精挑细选总结出的必不可少的插件，熟悉运用这些插件，一定成吨提高生产效率。安装这些插件只需要在Atom的File -&gt;setting -&gt;install中输入插件名称查到后即可安装：<br>","more":"<br>1.Sync Settings<br>搭配github，同步你的atom插件信息，配置信息，让你轻松实现一台电脑配置，多台电脑共享。</p>\n<p>2.Emmet<br>能够基于Emmet语法产生HTML，做过前段开发的不会不知道这个插件吧。好用到哭。</p>\n<p>3.Atom Beautify<br>代码格式化工具，可以设置在保存时自动格式化，别提有多方便了。支持html，css，javascript，java，go等等，反正常见的语言基本都支持了。</p>\n<p>4.Autocomplete Paths<br>自动补全文件路径，这个功能肯定使用嘛，完全避免了路径输入错误带来的bug。</p>\n<p>5.Auto close HTML<br>自动输入对应的HTML关闭标签，虽然简答但是实用。</p>\n<p>6.Minimap<br>这个插件不用介绍了吧，从sublime开始，一直使用。从未遗忘。</p>\n<p>7.color-picker<br>取色器，让你在代码编写去直接打开取色板，拾取颜色。</p>\n<p>8.vim-mode<br>vim死忠粉必备插件。</p>\n<p>9.git-plus<br>让你轻松的在编辑器里管理你的git项目，各种常用git功能，信手拈来。</p>\n<p>10.file-icons<br>很简单，为不同类型的文件添加一个漂亮的小图标，颜控开发者必备。</p>\n<p>11.docblockr<br>文档化注释，你懂的，团队协作规范注释必备插件。</p>\n<p>12.Linter Jshint<br>帮助你编写专业的js代码，js开发者必备插件。</p>\n<p>作者：incomplete_cat<br>来源：CSDN<br>原文：<a href=\"https://blog.csdn.net/m13026178198/article/details/52843849\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/m13026178198/article/details/52843849</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>"},{"title":"github quick start","date":"2019-03-05T14:15:37.000Z","_content":"\n# install git at you laptop\n`https://git-scm.com/downloads`\n\n# config git at you laptop\n```\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\ngit config --global core.autocrlf false\ngit config --global core.safecrlf true\n```\n<!--more-->\n# add a project at github\nNew a project at github\n\n# git clone project at laptop\n`git clone github repo address`\n\n# open project at atom\n```\npackage - github - Toggle git tab\nselect a branch\nedit the files\ngit commit\ngit push\n```\n","source":"_posts/tools/github quick start.md","raw":"---\ntitle: github quick start\ndate: 2019-03-05 14:15:37\ntags: git\n---\n\n# install git at you laptop\n`https://git-scm.com/downloads`\n\n# config git at you laptop\n```\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\ngit config --global core.autocrlf false\ngit config --global core.safecrlf true\n```\n<!--more-->\n# add a project at github\nNew a project at github\n\n# git clone project at laptop\n`git clone github repo address`\n\n# open project at atom\n```\npackage - github - Toggle git tab\nselect a branch\nedit the files\ngit commit\ngit push\n```\n","slug":"tools/github quick start","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdeux005y0en7n9m1uwpv","content":"<h1 id=\"install-git-at-you-laptop\"><a href=\"#install-git-at-you-laptop\" class=\"headerlink\" title=\"install git at you laptop\"></a>install git at you laptop</h1><p><code>https://git-scm.com/downloads</code></p>\n<h1 id=\"config-git-at-you-laptop\"><a href=\"#config-git-at-you-laptop\" class=\"headerlink\" title=\"config git at you laptop\"></a>config git at you laptop</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">git config --global user.email &quot;email@example.com&quot;</span><br><span class=\"line\">git config --global core.autocrlf false</span><br><span class=\"line\">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"add-a-project-at-github\"><a href=\"#add-a-project-at-github\" class=\"headerlink\" title=\"add a project at github\"></a>add a project at github</h1><p>New a project at github</p>\n<h1 id=\"git-clone-project-at-laptop\"><a href=\"#git-clone-project-at-laptop\" class=\"headerlink\" title=\"git clone project at laptop\"></a>git clone project at laptop</h1><p><code>git clone github repo address</code></p>\n<h1 id=\"open-project-at-atom\"><a href=\"#open-project-at-atom\" class=\"headerlink\" title=\"open project at atom\"></a>open project at atom</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package - github - Toggle git tab</span><br><span class=\"line\">select a branch</span><br><span class=\"line\">edit the files</span><br><span class=\"line\">git commit</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"install-git-at-you-laptop\"><a href=\"#install-git-at-you-laptop\" class=\"headerlink\" title=\"install git at you laptop\"></a>install git at you laptop</h1><p><code>https://git-scm.com/downloads</code></p>\n<h1 id=\"config-git-at-you-laptop\"><a href=\"#config-git-at-you-laptop\" class=\"headerlink\" title=\"config git at you laptop\"></a>config git at you laptop</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">git config --global user.email &quot;email@example.com&quot;</span><br><span class=\"line\">git config --global core.autocrlf false</span><br><span class=\"line\">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"add-a-project-at-github\"><a href=\"#add-a-project-at-github\" class=\"headerlink\" title=\"add a project at github\"></a>add a project at github</h1><p>New a project at github</p>\n<h1 id=\"git-clone-project-at-laptop\"><a href=\"#git-clone-project-at-laptop\" class=\"headerlink\" title=\"git clone project at laptop\"></a>git clone project at laptop</h1><p><code>git clone github repo address</code></p>\n<h1 id=\"open-project-at-atom\"><a href=\"#open-project-at-atom\" class=\"headerlink\" title=\"open project at atom\"></a>open project at atom</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package - github - Toggle git tab</span><br><span class=\"line\">select a branch</span><br><span class=\"line\">edit the files</span><br><span class=\"line\">git commit</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>"},{"title":"ANSIBLE快速安装（使用PIP）","date":"2019-06-20T14:53:37.000Z","_content":"\n* 1.使用python pip 安装\n首先确保你的server安装了pip，并且可以正常使用，可以立即使用如下命令安装\npip install ansible==2.6.4\nansible --version\n\n ![avatar](/images/ansible-version.png)\n\n当前版本信息详见https://pypi.org/project/ansible/2.6.4/#history\n所有版本信息详见https://pypi.org/project/ansible/\n\n* 2.使用Linux yum 安装\n不再赘诉","source":"_posts/ansible/ansible_install.md","raw":"---\ntitle: ANSIBLE快速安装（使用PIP）\ndate: 2019-06-20 14:53:37\ntags: ansible\ncategories: ansible\n---\n\n* 1.使用python pip 安装\n首先确保你的server安装了pip，并且可以正常使用，可以立即使用如下命令安装\npip install ansible==2.6.4\nansible --version\n\n ![avatar](/images/ansible-version.png)\n\n当前版本信息详见https://pypi.org/project/ansible/2.6.4/#history\n所有版本信息详见https://pypi.org/project/ansible/\n\n* 2.使用Linux yum 安装\n不再赘诉","slug":"ansible/ansible_install","published":1,"updated":"2020-04-07T16:18:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9mxdev000620en7hwvaejyf","content":"<ul>\n<li><p>1.使用python pip 安装<br>首先确保你的server安装了pip，并且可以正常使用，可以立即使用如下命令安装<br>pip install ansible==2.6.4<br>ansible –version</p>\n<p><img src=\"/images/ansible-version.png\" alt=\"avatar\"></p>\n</li>\n</ul>\n<p>当前版本信息详见<a href=\"https://pypi.org/project/ansible/2.6.4/#history\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/ansible/2.6.4/#history</a><br>所有版本信息详见<a href=\"https://pypi.org/project/ansible/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/ansible/</a></p>\n<ul>\n<li>2.使用Linux yum 安装<br>不再赘诉</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>1.使用python pip 安装<br>首先确保你的server安装了pip，并且可以正常使用，可以立即使用如下命令安装<br>pip install ansible==2.6.4<br>ansible –version</p>\n<p><img src=\"/images/ansible-version.png\" alt=\"avatar\"></p>\n</li>\n</ul>\n<p>当前版本信息详见<a href=\"https://pypi.org/project/ansible/2.6.4/#history\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/ansible/2.6.4/#history</a><br>所有版本信息详见<a href=\"https://pypi.org/project/ansible/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/project/ansible/</a></p>\n<ul>\n<li>2.使用Linux yum 安装<br>不再赘诉</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9mxdemt00010en71fvoia7p","category_id":"ck9mxden600020en7f58o0lq1","_id":"ck9mxdena00050en75224nc0j"},{"post_id":"ck9mxdepe000b0en7j2e7rmq5","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdepm000i0en71ovxb73d"},{"post_id":"ck9mxdeoy00060en7z995wzd7","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdepr000n0en70toba2lq"},{"post_id":"ck9mxdepf000c0en7erkzubc3","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdept000q0en7qh1fh1yz"},{"post_id":"ck9mxdepj000g0en7ode37i77","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdepv000u0en738vwhs3k"},{"post_id":"ck9mxdep000070en7ochxr64s","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdepz000x0en7yufzg453"},{"post_id":"ck9mxdepk000h0en7w9aful8z","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeq100100en7lehhvqz0"},{"post_id":"ck9mxdepp000m0en7hddzoabc","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeq300120en7501xmmch"},{"post_id":"ck9mxdep6000a0en7ad2rvl8e","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeq600160en70cm3gbyw"},{"post_id":"ck9mxdeps000p0en7byrfkttu","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqd00180en7g4pp82e7"},{"post_id":"ck9mxdepu000t0en73g8mje5r","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqf001a0en7mpyhzq1b"},{"post_id":"ck9mxdepx000w0en7xya2vtca","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqk001e0en7dhiohbnf"},{"post_id":"ck9mxdeq0000z0en7edaetfvm","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqm001g0en7nxiy4r3y"},{"post_id":"ck9mxdeq200110en7djgkac1i","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqp001k0en72yqqglz6"},{"post_id":"ck9mxdeq400150en757yzrqv4","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdeqt001n0en7i7nxtwg1"},{"post_id":"ck9mxdeq800170en7bqm1blmy","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxder3001r0en76zduiqq9"},{"post_id":"ck9mxdeqe00190en7pv4jqx9o","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxder8001v0en7rzpbjs1u"},{"post_id":"ck9mxdeqg001d0en78lwdqvmz","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdera001z0en7i55kfv2r"},{"post_id":"ck9mxdeql001f0en7chutt43p","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxderd00230en7pyovgivw"},{"post_id":"ck9mxdeqn001j0en7mimazjef","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxderl00270en7pcu1mxel"},{"post_id":"ck9mxder9001y0en73hojweiz","category_id":"ck9mxder4001s0en7yxfcyr5r","_id":"ck9mxderq002b0en7g8sys0lu"},{"post_id":"ck9mxdeqp001m0en7sqlnkazo","category_id":"ck9mxder4001s0en7yxfcyr5r","_id":"ck9mxderr002e0en72neocvqo"},{"post_id":"ck9mxdeqw001q0en7deme85c9","category_id":"ck9mxder4001s0en7yxfcyr5r","_id":"ck9mxderu002i0en70kzmcxje"},{"post_id":"ck9mxder6001u0en7zqs9uy4o","category_id":"ck9mxder4001s0en7yxfcyr5r","_id":"ck9mxderz002m0en7no8b7fki"},{"post_id":"ck9mxderb00210en7ijvq5ufi","category_id":"ck9mxdert002h0en7optv14se","_id":"ck9mxdes7002v0en7nbmawnzf"},{"post_id":"ck9mxderj00260en73tncmsa1","category_id":"ck9mxdert002h0en7optv14se","_id":"ck9mxdesb00300en7guac5raw"},{"post_id":"ck9mxderm00290en7vwdpdjl9","category_id":"ck9mxdes7002u0en74jug66w6","_id":"ck9mxdesn00370en7g2lc3v76"},{"post_id":"ck9mxdesc00330en720e5dwak","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdess003c0en7vohb9wtu"},{"post_id":"ck9mxderq002d0en73yvmciz0","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdest003g0en72a6ddw1m"},{"post_id":"ck9mxdese00350en7g33jv1xq","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdesv003i0en7cev0yyuo"},{"post_id":"ck9mxdeso00390en7yazj4lzx","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdesy003n0en7w29g141l"},{"post_id":"ck9mxders002g0en73abl4g6w","category_id":"ck9mxdes7002u0en74jug66w6","_id":"ck9mxdet2003p0en76pnfty0w"},{"post_id":"ck9mxdesq003b0en76y3bpcmp","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdet4003t0en75mn4h5pl"},{"post_id":"ck9mxdess003f0en7317tzn4e","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdet6003w0en7ka1081ym"},{"post_id":"ck9mxderu002j0en705xlu27y","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdet900400en7qw4hwofd"},{"post_id":"ck9mxdesu003h0en7ktqmctjb","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeta00430en7n57yzxga"},{"post_id":"ck9mxdesw003m0en7b1cetq5d","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdetc00470en7hxcosuqe"},{"post_id":"ck9mxdery002l0en74szu9goq","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdete004a0en75wo0336t"},{"post_id":"ck9mxdet0003o0en7d23fo85s","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeth004d0en7m98m2074"},{"post_id":"ck9mxdet3003s0en7arrxk445","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdetj004h0en758h1np0l"},{"post_id":"ck9mxdes1002p0en7hslrkx96","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdett004j0en70a71wzw2"},{"post_id":"ck9mxdet5003v0en7tc3kt0pq","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdetv004m0en7q68z4kas"},{"post_id":"ck9mxdet7003z0en7wbja79by","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdety004p0en7l7xd7uvd"},{"post_id":"ck9mxdes5002s0en7c12yxsac","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeu0004s0en7tq1f82yi"},{"post_id":"ck9mxdet900420en7k7owc6pu","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeu1004v0en7rvhd57nl"},{"post_id":"ck9mxdetb00460en7ceq0pxc3","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeu400500en7j0x2d73n"},{"post_id":"ck9mxdes7002w0en7ppsrn379","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeu900530en7h5rvqvy3"},{"post_id":"ck9mxdetd00490en7jq3gtjxs","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeub00570en72akmeyiv"},{"post_id":"ck9mxdetg004c0en7iwtua6ty","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeue005b0en72b1s4c2o"},{"post_id":"ck9mxdesa002z0en7etw6xstd","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeug005e0en79s7eu984"},{"post_id":"ck9mxdeti004g0en70jxx22l1","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeuk005i0en77szroadr"},{"post_id":"ck9mxdets004i0en7qj7ryf0d","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeum005l0en71b4ogrln"},{"post_id":"ck9mxdetu004l0en7j7yv2ffo","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeur005p0en7nnrxcbqm"},{"post_id":"ck9mxdetw004o0en7l6x9wses","category_id":"ck9mxdesc00320en7uapjnml1","_id":"ck9mxdeut005s0en7uu63itvw"},{"post_id":"ck9mxdeu0004u0en7hr46k90g","category_id":"ck9mxden600020en7f58o0lq1","_id":"ck9mxdeux005w0en7bgasni2q"},{"post_id":"ck9mxdeu800520en7n7567213","category_id":"ck9mxden600020en7f58o0lq1","_id":"ck9mxdeuy005z0en7795kt95c"},{"post_id":"ck9mxdety004r0en7xa7at3kb","category_id":"ck9mxdeu2004x0en7kobccw1b","_id":"ck9mxdev200640en7q6h0d5ek"},{"post_id":"ck9mxdeu2004z0en7msscnxtx","category_id":"ck9mxdeu2004x0en7kobccw1b","_id":"ck9mxdev300660en7g1e3mbgd"},{"post_id":"ck9mxdeul005k0en70ydo69d9","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev400690en7h8bs4fn3"},{"post_id":"ck9mxdeuc005a0en7105fr4zc","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev4006b0en78e6yl6qh"},{"post_id":"ck9mxdeun005n0en7081v4z82","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev4006d0en73aj37dzc"},{"post_id":"ck9mxdeur005r0en72x20e5ir","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev4006f0en7cwwdkc8e"},{"post_id":"ck9mxdeue005d0en752k2m039","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev5006h0en71px08b7h"},{"post_id":"ck9mxdeuh005h0en7vpna7jyc","category_id":"ck9mxdeuh005g0en7274dhotz","_id":"ck9mxdev6006j0en70dupn0qd"},{"post_id":"ck9mxdev000620en7hwvaejyf","category_id":"ck9mxdep500080en7ie51fg12","_id":"ck9mxdev6006l0en7oxo76ygp"},{"post_id":"ck9mxdeuv005u0en7jo0xwltg","category_id":"ck9mxdev100630en7c7i6m74t","_id":"ck9mxdev6006n0en77ytbb2u3"}],"PostTag":[{"post_id":"ck9mxdemt00010en71fvoia7p","tag_id":"ck9mxden800030en7v8t4v5qe","_id":"ck9mxdena00040en7sm14d3rp"},{"post_id":"ck9mxdeoy00060en7z995wzd7","tag_id":"ck9mxdep600090en726h5hbur","_id":"ck9mxdepi000f0en7fjgoqdde"},{"post_id":"ck9mxdepj000g0en7ode37i77","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdepp000l0en7q4szhz2a"},{"post_id":"ck9mxdep000070en7ochxr64s","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdepr000o0en7nvmauozl"},{"post_id":"ck9mxdepp000m0en7hddzoabc","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdepu000s0en7msoe1rb9"},{"post_id":"ck9mxdep6000a0en7ad2rvl8e","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdepv000v0en7aapmkw1z"},{"post_id":"ck9mxdeq0000z0en7edaetfvm","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdeq400130en74gze5p1v"},{"post_id":"ck9mxdeq800170en7bqm1blmy","tag_id":"ck9mxdep600090en726h5hbur","_id":"ck9mxdeqg001c0en7chysdyz9"},{"post_id":"ck9mxdepe000b0en7j2e7rmq5","tag_id":"ck9mxdept000r0en7za9lqals","_id":"ck9mxdeqn001i0en73l79erig"},{"post_id":"ck9mxdepe000b0en7j2e7rmq5","tag_id":"ck9mxdeq0000y0en78chnvqva","_id":"ck9mxdeqp001l0en7z1shr32f"},{"post_id":"ck9mxdepe000b0en7j2e7rmq5","tag_id":"ck9mxdeq400140en7lzfd402s","_id":"ck9mxdeqv001p0en795ldaz25"},{"post_id":"ck9mxdepe000b0en7j2e7rmq5","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxder6001t0en7xsn2rgkq"},{"post_id":"ck9mxdepf000c0en7erkzubc3","tag_id":"ck9mxdeqm001h0en7r1gg6po3","_id":"ck9mxder8001x0en7bwamcax7"},{"post_id":"ck9mxdepk000h0en7w9aful8z","tag_id":"ck9mxdeqt001o0en71qeqhbws","_id":"ck9mxderb00200en7ui1fayoj"},{"post_id":"ck9mxdepk000h0en7w9aful8z","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxderj00250en76lhayi8j"},{"post_id":"ck9mxder9001y0en73hojweiz","tag_id":"ck9mxden800030en7v8t4v5qe","_id":"ck9mxderl00280en7ys3zt0wd"},{"post_id":"ck9mxdeps000p0en7byrfkttu","tag_id":"ck9mxder8001w0en7eixg3ang","_id":"ck9mxderq002c0en7dwh0na4r"},{"post_id":"ck9mxdepu000t0en73g8mje5r","tag_id":"ck9mxderj00240en75uywhqtl","_id":"ck9mxderz002n0en7wpz8w5s8"},{"post_id":"ck9mxdepu000t0en73g8mje5r","tag_id":"ck9mxders002f0en72hvhxzxg","_id":"ck9mxdes4002q0en75hgw1r80"},{"post_id":"ck9mxdepu000t0en73g8mje5r","tag_id":"ck9mxdeph000e0en7ryqcefds","_id":"ck9mxdes7002t0en7t9jk7jq4"},{"post_id":"ck9mxdepx000w0en7xya2vtca","tag_id":"ck9mxderx002k0en7o623g3ov","_id":"ck9mxdes9002x0en7clz8j0s3"},{"post_id":"ck9mxdeq200110en7djgkac1i","tag_id":"ck9mxderx002k0en7o623g3ov","_id":"ck9mxdesc00310en7nir3v28v"},{"post_id":"ck9mxdeq400150en757yzrqv4","tag_id":"ck9mxderx002k0en7o623g3ov","_id":"ck9mxdesn00360en7wgwdwnf1"},{"post_id":"ck9mxdeqe00190en7pv4jqx9o","tag_id":"ck9mxdese00340en746xcvx1t","_id":"ck9mxdess003d0en7syj0j1nt"},{"post_id":"ck9mxdeqg001d0en78lwdqvmz","tag_id":"ck9mxdesq003a0en7s6qbhsmi","_id":"ck9mxdesw003l0en7ablds6ua"},{"post_id":"ck9mxdeql001f0en7chutt43p","tag_id":"ck9mxdesv003j0en7o2blqckl","_id":"ck9mxdet4003u0en7b8cfknt0"},{"post_id":"ck9mxdeqn001j0en7mimazjef","tag_id":"ck9mxdet2003q0en7ift78ms9","_id":"ck9mxdet900410en7now51441"},{"post_id":"ck9mxdeqp001m0en7sqlnkazo","tag_id":"ck9mxdet7003x0en7x36ouw8b","_id":"ck9mxdetd00480en7vrrrqz4s"},{"post_id":"ck9mxdeqw001q0en7deme85c9","tag_id":"ck9mxdetb00450en7rlzxikg4","_id":"ck9mxdeth004f0en7yaxe8qyy"},{"post_id":"ck9mxder6001u0en7zqs9uy4o","tag_id":"ck9mxdeth004e0en7mmgpfqw3","_id":"ck9mxdetw004n0en778dbd8ac"},{"post_id":"ck9mxderb00210en7ijvq5ufi","tag_id":"ck9mxdett004k0en73bzyk1zq","_id":"ck9mxdeu0004t0en7bnjmsp7d"},{"post_id":"ck9mxdetw004o0en7l6x9wses","tag_id":"ck9mxderx002k0en7o623g3ov","_id":"ck9mxdeu2004w0en7naqmbeaw"},{"post_id":"ck9mxderj00260en73tncmsa1","tag_id":"ck9mxdety004q0en7nzno3b9m","_id":"ck9mxdeu800510en7b3wdu50m"},{"post_id":"ck9mxdeu0004u0en7hr46k90g","tag_id":"ck9mxden800030en7v8t4v5qe","_id":"ck9mxdeua00540en72s352d3z"},{"post_id":"ck9mxdeu800520en7n7567213","tag_id":"ck9mxden800030en7v8t4v5qe","_id":"ck9mxdeuc00590en7w4weltks"},{"post_id":"ck9mxderm00290en7vwdpdjl9","tag_id":"ck9mxdeu2004y0en7flw3idc5","_id":"ck9mxdeue005c0en7xszrbyrz"},{"post_id":"ck9mxderq002d0en73yvmciz0","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdeuk005j0en76e9y1c64"},{"post_id":"ck9mxders002g0en73abl4g6w","tag_id":"ck9mxdeug005f0en75swj6sxo","_id":"ck9mxdeur005q0en7nie8ktrw"},{"post_id":"ck9mxderu002j0en705xlu27y","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdeux005x0en7vjr8swnt"},{"post_id":"ck9mxdeuv005u0en7jo0xwltg","tag_id":"ck9mxdeth004e0en7mmgpfqw3","_id":"ck9mxdev000610en73sbkspfj"},{"post_id":"ck9mxdery002l0en74szu9goq","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdev300650en7v2jtznje"},{"post_id":"ck9mxdev000620en7hwvaejyf","tag_id":"ck9mxderx002k0en7o623g3ov","_id":"ck9mxdev300680en7c7hm80r1"},{"post_id":"ck9mxdes1002p0en7hslrkx96","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdev4006a0en7yfyn5g7p"},{"post_id":"ck9mxdes5002s0en7c12yxsac","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdev4006e0en7hi4n2y25"},{"post_id":"ck9mxdes7002w0en7ppsrn379","tag_id":"ck9mxdev4006c0en7hg9iwdcj","_id":"ck9mxdev5006i0en7yfbsqejq"},{"post_id":"ck9mxdesa002z0en7etw6xstd","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdev6006m0en73ub85v33"},{"post_id":"ck9mxdesc00330en720e5dwak","tag_id":"ck9mxdev6006k0en741dcfgs8","_id":"ck9mxdev7006p0en7nh79jqit"},{"post_id":"ck9mxdese00350en7g33jv1xq","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdev7006r0en7tvnu5c03"},{"post_id":"ck9mxdeso00390en7yazj4lzx","tag_id":"ck9mxdev4006c0en7hg9iwdcj","_id":"ck9mxdev8006t0en7iezo51lt"},{"post_id":"ck9mxdesq003b0en76y3bpcmp","tag_id":"ck9mxdev7006s0en7c38v0xbv","_id":"ck9mxdev8006v0en7ld3f4t3r"},{"post_id":"ck9mxdess003f0en7317tzn4e","tag_id":"ck9mxdev6006k0en741dcfgs8","_id":"ck9mxdev9006x0en7qokxemfv"},{"post_id":"ck9mxdesu003h0en7ktqmctjb","tag_id":"ck9mxdev8006w0en7ngi91mp1","_id":"ck9mxdevc006z0en7c1rixsps"},{"post_id":"ck9mxdesw003m0en7b1cetq5d","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevd00710en7t92f4kjs"},{"post_id":"ck9mxdet0003o0en7d23fo85s","tag_id":"ck9mxdev6006k0en741dcfgs8","_id":"ck9mxdevd00730en7gbb7i3ad"},{"post_id":"ck9mxdet3003s0en7arrxk445","tag_id":"ck9mxdevd00720en7ns8wc3fz","_id":"ck9mxdevf00750en7bgjehi9r"},{"post_id":"ck9mxdet5003v0en7tc3kt0pq","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevg00770en7djn3wnd4"},{"post_id":"ck9mxdet7003z0en7wbja79by","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevg00790en7ue85agd4"},{"post_id":"ck9mxdet900420en7k7owc6pu","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevh007b0en7krlhdf0z"},{"post_id":"ck9mxdetb00460en7ceq0pxc3","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevh007d0en7rpzjs4z6"},{"post_id":"ck9mxdetd00490en7jq3gtjxs","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevh007f0en7y6phkns8"},{"post_id":"ck9mxdetg004c0en7iwtua6ty","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevi007h0en7g11c6y9e"},{"post_id":"ck9mxdeti004g0en70jxx22l1","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevi007j0en73h1k51xj"},{"post_id":"ck9mxdets004i0en7qj7ryf0d","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevj007l0en7k502kdmg"},{"post_id":"ck9mxdetu004l0en7j7yv2ffo","tag_id":"ck9mxdeub00580en796i7um3m","_id":"ck9mxdevk007n0en7kgsvbzxm"},{"post_id":"ck9mxdety004r0en7xa7at3kb","tag_id":"ck9mxdevj007m0en7m3e1ms4b","_id":"ck9mxdevk007p0en7w98k4c05"},{"post_id":"ck9mxdeu2004z0en7msscnxtx","tag_id":"ck9mxdevk007o0en7lrdp1l5z","_id":"ck9mxdevl007s0en7kr67qpr9"},{"post_id":"ck9mxdeu2004z0en7msscnxtx","tag_id":"ck9mxdevk007q0en78xtiagzb","_id":"ck9mxdevl007t0en7xgl26rp9"},{"post_id":"ck9mxdeuc005a0en7105fr4zc","tag_id":"ck9mxdevl007r0en7uziel4as","_id":"ck9mxdevm007v0en7fa9u1vw3"},{"post_id":"ck9mxdeue005d0en752k2m039","tag_id":"ck9mxdev6006k0en741dcfgs8","_id":"ck9mxdevm007x0en7169jg0j2"},{"post_id":"ck9mxdeuh005h0en7vpna7jyc","tag_id":"ck9mxdevm007w0en79nk74n0c","_id":"ck9mxdevn007z0en7kf4gr8jx"},{"post_id":"ck9mxdeul005k0en70ydo69d9","tag_id":"ck9mxdevm007y0en77te09vni","_id":"ck9mxdevn00810en77k9xutir"},{"post_id":"ck9mxdeun005n0en7081v4z82","tag_id":"ck9mxdevn00800en71qyp8g1x","_id":"ck9mxdevp00830en7qhzq0rhq"},{"post_id":"ck9mxdeur005r0en72x20e5ir","tag_id":"ck9mxdevo00820en7tp2uhuci","_id":"ck9mxdevs00850en7urbin7lg"},{"post_id":"ck9mxdeux005y0en7n9m1uwpv","tag_id":"ck9mxdevp00840en7vtq1k33f","_id":"ck9mxdevs00860en7pwwsjk0e"}],"Tag":[{"name":"other","_id":"ck9mxden800030en7v8t4v5qe"},{"name":"ansible-playbook","_id":"ck9mxdep600090en726h5hbur"},{"name":"ansible-module","_id":"ck9mxdeph000e0en7ryqcefds"},{"name":"github","_id":"ck9mxdept000r0en7za9lqals"},{"name":"http","_id":"ck9mxdeq0000y0en78chnvqva"},{"name":"https","_id":"ck9mxdeq400140en7lzfd402s"},{"name":"ansible-error","_id":"ck9mxdeqm001h0en7r1gg6po3"},{"name":"windows","_id":"ck9mxdeqt001o0en71qeqhbws"},{"name":"ansible-help","_id":"ck9mxder8001w0en7eixg3ang"},{"name":"include_vars","_id":"ck9mxderj00240en75uywhqtl"},{"name":"delegate_to","_id":"ck9mxders002f0en72hvhxzxg"},{"name":"ansible","_id":"ck9mxderx002k0en7o623g3ov"},{"name":"ansible-roles","_id":"ck9mxdese00340en746xcvx1t"},{"name":"ansible-template","_id":"ck9mxdesq003a0en7s6qbhsmi"},{"name":"ansible-variables","_id":"ck9mxdesv003j0en7o2blqckl"},{"name":"ansible-learn","_id":"ck9mxdet2003q0en7ift78ms9"},{"name":"monitor","_id":"ck9mxdet7003x0en7x36ouw8b"},{"name":"ci","_id":"ck9mxdetb00450en7rlzxikg4"},{"name":"tools","_id":"ck9mxdeth004e0en7mmgpfqw3"},{"name":"dcoker","_id":"ck9mxdett004k0en73bzyk1zq"},{"name":"podman","_id":"ck9mxdety004q0en7nzno3b9m"},{"name":"pipeline","_id":"ck9mxdeu2004y0en7flw3idc5"},{"name":"shell","_id":"ck9mxdeub00580en796i7um3m"},{"name":"jenkins","_id":"ck9mxdeug005f0en75swj6sxo"},{"name":"file","_id":"ck9mxdev4006c0en7hg9iwdcj"},{"name":"linux","_id":"ck9mxdev6006k0en741dcfgs8"},{"name":"nas","_id":"ck9mxdev7006s0en7c38v0xbv"},{"name":"learn","_id":"ck9mxdev8006w0en7ngi91mp1"},{"name":"progress","_id":"ck9mxdevd00720en7ns8wc3fz"},{"name":"ipv6","_id":"ck9mxdevj007m0en7m3e1ms4b"},{"name":"nat","_id":"ck9mxdevk007o0en7lrdp1l5z"},{"name":"internet","_id":"ck9mxdevk007q0en78xtiagzb"},{"name":"mysql","_id":"ck9mxdevl007r0en7uziel4as"},{"name":"standard","_id":"ck9mxdevm007w0en79nk74n0c"},{"name":"pip","_id":"ck9mxdevm007y0en77te09vni"},{"name":"web","_id":"ck9mxdevn00800en71qyp8g1x"},{"name":"cloud","_id":"ck9mxdevo00820en7tp2uhuci"},{"name":"git","_id":"ck9mxdevp00840en7vtq1k33f"}]}}